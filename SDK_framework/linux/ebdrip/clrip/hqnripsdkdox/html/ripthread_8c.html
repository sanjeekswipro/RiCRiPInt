<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: ripthread.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>ripthread.c File Reference</h1>
<p>Example implementation of corerip integration: Starting the RIP.  
<a href="#_details">More...</a></p>
<code>#include &lt;locale.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="hqcstass_8h.html">hqcstass.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqstr_8h.html">hqstr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dlliface_8h.html">dlliface.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swstart_8h.html">swstart.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swdevice_8h.html">swdevice.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swtrace_8h.html">swtrace.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="kit_8h.html">kit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skinkit_8h.html">skinkit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="probelog_8h.html">probelog.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rdrapi_8h.html">rdrapi.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add389119aff8555370d57762d9524266"></a><!-- doxytag: member="ripthread.c::RipExit" ref="add389119aff8555370d57762d9524266" args="(int32 n, uint8 *text)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#add389119aff8555370d57762d9524266">RipExit</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> n, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RipExit will be called if for some reason the rip exits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#aeac4d59165fb75aea68cf8cea6bf4f91">RipReboot</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RIP will call back on this function if the interpreter reboots.  <a href="#aeac4d59165fb75aea68cf8cea6bf4f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf1ebf27a08a7bba08672aece3ac6cc"></a><!-- doxytag: member="ripthread.c::RipWarn" ref="a6cf1ebf27a08a7bba08672aece3ac6cc" args="(uint8 *buffer)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a6cf1ebf27a08a7bba08672aece3ac6cc">RipWarn</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RipWarn. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab4ec127a624caf97820ae6a1ad24dd19">SwLeSetTraceHandler</a> (<a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *handler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a probe callback function to capture fine-grained tracing information.  <a href="group__skinkit.html#gab4ec127a624caf97820ae6a1ad24dd19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gabd9b960c1dabca86da6695cbf5691c7b">SwLeTraceEnable</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> trace, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a probe to capture fine-grained tracing information.  <a href="group__skinkit.html#gabd9b960c1dabca86da6695cbf5691c7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8f04bbe0cdae9a4b9c10214f90cf8001">SwLeProbe</a> (int trace_id, int trace_type, intptr_t designator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call the skinkit trace handler, if installed.  <a href="group__skinkit.html#ga8f04bbe0cdae9a4b9c10214f90cf8001"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1e806219fb4f02a06013361a43c983"></a><!-- doxytag: member="ripthread.c::InitRipMemory" ref="adf1e806219fb4f02a06013361a43c983" args="(size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#adf1e806219fb4f02a06013361a43c983">InitRipMemory</a> (size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise memory for RIP, and call <a class="el" href="swstart_8h.html#a537ae5b11a4df592dd457e1f8883f036" title="The core RIP provides this function.">SwInit()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga428d64db39435d1daa0fbdcb5d5a553d">SwLeAddCustomDevices</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nCustomDevices, <a class="el" href="structDeviceType.html">DEVICETYPE</a> **ppCustomDevices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds DEVICETYPE* objects to the array passed to the RIP during startup.  <a href="group__skinkit.html#ga428d64db39435d1daa0fbdcb5d5a553d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga9ad325e19e38b2607563c50964bb9244">SwLeSetRipRendererThreads</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nThreads)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of renderer threads. Takes effect when the RIP is next started.  <a href="group__skinkit.html#ga9ad325e19e38b2607563c50964bb9244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b6fa6a5883ff25afb6ccbab0f5c326"></a><!-- doxytag: member="ripthread.c::StartRip" ref="ac3b6fa6a5883ff25afb6ccbab0f5c326" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#ac3b6fa6a5883ff25afb6ccbab0f5c326">StartRip</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the environment for SwDllStart() and then calls it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af47e9947a2cc999e5b6c3db5b5836542"></a><!-- doxytag: member="ripthread.c::setTickleTimerFunctions" ref="af47e9947a2cc999e5b6c3db5b5836542" args="(SwStartTickleTimerFn *pfnSwStartTickleTimer, SwStopTickleTimerFn *pfnSwStopTickleTimer)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#af47e9947a2cc999e5b6c3db5b5836542">setTickleTimerFunctions</a> (SwStartTickleTimerFn *pfnSwStartTickleTimer, SwStopTickleTimerFn *pfnSwStopTickleTimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Skin-internal function to support <code><a class="el" href="group__skinkit.html#ga0a34398673384fea0f8529de48d7be6f" title="Allows the caller to supply timers for triggering the tickle callbacks.">SwLeSetTickleTimerFunctions()</a></code>. <br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605359e200aab9d7813c49835f4b861a"></a><!-- doxytag: member="ripthread.c::interrupt_signal_seen" ref="a605359e200aab9d7813c49835f4b861a" args="" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a605359e200aab9d7813c49835f4b861a">interrupt_signal_seen</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to communicate the arrival of an interrupt signal to the tickle function in egconfig.c. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSWSTART.html">SWSTART</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a390b1d9f52ff5f8c2394844ca8932593">memory</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSWSTART.html">SWSTART</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#ae54cdd9b26cd3e25c505f218455d5701">starters</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static DllFuncs&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a3a4279ae1872561398b3c1857e37b3c3">dllFuncs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#ad55a532bb0e6a0c550c1575fff36da0d">Fs_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The device type structure for the file system devices. This is a specific example of the structure defined in PR5.8.  <a href="#ad55a532bb0e6a0c550c1575fff36da0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8d2fd3226e253b0351b9f9e9c9db26d"></a><!-- doxytag: member="ripthread.c::Monitor_Device_Type" ref="af8d2fd3226e253b0351b9f9e9c9db26d" args="" -->
<a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#af8d2fd3226e253b0351b9f9e9c9db26d">Monitor_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the function entry points for the monitor device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f0a5223a060c01c420d5809c1e7f6b7"></a><!-- doxytag: member="ripthread.c::Config_Device_Type" ref="a5f0a5223a060c01c420d5809c1e7f6b7" args="" -->
<a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a5f0a5223a060c01c420d5809c1e7f6b7">Config_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The config device type structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade6fd642d130e5d7417ea8a00f81a434"></a><!-- doxytag: member="ripthread.c::Stream_Device_Type" ref="ade6fd642d130e5d7417ea8a00f81a434" args="" -->
<a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#ade6fd642d130e5d7417ea8a00f81a434">Stream_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The pipeline input device type structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4157634fcbda04420d0d4b32431a1801"></a><!-- doxytag: member="ripthread.c::Progress_Device_Type" ref="a4157634fcbda04420d0d4b32431a1801" args="" -->
<a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#a4157634fcbda04420d0d4b32431a1801">Progress_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The DEVICETYPE object describing the callbacks in this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html#af22690d4637c1091c9577c649ea13cd3">RAM_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RAM input device type structure.  <a href="#af22690d4637c1091c9577c649ea13cd3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Example implementation of corerip integration: Starting the RIP. </p>
<p>The <a class="el" href="ripthread_8c.html#ac3b6fa6a5883ff25afb6ccbab0f5c326" title="Sets up the environment for SwDllStart() and then calls it.">StartRip()</a> function sets up the environment for SwDllStart by allocating memory for the rip and gathering together all the devices it requires. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6e"></a><!-- doxytag: member="ripthread.c::@57" ref="afa9be5679ab03d785820f2474c5ccc6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indexes into <code>memory</code> structure </p>

</div>
</div>
<a class="anchor" id="ae6dceca96ec2c7a1b4aa211264a87ef6"></a><!-- doxytag: member="ripthread.c::@58" ref="ae6dceca96ec2c7a1b4aa211264a87ef6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indexes into <code>starters</code> structure </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aeac4d59165fb75aea68cf8cea6bf4f91"></a><!-- doxytag: member="ripthread.c::RipReboot" ref="aeac4d59165fb75aea68cf8cea6bf4f91" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void RipReboot </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The RIP will call back on this function if the interpreter reboots. </p>
<p>A reboot of the interpreter is a "soft" reboot. This callback allows the host application to react to the situation where the RIP's job server loop has reset itself. This can happen due to a serious error during processing of a job, or because the job itself has called the PostScript <code>quit</code> operator explicitly. The RIP restarts its server loop automatically and continues running.</p>
<p>The application may wish to react by soft-rebooting one or more of its own modules, but no specific actions are required by the RIP. Any modules that are shutdown by this function should also be re-started. A reboot of the interpreter does not necessarily mean that the host application is shutting down, although it can, of course, choose to do so.</p>
<p>A client reboot callback can be registed via <a class="el" href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54" title="Allows the caller to supply callback function to be called when the RIP reboots.">SwLeSetRipRebootFunction()</a>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a3a4279ae1872561398b3c1857e37b3c3"></a><!-- doxytag: member="ripthread.c::dllFuncs" ref="a3a4279ae1872561398b3c1857e37b3c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DllFuncs <a class="el" href="ripthread_8c.html#a3a4279ae1872561398b3c1857e37b3c3">dllFuncs</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
{
  <a class="code" href="ripthread_8c.html#add389119aff8555370d57762d9524266" title="RipExit will be called if for some reason the rip exits.">RipExit</a>,
  <a class="code" href="ripthread_8c.html#aeac4d59165fb75aea68cf8cea6bf4f91" title="The RIP will call back on this function if the interpreter reboots.">RipReboot</a>,
  HqCustomAssert,
  HqCustomTrace,
  <a class="code" href="ripthread_8c.html#a6cf1ebf27a08a7bba08672aece3ac6cc" title="RipWarn.">RipWarn</a>,
   0 , 
   0 , 
}
</pre></div><p>Functions provided by app for use by corerip library </p>

</div>
</div>
<a class="anchor" id="ad55a532bb0e6a0c550c1575fff36da0d"></a><!-- doxytag: member="ripthread.c::Fs_Device_Type" ref="ad55a532bb0e6a0c550c1575fff36da0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDeviceType.html">DEVICETYPE</a> <a class="el" href="ripthread_8c.html#ad55a532bb0e6a0c550c1575fff36da0d">Fs_Device_Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The device type structure for the file system devices. This is a specific example of the structure defined in PR5.8. </p>
<p>Device type list</p>
<p>Points to note: (a) of the function pointers included in this structure, only the tickle function may be a NULL pointer. The rest must be filled in with stub routines which at least set the last error flag appropriately. The dismount call does nothing else but indicates success with its return code; however the buffer size function indicates failure, which means that a fixed size buffer will be allocated see PR5.8.2 and PR5.8.26. (b) the device is "relative" (it can support named files, unlike, for example, a serial line). This means that when an attempt is made to open a named file in PostScript unqualified by a device, devices of this type will each receive open requests until one does not report an "undefined" error. See PR5.8.2 (c) the device is "writable": this means that devices of this type will be considered when trying to open a file for writing from PostScript. </p>

</div>
</div>
<a class="anchor" id="a390b1d9f52ff5f8c2394844ca8932593"></a><!-- doxytag: member="ripthread.c::memory" ref="a390b1d9f52ff5f8c2394844ca8932593" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSWSTART.html">SWSTART</a> <a class="el" href="ripthread_8c.html#a390b1d9f52ff5f8c2394844ca8932593">memory</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
  { 0, { 0 } }, 
  {  (14) , { 0 } }, 
  {  (5) , { 0 } },
  {  (17) , { 0 } },
  {  (-1) , { 0 } }, 
  {  (-1) , { 0 } } 
}
</pre></div><p>Structures required for passing to SwDllInit </p>

</div>
</div>
<a class="anchor" id="af22690d4637c1091c9577c649ea13cd3"></a><!-- doxytag: member="ripthread.c::RAM_Device_Type" ref="af22690d4637c1091c9577c649ea13cd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDeviceType.html">DEVICETYPE</a> <a class="el" href="ripthread_8c.html#af22690d4637c1091c9577c649ea13cd3">RAM_Device_Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The RAM input device type structure. </p>
<p>externally defined device types of the sub-devices of this device. </p>

</div>
</div>
<a class="anchor" id="ae54cdd9b26cd3e25c505f218455d5701"></a><!-- doxytag: member="ripthread.c::starters" ref="ae54cdd9b26cd3e25c505f218455d5701" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSWSTART.html">SWSTART</a> <a class="el" href="ripthread_8c.html#ae54cdd9b26cd3e25c505f218455d5701">starters</a>[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
  {  (4)  , { 0 } },



  {  (-1) , { 0 } }
}
</pre></div><p>Structures required for passing to SwDllStart </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
