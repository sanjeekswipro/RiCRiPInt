<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: config.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>config.c File Reference</h1>
<p>Implementation of the config (configuration) device type.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="kit_8h.html">kit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swdevice_8h.html">swdevice.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skindevs_8h.html">skindevs.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static DEVICE_FILEDESCRIPTOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ab2eb4ff9d4ee9113df25758c1e38bfc4">config_open_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The open file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a>.  <a href="#ab2eb4ff9d4ee9113df25758c1e38bfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a5f42dfd153dea2649e00836390e4f6f4">config_read_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read_file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga1773113a2fdf552abfbf7f77479ef837" title="Call to read data from file on device.">DEVICELIST_READ()</a>.  <a href="#a5f42dfd153dea2649e00836390e4f6f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a572dc9d532ae612897922683dff5221f"></a><!-- doxytag: member="config.c::config_write_file" ref="a572dc9d532ae612897922683dff5221f" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a572dc9d532ae612897922683dff5221f">config_write_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stub with correct protopype function pointer. See <a class="el" href="group__PLUGIN__swdevice.html#gaf9d8d01fc7f291720ee20a0424898198" title="Call to write data to file on device.">DEVICELIST_WRITE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29cf816a573ba915d8349b88d1d67410"></a><!-- doxytag: member="config.c::config_close_file" ref="a29cf816a573ba915d8349b88d1d67410" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a29cf816a573ba915d8349b88d1d67410">config_close_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The close_file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga3c3c68995e66050fb42a9caa282aebc2" title="Call to close file on device.">DEVICELIST_CLOSE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68467c477d1ad21260542e43b9fb092f"></a><!-- doxytag: member="config.c::config_seek_file" ref="a68467c477d1ad21260542e43b9fb092f" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *destination, int32 flags)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a68467c477d1ad21260542e43b9fb092f">config_seek_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The seek_file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f" title="Call to seek file on device.">DEVICELIST_SEEK()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a1375cd68966bc127340347119c96338b">config_bytes_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bytes_file routine for the config device type, the manifestation in C of the bytesavailable PostScript operator. See <a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440" title="Call to get bytes available for open file.">DEVICELIST_BYTES()</a>.  <a href="#a1375cd68966bc127340347119c96338b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae006f540e8bd39bc5d895c90cf26a76a"></a><!-- doxytag: member="config.c::config_status_file" ref="ae006f540e8bd39bc5d895c90cf26a76a" args="(DEVICELIST *dev, uint8 *filename, STAT *statbuff)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ae006f540e8bd39bc5d895c90cf26a76a">config_status_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to check status of file. See <a class="el" href="group__PLUGIN__swdevice.html#ga763b61136b7308649b2fcc83edb2f9d0" title="Call to check status of file.">DEVICELIST_STATUS_FILE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a048cdbdd92de1d6fc1b7a4062c83d71a"></a><!-- doxytag: member="config.c::config_start_file_list" ref="a048cdbdd92de1d6fc1b7a4062c83d71a" args="(DEVICELIST *dev, uint8 *pattern)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a048cdbdd92de1d6fc1b7a4062c83d71a">config_start_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to start listing files. See <a class="el" href="group__PLUGIN__swdevice.html#ga68226e680ebb5b7639848f682c0b2a9d" title="Call to start listing files.">DEVICELIST_START_LIST()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e500717d1991867adff1d0e9ccd3deb"></a><!-- doxytag: member="config.c::config_next_file" ref="a1e500717d1991867adff1d0e9ccd3deb" args="(DEVICELIST *dev, void **handle, uint8 *pattern, FILEENTRY *entry)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a1e500717d1991867adff1d0e9ccd3deb">config_next_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void **handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="structFILEENTRY.html">FILEENTRY</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get next file in list. See <a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0d9bcabe58d740e319140931df780cd"></a><!-- doxytag: member="config.c::config_end_file_list" ref="ae0d9bcabe58d740e319140931df780cd" args="(DEVICELIST *dev, void *handle)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ae0d9bcabe58d740e319140931df780cd">config_end_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to end listing. See <a class="el" href="group__PLUGIN__swdevice.html#gaa3b7ed2931a39bbdf4fb73cfcaeb3da3" title="Call to end listing.">DEVICELIST_END_LIST()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2767834795b04871e88e86a55898c163"></a><!-- doxytag: member="config.c::config_rename_file" ref="a2767834795b04871e88e86a55898c163" args="(DEVICELIST *dev, uint8 *file1, uint8 *file2)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a2767834795b04871e88e86a55898c163">config_rename_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file1, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename file on the device. See <a class="el" href="group__PLUGIN__swdevice.html#ga7c109d56a1e761215b1a6bdcdeba80de" title="Rename file on the device.">DEVICELIST_RENAME()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c1a00e61a5297143c7937104ef970f5"></a><!-- doxytag: member="config.c::config_delete_file" ref="a7c1a00e61a5297143c7937104ef970f5" args="(DEVICELIST *dev, uint8 *filename)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a7c1a00e61a5297143c7937104ef970f5">config_delete_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove file from device. See <a class="el" href="group__PLUGIN__swdevice.html#gad1ca81dc9ecd629b09e4ac0fcabc2dd6" title="Remove file from device.">DEVICELIST_DELETE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37528e90b0f0f60f96f75debe26ea4f2"></a><!-- doxytag: member="config.c::config_set_param" ref="a37528e90b0f0f60f96f75debe26ea4f2" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a37528e90b0f0f60f96f75debe26ea4f2">config_set_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to set device parameter. See <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1204aa07316328556e7aeba13ad3cb6f"></a><!-- doxytag: member="config.c::config_start_param" ref="a1204aa07316328556e7aeba13ad3cb6f" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a1204aa07316328556e7aeba13ad3cb6f">config_start_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to start getting device parameters. See <a class="el" href="group__PLUGIN__swdevice.html#ga7c655506f815c9f606fa361a97a89e12" title="Call to start getting device parameters.">DEVICELIST_START_PARAM()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7525cf799937fb3b6c8252f19d63eb"></a><!-- doxytag: member="config.c::config_get_param" ref="abe7525cf799937fb3b6c8252f19d63eb" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#abe7525cf799937fb3b6c8252f19d63eb">config_get_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to start getting device parameters. See <a class="el" href="group__PLUGIN__swdevice.html#ga28179fe012380bfc5b2bee0962865d06" title="Call to get the next device parameter.">DEVICELIST_GET_PARAM()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671145a3004df8c4f4cd408e5ad82d4c"></a><!-- doxytag: member="config.c::config_status_device" ref="a671145a3004df8c4f4cd408e5ad82d4c" args="(DEVICELIST *dev, DEVSTAT *devstat)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a671145a3004df8c4f4cd408e5ad82d4c">config_status_device</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVSTAT *devstat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get the status of the device. <a class="el" href="group__PLUGIN__swdevice.html#ga5717f71a4260330832b331b644e9dd05" title="Call to get the status of the device.">DEVICELIST_STATUS_DEVICE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab67484f1fa2b93ed5eed163836723df7"></a><!-- doxytag: member="config.c::config_buffsize" ref="ab67484f1fa2b93ed5eed163836723df7" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ab67484f1fa2b93ed5eed163836723df7">config_buffsize</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The buffsize routine for the config device type. Not required, but provided for example purposes. The 'len' parameter of the <a class="el" href="config_8c.html#a5f42dfd153dea2649e00836390e4f6f4" title="The read_file routine for the config device type. See DEVICELIST_READ().">config_read_file()</a> function will never exceed the amount we indicate with this function. See <a class="el" href="group__PLUGIN__swdevice.html#ga0c5da82f8cac53a9a5f4d4e6197124a5" title="Optional call to return the buffer size that a device requires for best operation...">DEVICELIST_BUFFER_SIZE()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3744cd72c3a4733539a4733c44817bfa"></a><!-- doxytag: member="config.c::config_spare" ref="a3744cd72c3a4733539a4733c44817bfa" args="(void)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a3744cd72c3a4733539a4733c44817bfa">config_spare</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spare slot. See DEVICELIST_SPARE(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace6c3d38d351c28930485d107823d430"></a><!-- doxytag: member="config.c::config_set_last_error" ref="ace6c3d38d351c28930485d107823d430" args="(int32 error)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ace6c3d38d351c28930485d107823d430">config_set_last_error</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The stub functions for the configuration device to provide appropriate return codes for slots which have nothing else to do. <br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#ae57acb7ac185aa4d869a00403118859a">config_fd</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a928aae444f3de2be77cea75580080772">config_status</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to maintain the state of the device between read calls.  <a href="#a928aae444f3de2be77cea75580080772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f0a5223a060c01c420d5809c1e7f6b7"></a><!-- doxytag: member="config.c::Config_Device_Type" ref="a5f0a5223a060c01c420d5809c1e7f6b7" args="" -->
<a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html#a5f0a5223a060c01c420d5809c1e7f6b7">Config_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The config device type structure. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of the config (configuration) device type. </p>
<p>This is a minimal implementation of the config device type. It provides all the required functions, but only limited functionality.</p>
<p>The purpose of the configuration device type is twofold:</p>
<ul>
<li>to set up the environment in which PostScript jobs run</li>
<li>to provide the RIP with jobs to run.</li>
</ul>
<p>In addition, this file illustrates the use of tickle functions to provide interrupts to the interpreter.</p>
<p>The RIP simply runs the configuration file. Therefore the read function of the configuration device provides PostScript fragments which the RIP executes. Like a PostScript procedure, this PostScript is expected to manipulate the operand stack. In particular it consumes no operands, and leaves a boolean object on top of the stack. If the boolean is true, two further items are expected on the stack: a pair of file objects, the first of which is a file open for reading which is the PostScript job to be executed, and second is a file opened for writing, to which anything written to PostScript's stdout% pseudo-device will be directed. If the boolean is false, the system will re-run the config device again.</p>
<p>Therefore the read call for the config device could just return in the supplied buffer the characters</p>
<pre>
   (%console%)(r) file (%console%)(w) file true
 </pre><p>on the first call; and no characters on the second call (indicating end-of-file to the RIP) - and the RIP would then act on the PostScript shown as described above, causing it to read PostScript from a file opened on a device called %console%. %console% must have been mounted and had its device type set in order for this to succeed. Normally this would be done in the file %osSys/ExtraDevices, but could be done anywhere - for example it could be included in the PostScript emitted by the %config% device.</p>
<p>Normally, however, the PostScript emitted by %config% will be somewhat more complex. The device may require to choose its input from among several possible input sources; and it will certainly want to set up some default environment in which the job may run. Even if the PostScript emitted is quite simple, the implementation of the %config% device may be quite complex - involving perhaps manipulating user interface dialogs which allow the user to select the job to be run.</p>
<p>A useful technique appropriate in some circumstances is to implement the function of the config device wholly in PostScript in which case the PostScript emitted by the config% device would simply be</p>
<pre>
   (%osmy-config-file) run
 </pre><p> and the PostScript file my-config-file on the %os% device would then be responsible for putting the two files and true onto the operand stack.</p>
<p>However, in our example below, we obtain this configuration PostScript by calling <a class="el" href="kit_8h.html#a966a16a7ec47b0f958ce38266c940bb0" title="This method is called from the RIP thread by the config device when it is ready for...">KGetConfigData()</a>, repeatedly if necessary. This returns the PostScript provided to <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a>.</p>
<p>Finally, in order for the RIP to run %config%, the device must exist. It should be created (that is, mounted, enabled and assigned a device type number) in the Sys/ExtraDevices file, using PostScript similar to this:</p>
<pre>
   statusdict begin
   (config%) dup devmount pop
   &lt;&lt;
     /Password 0
     /DeviceType 16#ffff0001
     /Enable true
   &gt;&gt; setdevparams
   end
 </pre><p>(See <a class="el" href="ripthread_8h.html" title="RIP lifecycle code.">ripthread.h</a> for a discussion of how 16#ffff0001 arises as the device type number).</p>
<p>This config device implementation accepts no device parameters. It is a non-relative device, so therefore many routines can be provided as stubs only. Furthermore, it will not be written to by the RIP as supplied so that functionality need not be supported. (However, you might consider implementing a write call on %config% for your own use, in place of a separate device type to receive PostScript messages written to standard error or standard output - see the discussion alongside the definition of the %console% device in <a class="el" href="monitor_8c.html">monitor.c</a>).</p>
<p>Note however that <a class="el" href="config_8c.html#a1375cd68966bc127340347119c96338b" title="The bytes_file routine for the config device type, the manifestation in C of the...">config_bytes_file()</a> (bytesavailable in PostScript) MUST be implemented for the config device in order that the RIP can determine whether or not to run the %config% file - see Programmer's Reference Manual Chapter 7 entitled "The
 Configuration Device".</p>
<p>This example also illustrates the use of the buffer size function, <a class="el" href="config_8c.html#ab67484f1fa2b93ed5eed163836723df7" title="The buffsize routine for the config device type. Not required, but provided for example...">config_buffsize()</a>. This is not a requirement, but since only a very small buffer is required in this example, we choose not to allow the RIP to waste space on a larger buffer as it would if this routine were not implemented. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1375cd68966bc127340347119c96338b"></a><!-- doxytag: member="config.c::config_bytes_file" ref="a1375cd68966bc127340347119c96338b" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *bytes, int32 reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> config_bytes_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bytes_file routine for the config device type, the manifestation in C of the bytesavailable PostScript operator. See <a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440" title="Call to get bytes available for open file.">DEVICELIST_BYTES()</a>. </p>
<p>This routine has special significance for the config device. This implementation simply returns the length of the PostScript string we would supply. If the amount of data which will be emitted is not known exactly, any strictly positive number (e.g. 1) will cause the RIP to proceed to open the config% file rather than continuing to idle.</p>
<p>If there is no input pending, this function should return 0 (NOT -1 which would be an error condition), so that the RIP can continue to do any idle-time tasks allocated to it. It will then call bytesavailable at frequent intervals until there is some input pending. This is preferable to blocking either here or in the read or open functions when this condition arises. </p>

</div>
</div>
<a class="anchor" id="ab2eb4ff9d4ee9113df25758c1e38bfc4"></a><!-- doxytag: member="config.c::config_open_file" ref="ab2eb4ff9d4ee9113df25758c1e38bfc4" args="(DEVICELIST *dev, uint8 *filename, int32 openflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static DEVICE_FILEDESCRIPTOR config_open_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>openflags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The open file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a>. </p>
<p>Since we are not implementing write functionality, it will be an error to attempt an open for other than reading. Also the semantics of the device mean that it does not make sense to have more than one file open at once for the whole device type, therefore this too is an error. </p>

</div>
</div>
<a class="anchor" id="a5f42dfd153dea2649e00836390e4f6f4"></a><!-- doxytag: member="config.c::config_read_file" ref="a5f42dfd153dea2649e00836390e4f6f4" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> config_read_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The read_file routine for the config device type. See <a class="el" href="group__PLUGIN__swdevice.html#ga1773113a2fdf552abfbf7f77479ef837" title="Call to read data from file on device.">DEVICELIST_READ()</a>. </p>
<p>On the first read, we emit the PostScript required to set up the environment and set up the two files and true on the operand stack as described at the head of the file.</p>
<p>On the second call we return zero bytes which indicates end of file to the RIP. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ae57acb7ac185aa4d869a00403118859a"></a><!-- doxytag: member="config.c::config_fd" ref="ae57acb7ac185aa4d869a00403118859a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="config_8c.html#ae57acb7ac185aa4d869a00403118859a">config_fd</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>"file descriptor" for config device </p>

</div>
</div>
<a class="anchor" id="a928aae444f3de2be77cea75580080772"></a><!-- doxytag: member="config.c::config_status" ref="a928aae444f3de2be77cea75580080772" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="config_8c.html#a928aae444f3de2be77cea75580080772">config_status</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to maintain the state of the device between read calls. </p>
<p>For a more comprehensive implementation this would be considerably more complex since more than one buffer full of information may have to be returned by the read file function. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
