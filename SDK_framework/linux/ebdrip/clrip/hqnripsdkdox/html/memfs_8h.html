<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: memfs.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_30ea0f072a45d4235daf97fe839164a5.html">export</a>
  </div>
</div>
<div class="contents">
<h1>memfs.h File Reference</h1>
<p>Simple API for managing an in-memory, virtual file system.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="std_8h.html">std.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__MFSFILE.html">_MFSFILE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a file.  <a href="struct__MFSFILE.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__MFSDIR.html">_MFSDIR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a directory.  <a href="struct__MFSDIR.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__MFSNODE.html">_MFSNODE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a node, which is a named entry within the filesystem, and is either a file or a directory.  <a href="struct__MFSNODE.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__MFSITERELEMENT.html">_MFSITERELEMENT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper structure for storing the state of an iteration.  <a href="struct__MFSITERELEMENT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__MFSITERSTATE.html">_MFSITERSTATE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the current state of an iteration.  <a href="struct__MFSITERSTATE.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a6d7ee53640b6fe9bc528e2e349c6ea96">COMPRESS_NEW_FILES</a>&nbsp;&nbsp;&nbsp;TRUE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tune this to decide whether compression should be applied to new files created at run-time.  <a href="#a6d7ee53640b6fe9bc528e2e349c6ea96"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4c0e228dbfc705868f5e8c57b831853"></a><!-- doxytag: member="memfs.h::MFSFILE" ref="ae4c0e228dbfc705868f5e8c57b831853" args="" -->
typedef struct <a class="el" href="struct__MFSFILE.html">_MFSFILE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#ae4c0e228dbfc705868f5e8c57b831853">MFSFILE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc53ada77a3181c8f2c8efa320e14bc2"></a><!-- doxytag: member="memfs.h::MFSDIR" ref="acc53ada77a3181c8f2c8efa320e14bc2" args="" -->
typedef struct <a class="el" href="struct__MFSDIR.html">_MFSDIR</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#acc53ada77a3181c8f2c8efa320e14bc2">MFSDIR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a directory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__MFSNODE.html">_MFSNODE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a5d716dfffbbe920f82b2c77a47816483">MFSNODE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a node, which is a named entry within the filesystem, and is either a file or a directory.  <a href="#a5d716dfffbbe920f82b2c77a47816483"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a149dff2dc199b173cd81b48368ca72e2"></a><!-- doxytag: member="memfs.h::MFSFILEDESC" ref="a149dff2dc199b173cd81b48368ca72e2" args="" -->
typedef struct _MFSFILEDESC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the information required to control access to an open file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe7d376e753978e90fa621cd747260b"></a><!-- doxytag: member="memfs.h::MFSITERELEMENT" ref="a2fe7d376e753978e90fa621cd747260b" args="" -->
typedef struct <a class="el" href="struct__MFSITERELEMENT.html">_MFSITERELEMENT</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a2fe7d376e753978e90fa621cd747260b">MFSITERELEMENT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper structure for storing the state of an iteration. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__MFSITERSTATE.html">_MFSITERSTATE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#afe682f034a5196815609c3fb655d7a47">MFSITERSTATE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the current state of an iteration.  <a href="#afe682f034a5196815609c3fb655d7a47"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="memfs_8h.html#a8628933cde20921c453a6d2607bdad62a826aae261d5f429e66b8ee9f439c6540">MFS_File</a>, 
<a class="el" href="memfs_8h.html#a8628933cde20921c453a6d2607bdad62a4ce62844a36836ae426bc21487a71b0f">MFS_Directory</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A node within the filesystem is either a file or a directory, and we use these markers to indicate which. </p>
 <a href="memfs_8h.html#a8628933cde20921c453a6d2607bdad62">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a67feded02a5ca9f5409efdcab816a96b">MFSFindRelative</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="struct__MFSNODE.html">MFSNODE</a> **ppParent, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate a file node, relative to the given root, according to its pathname.  <a href="#a67feded02a5ca9f5409efdcab816a96b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#af345c05802dcf2b916cec75fa121ac1b">MFSOpen</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openFlags, <a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> **ppDesc, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open or create a file for reading and/or writing.  <a href="#af345c05802dcf2b916cec75fa121ac1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a8752395e361736b14aef4c5851217234">MFSClose</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a file that was previously opened with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.  <a href="#a8752395e361736b14aef4c5851217234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a0670085c171a758c25934ab3dfedf7de">MFSGetFile</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the underlying file from its open descriptor.  <a href="#a0670085c171a758c25934ab3dfedf7de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a559666aba4a9ff415231bef57568badd">MFSRead</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbLen, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a specified number of bytes from the current location of an open file.  <a href="#a559666aba4a9ff415231bef57568badd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a95bd7667a5f6ce08df29a326fa7ff390">MFSWrite</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbLen, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a specified number of bytes to an open file at the current location, expanding the file as necessary.  <a href="#a95bd7667a5f6ce08df29a326fa7ff390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#aa5a5af100d6d7bf19e3a05fbb46eb2cf">MFSWriteString</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, char *pszString, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a specified NUL-terminated character string to an open file at the current location, expanding the file as necessary. The terminating NUL character itself is not written.  <a href="#aa5a5af100d6d7bf19e3a05fbb46eb2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a13abcc96cdda1890358797cec74087be">MFSSeek</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="structHq32x2.html">Hq32x2</a> *pDestination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set (or query) the current the position in an open file.  <a href="#a13abcc96cdda1890358797cec74087be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#abeddd25e694b55a14cab9351c4aea56b">MFSAvail</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="structHq32x2.html">Hq32x2</a> *pAvail, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reasonFlag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes that are currently available to be read from an open file.  <a href="#abeddd25e694b55a14cab9351c4aea56b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#afeb21268e98b1f3b1a0139b22dd4e7aa">MFSSetCompression</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fCompress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controls whether the file's data buffer will be compressed (or re-compressed) when the file is closed.  <a href="#afeb21268e98b1f3b1a0139b22dd4e7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a3ac4bc307460c87476fe6409c9147995">MFSDelete</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a file or directory, and completely release all of its associated memory resources.  <a href="#a3ac4bc307460c87476fe6409c9147995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a25a08607c320c75bb89ae429896b2e4b">MFSRename</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFromName, char *pszToName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename a file, preserving all of its contents and other properties.  <a href="#a25a08607c320c75bb89ae429896b2e4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#aad7116548c147cdb4d352dca4145c361">MFSIterBegin</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, void *pPrivate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an iteration over all or part of the file system.  <a href="#aad7116548c147cdb4d352dca4145c361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a89444976e3dbc882a6ad34aace2fbdc5">MFSIterNext</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Proceed to the first (or next) file in an iteration sequence.  <a href="#a89444976e3dbc882a6ad34aace2fbdc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a35daf840b1298eb97c15e64d025fa7f3">MFSIterEnd</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close an iteration sequence.  <a href="#a35daf840b1298eb97c15e64d025fa7f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a5f65338d066ddde354923d78754a1874">MFSIterNode</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a direct pointer to the <code>MFS_File</code> node of the current iteration step.  <a href="#a5f65338d066ddde354923d78754a1874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a16c6dcdf84410f84ce54015a3c107764">MFSIterNameLength</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fLeadingSlash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the pathname length of the file at the current iteration step.  <a href="#a16c6dcdf84410f84ce54015a3c107764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#ab2f686cf36a402d6dfcfcdbaa313d9fe">MFSIterName</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState, char *pszFilenameBuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> bufLen, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fLeadingSlash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the pathname of the file at the current iteration step.  <a href="#ab2f686cf36a402d6dfcfcdbaa313d9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a0587f175c00c055fc1946afbc329031e">MFSNewRoot</a> (char *pszRootName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and return a completely new root directory node.  <a href="#a0587f175c00c055fc1946afbc329031e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a20b70d273f9ae48d72764195ba389676">MFSCopyTree</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *<a class="el" href="ramdev_8c.html#acd900ede0a17cd5e83852d00f96f59a6">pMFSRoot</a>, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fCopyFileData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and return a completely new filesystem tree by making a recursive copy of the given tree.  <a href="#a20b70d273f9ae48d72764195ba389676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#ace205408816af77dc43b4423e99e9a99">MFSReleaseRoot</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *<a class="el" href="ramdev_8c.html#acd900ede0a17cd5e83852d00f96f59a6">pMFSRoot</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the given root node, and the entire virtual filesystem descended from it.  <a href="#ace205408816af77dc43b4423e99e9a99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html#a7cfe51db1b9db4fcc46adb5e5b216d90">MFSMemUsage</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pNode, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pROMSize, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pRAMSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the amount of memory currently in use by the virtual filesystem descended from the given node.  <a href="#a7cfe51db1b9db4fcc46adb5e5b216d90"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Simple API for managing an in-memory, virtual file system. </p>
<p>This API specifies a simple tree data structure for representing one or more <code>virtual file systems</code>. Each system is modelled as a tree of <code>MFSNODE</code> objects, where each node represents either a file or a directory. A file is always a leaf node, whereas a directory contains pointers down to child nodes. As with any filesystem, each node is assigned a name, meaning that nodes may be addressed using a path. Currently, only 8-bit ASCII filenames are supported. The tree may be arbitrarily nested. (Pathnames are expressed using a forward-slash <code>'/'</code> character as the separator).</p>
<p>These data structures are designed to be statically-declarable, but dynamically-growable. A filesystem need not start off as empty, although it can do. It is possible to write (or generate) a series of static C data declarations to describe the initial state of a whole tree. This leads the way for implementing an "Import Tool", which can scan an existing directory on disk, and represent it as a virtual filesystem within the application's memory. This can eliminate avoid the need for configuration files on disk.</p>
<p>Whether from an empty initial state, or from a pre-declared static state, it is possible to access and modify files, and to create new ones. Such modifications, of course, persist only for the lifetime of the application, since the entire filesystem is held in process-local memory. Functions are provided to open and create files, and for reading and writing data. There are also functions for managing the tree: such as locating, deleting and renaming files. See the individual function descriptions for further details in each case.</p>
<p>The API supports compression and decompression via the ZLIB interface. This happens transparently, but a file's data stream can only be in a compressed state when the file is closed. In order to keep the code simple, live stream-based compression/decompression of open files is <em>not</em> supported. As soon as a file is opened with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, its data stream will become uncompressed in its entirety, and will remain so until the file is closed, whereupon the data will be re-compressed.</p>
<p>When a file system has a statically-declared initial state (as might be generated by an Import Tool), it is likely that the Import Tool will apply compression to the data buffers where possible. If it does so, it <em>must</em> do so via the ZLIB interface. Statically-declared filesystems are expected to be the typical case for compression. However, a policy of compressing dynamically-created MFS files can also be put in place by tuning the <code>COMPRESS_NEW_FILES</code> macro, defined in this header file. If this macro is set to <code>FALSE</code>, no compression will be applied to fresh files created at runtime.</p>
<p>The implementation of this API is thread-safe, to the extent that there is no undocumented global state within the implementation that might prevent concurrent use. However, the tree structures themselves are <em>not</em> protected by this layer. Broadly, this means that concurrent use of this API should be limited to <em>disjoint filesystem trees, or disjoint portions of a single tree</em>. For convenience, there are some exceptions to this general rule, particularly when read-only access is required to files and directories.</p>
<p>This API is primarily aimed at implementing a <em>device</em> in terms of the Core RIP Device Interface. Some of the flags and return codes used here are deliberately specified to match the contracts of the Device Interface. However, this API can also be used standalone, instead of (or even as well as) just providing the support for a device implementation.</p>
<p>As with much of the technology in the Skin Kit, this API aims to be both useful and demonstrative in its own right, but it is not suitable for production use. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6d7ee53640b6fe9bc528e2e349c6ea96"></a><!-- doxytag: member="memfs.h::COMPRESS_NEW_FILES" ref="a6d7ee53640b6fe9bc528e2e349c6ea96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPRESS_NEW_FILES&nbsp;&nbsp;&nbsp;TRUE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tune this to decide whether compression should be applied to new files created at run-time. </p>
<p>See also the <a class="el" href="memfs_8c.html#afeb21268e98b1f3b1a0139b22dd4e7aa" title="Controls whether the file&#39;s data buffer will be compressed (or re-compressed)...">MFSSetCompression()</a> function, which allows the caller to decide whether to apply compression for individual files. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="afe682f034a5196815609c3fb655d7a47"></a><!-- doxytag: member="memfs.h::MFSITERSTATE" ref="afe682f034a5196815609c3fb655d7a47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__MFSITERSTATE.html">_MFSITERSTATE</a>  <a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates the current state of an iteration. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="memfs_8h.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d716dfffbbe920f82b2c77a47816483"></a><!-- doxytag: member="memfs.h::MFSNODE" ref="a5d716dfffbbe920f82b2c77a47816483" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__MFSNODE.html">_MFSNODE</a>  <a class="el" href="struct__MFSNODE.html">MFSNODE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes a node, which is a named entry within the filesystem, and is either a file or a directory. </p>
<p>If this node is a file, then it is a leaf node. If it is a directory, then it contains an array of pointers to the child <code>MFSNODE</code>s.</p>
<p>Nodes do <em>not</em> contain parent pointers. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a8628933cde20921c453a6d2607bdad62"></a><!-- doxytag: member="memfs.h::@65" ref="a8628933cde20921c453a6d2607bdad62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A node within the filesystem is either a file or a directory, and we use these markers to indicate which. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="memfs_8h.html#a5d716dfffbbe920f82b2c77a47816483" title="Describes a node, which is a named entry within the filesystem, and is either a file...">MFSNODE</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8628933cde20921c453a6d2607bdad62a826aae261d5f429e66b8ee9f439c6540"></a><!-- doxytag: member="MFS_File" ref="a8628933cde20921c453a6d2607bdad62a826aae261d5f429e66b8ee9f439c6540" args="" -->MFS_File</em>&nbsp;</td><td>
<p>Denotes an ordinary file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8628933cde20921c453a6d2607bdad62a4ce62844a36836ae426bc21487a71b0f"></a><!-- doxytag: member="MFS_Directory" ref="a8628933cde20921c453a6d2607bdad62a4ce62844a36836ae426bc21487a71b0f" args="" -->MFS_Directory</em>&nbsp;</td><td>
<p>Denotes a directory. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abeddd25e694b55a14cab9351c4aea56b"></a><!-- doxytag: member="memfs.h::MFSAvail" ref="abeddd25e694b55a14cab9351c4aea56b" args="(MFSFILEDESC *pDesc, Hq32x2 *pAvail, int32 reasonFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSAvail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pAvail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>reasonFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the number of bytes that are currently available to be read from an open file. </p>
<p>It is never permissible to call this function concurrently with the same descriptor. It <em>is</em>, however, permissible to call the function concurrently with different descriptors on the same underlying file, <em>provided that there are no open descriptors with write access on the file.</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pAvail</em>&nbsp;</td><td>Receives a count of available bytes upon successful return.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reasonFlag</em>&nbsp;</td><td>One of <code>SW_BYTES_AVAIL_REL</code> or <code>SW_BYTES_TOTAL_ABS</code>, as per the Core RIP Device Interface. Since files are stored in memory, the maximum extent of the data is always known, so precise information can be returned in both cases.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. This return convention is directly compatible with <code>bytes_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a8752395e361736b14aef4c5851217234"></a><!-- doxytag: member="memfs.h::MFSClose" ref="a8752395e361736b14aef4c5851217234" args="(MFSFILEDESC *pDesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a file that was previously opened with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. Note that the Core RIP Device Interfaces uses a different return convention for the <code>open_file()</code> function. When implementing such a function in terms of <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, you must convert TRUE to 0, and FALSE to -1 respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="a20b70d273f9ae48d72764195ba389676"></a><!-- doxytag: member="memfs.h::MFSCopyTree" ref="a20b70d273f9ae48d72764195ba389676" args="(MFSNODE *pMFSRoot, uint32 fCopyFileData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSCopyTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pMFSRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fCopyFileData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct and return a completely new filesystem tree by making a recursive copy of the given tree. </p>
<p>Use <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> to recursively destroy the copy when it is no longer needed.</p>
<p><code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> and <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code> are the only two functions that can be used to create a completely fresh virtual filesystem tree. All other functions operate on nodes that are already linked into an existing tree.</p>
<p>The directory node returned by this function is stand-alone, and completely unlinked from any existing virtual filesystems being managed by MFS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pMFSRoot</em>&nbsp;</td><td>Pointer to the root of the tree to be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fCopyFileData</em>&nbsp;</td><td>Controls whether the underlying file data buffers are copied into the new tree. If you pass <code>TRUE</code>, then fresh copies of the file data will be made in the new tree. Otherwise, the underlying file data will be shared by the new tree and the original tree. Sharing the file data will use less memory, but it means that modifications to files in the new tree can potentially have side-effects on the files in the original tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the function succeeds, the return value is a pointer to a newly-allocated filesystem tree whose shape and contents exactly match the original tree. Every directory and file that exists in the original tree will also exist in the new tree. The files will also contain the same data, which will either be a copy of the original, or a duplicated pointer to memory shared with the original, depending on the value of <code>fCopyFileData</code>. If the function fails, the return value is <code>NULL</code>, which is best interpreted as being due to memory exhaustion. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac4bc307460c87476fe6409c9147995"></a><!-- doxytag: member="memfs.h::MFSDelete" ref="a3ac4bc307460c87476fe6409c9147995" args="(MFSNODE *pRoot, char *pszFilename, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a file or directory, and completely release all of its associated memory resources. </p>
<p>This function can be used to delete a single file, or to <em>recursively</em> delete a directory and all of its descendants, regardless of their contents. If you consider this function as being like the UNIX <code>rm</code> command, then there is an implicit <code>-rf</code>.</p>
<p>This function will fail if the specified file is currently open with any level of access. In the recursive case, the function will similarly fail if any open files are included amongst the directory's descendants.</p>
<p>It is permissible to call this function concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This can be any directory node, as long as the filename is expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file or directory, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, -1 on failure. This return convention is directly compatible with <code>delete_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a67feded02a5ca9f5409efdcab816a96b"></a><!-- doxytag: member="memfs.h::MFSFindRelative" ref="a67feded02a5ca9f5409efdcab816a96b" args="(MFSNODE *pRoot, char *pszFilename, MFSNODE **ppParent, uint32 *pIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSFindRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> **&nbsp;</td>
          <td class="paramname"> <em>ppParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locate a file node, relative to the given root, according to its pathname. </p>
<p>This function may be called concurrently, even on shared directory trees. However, it should not be called concurrently with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code> or <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code>, unless such concurrent calls are operating on disjoint (sub-)trees, otherwise race conditions result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>The root of the search.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppParent</em>&nbsp;</td><td>If the function succeeds, this output parameter receives a pointer to the target node's parent node, which will be of type <code>MFS_Directory</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pIndex</em>&nbsp;</td><td>If the function succeeds, this output parameter receives the index of the target node within its parent directory's child array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the located node, or <code>NULL</code> if no matching node was found. (This function never creates new nodes - you must use <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code> for that). If a pointer is returned, the node will always be of type <code>MFS_File</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0670085c171a758c25934ab3dfedf7de"></a><!-- doxytag: member="memfs.h::MFSGetFile" ref="a0670085c171a758c25934ab3dfedf7de" args="(MFSFILEDESC *pDesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSFILE.html">MFSFILE</a>* MFSGetFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the underlying file from its open descriptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The corresponding file within the virtual tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aad7116548c147cdb4d352dca4145c361"></a><!-- doxytag: member="memfs.h::MFSIterBegin" ref="aad7116548c147cdb4d352dca4145c361" args="(MFSNODE *pRoot, void *pPrivate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a>* MFSIterBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pPrivate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin an iteration over all or part of the file system. </p>
<p>This function can be used to visit <em>file</em> nodes beneath the given directory. The iteration will recursively enter all nested directories, but the directories themselves are not visited as an explicit iteration step.</p>
<p>The function returns a pointer to an internally-allocated <code>MFSITERSTATE</code> structure, which maintains information about the current iteration state. This structure is initialized at a notional position <em>before</em> the first file. To visit the first file, you must make an initial call to <code><a class="el" href="memfs_8c.html#a89444976e3dbc882a6ad34aace2fbdc5" title="Proceed to the first (or next) file in an iteration sequence.">MFSIterNext()</a></code>, and so on to visit subsequent files.</p>
<p>At each iteration step, you can call <code><a class="el" href="memfs_8c.html#a16c6dcdf84410f84ce54015a3c107764" title="Obtain the pathname length of the file at the current iteration step.">MFSIterNameLength()</a></code> and <code><a class="el" href="memfs_8c.html#ab2f686cf36a402d6dfcfcdbaa313d9fe" title="Obtain the pathname of the file at the current iteration step.">MFSIterName()</a></code> to obtain the pathname of the current file, expressed relative to <code>pRoot</code>. You can also call <code><a class="el" href="memfs_8c.html#a5f65338d066ddde354923d78754a1874" title="Obtain a direct pointer to the MFS_File node of the current iteration step.">MFSIterNode()</a></code> to obtain a direct pointer to the current file node.</p>
<p>To avoid resource leaks, all calls to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code> must be matched by a later call to <code><a class="el" href="memfs_8c.html#a35daf840b1298eb97c15e64d025fa7f3" title="Close an iteration sequence.">MFSIterEnd()</a></code>.</p>
<p>The following code fragment demonstrates the basic call pattern for iteration.</p>
<div class="fragment"><pre class="fragment">
  {
     char filename[ MAXFILENAMELENGTH ];
     MFSITERSTATE *pState = MFSIterBegin( pRoot, NULL );
     while ( MFSIterNext( pState ) )
     {
       if ( MFSIterName( pState, filename, sizeof( filename ), TRUE ) )
         printf( "Visiting %s\n", filename );
       else
         printf( "&lt;Filename too long&gt;\n" );
     }
     MFSIterEnd( pState );
  } 
  </pre></div><p>Backwards iteration is not supported, and no assumption should be made that files are visited in any particular order, such as alphabetical order.</p>
<p>It is legal to call <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> on the current file during iteration. It is also legal to call <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code>, although it is then undefined whether the destination file will then be visited later in the iteration.</p>
<p>The iteration function can be used to support an implementation of the <code>start_file_list</code> and <code>next_file</code> functions in the Core RIP Device Interface.</p>
<p>In general, iteration functions may be called concurrently, provided that they are "separate" iterations - that is, using different <code>MFSITERSTATE</code> structures.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system, or directory sub-tree to be traversed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>Arbitrary pointer to caller-managed memory. This pointer will be installed into the <code>pPrivate</code> field of the <code>MFSITERSTATE</code> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to an internally-managed data structure. This pointer remains legal until it is passed into <code><a class="el" href="memfs_8c.html#a35daf840b1298eb97c15e64d025fa7f3" title="Close an iteration sequence.">MFSIterEnd()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a35daf840b1298eb97c15e64d025fa7f3"></a><!-- doxytag: member="memfs.h::MFSIterEnd" ref="a35daf840b1298eb97c15e64d025fa7f3" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSIterEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close an iteration sequence. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>. This pointer becomes invalid upon return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2f686cf36a402d6dfcfcdbaa313d9fe"></a><!-- doxytag: member="memfs.h::MFSIterName" ref="ab2f686cf36a402d6dfcfcdbaa313d9fe" args="(MFSITERSTATE *pState, char *pszFilenameBuf, uint32 bufLen, uint32 fLeadingSlash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSIterName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilenameBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fLeadingSlash</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the pathname of the file at the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilenameBuf</em>&nbsp;</td><td>A pointer to caller-managed memory, which will receive the pathname. The pathname will be expressed relative to the directory that was specified to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>, and will use forward-slash characters as path separators. A leading foward-slash and a terminating NUL character are included.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufLen</em>&nbsp;</td><td>The number of bytes available in the buffer. If this does not accommodate the pathname (including its NUL terminator), the function will fail, and no bytes will be written into the buffer. Use <code><a class="el" href="memfs_8c.html#a16c6dcdf84410f84ce54015a3c107764" title="Obtain the pathname length of the file at the current iteration step.">MFSIterNameLength()</a></code> to obtain the required buffer length, and remember to use the same value for <code>fLeadingSlash</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeadingSlash</em>&nbsp;</td><td>Flag indicating whether a leading slash should be included in the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c6dcdf84410f84ce54015a3c107764"></a><!-- doxytag: member="memfs.h::MFSIterNameLength" ref="a16c6dcdf84410f84ce54015a3c107764" args="(MFSITERSTATE *pState, uint32 fLeadingSlash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> MFSIterNameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fLeadingSlash</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the pathname length of the file at the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeadingSlash</em>&nbsp;</td><td>Flag indicating whether a leading slash should be taken into account when computing the filename. This will just increase the returned value by 1 character, but the parameterization is in order to be consistent with <code><a class="el" href="memfs_8c.html#ab2f686cf36a402d6dfcfcdbaa313d9fe" title="Obtain the pathname of the file at the current iteration step.">MFSIterName()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of 8-bit characters, including a NUL terminator and all separating characters, required to store the pathname of the current file. </dd></dl>

</div>
</div>
<a class="anchor" id="a89444976e3dbc882a6ad34aace2fbdc5"></a><!-- doxytag: member="memfs.h::MFSIterNext" ref="a89444976e3dbc882a6ad34aace2fbdc5" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSIterNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Proceed to the first (or next) file in an iteration sequence. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the iteration has proceeded; FALSE if the iteration has been exhausted. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f65338d066ddde354923d78754a1874"></a><!-- doxytag: member="memfs.h::MFSIterNode" ref="a5f65338d066ddde354923d78754a1874" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSIterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a direct pointer to the <code>MFS_File</code> node of the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cfe51db1b9db4fcc46adb5e5b216d90"></a><!-- doxytag: member="memfs.h::MFSMemUsage" ref="a7cfe51db1b9db4fcc46adb5e5b216d90" args="(MFSNODE *pNode, uint32 *pROMSize, uint32 *pRAMSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSMemUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pROMSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pRAMSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the amount of memory currently in use by the virtual filesystem descended from the given node. </p>
<p>This function recursively walks over the tree, and totals up the file data buffer space being used. The result is approximate, since the memory consumption of MFS internal data structures is not included, but this is generally small in comparison with the actual file data.</p>
<p>The function produces separate totals for ROM consumption and RAM consumption. ROM consumption extends to initial file data that was imported from an external source and embedded in the compiled binaries. RAM consumption extends to all further space that was allocated at runtime. RAM consumption will tend to fluctuate with usage of the filesystem, whereas ROM consumption is fixed (effectively at application link time).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>Root node of the virtual filesystem to be examined. This is allowed to be <code>NULL</code>, in which case the function does nothing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pROMSize</em>&nbsp;</td><td>This number is increased by the number of bytes of ROM being consumed by the filesystem. The caller should initialize this to zero to obtain a total for just the given node. There is no handling for overflow. If files have been deleted from the tree, their ROM consumption is no longer included by this function, although the memory is effectively "leaked" and cannot be recovered. (RAM space, by comparison, is never leaked).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRAMSize</em>&nbsp;</td><td>This number is increased by the number of bytes of dynamic heap memory being consumed by the filesystem. The caller should initialize this to zero to obtain a total for just the given node. There is no handling for overflow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0587f175c00c055fc1946afbc329031e"></a><!-- doxytag: member="memfs.h::MFSNewRoot" ref="a0587f175c00c055fc1946afbc329031e" args="(char *pszRootName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSNewRoot </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszRootName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct and return a completely new root directory node. </p>
<p>Use <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> to destroy this root and the entire virtual filesystem descended from it.</p>
<p><code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> and <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code> are the only two functions that can be used to create a completely fresh virtual filesystem tree. All other functions operate on nodes that are already linked into an existing tree.</p>
<p>The directory node returned by this function is stand-alone, and completely unlinked from any existing virtual filesystems being managed by MFS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszRootName</em>&nbsp;</td><td>The identifier to use for the root node, since all nodes must have a name. Note that this name <em>does not</em> form a part of any path relative to this root.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new node, whose type will be <code>MFS_Directory</code>, or <code>NULL</code> if there has been a failure to allocate the necessary memory. </dd></dl>

</div>
</div>
<a class="anchor" id="af345c05802dcf2b916cec75fa121ac1b"></a><!-- doxytag: member="memfs.h::MFSOpen" ref="af345c05802dcf2b916cec75fa121ac1b" args="(MFSNODE *pRoot, char *pszFilename, int32 openFlags, MFSFILEDESC **ppDesc, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>openFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> **&nbsp;</td>
          <td class="paramname"> <em>ppDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open or create a file for reading and/or writing. </p>
<p>This function can be called concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument. Similar caveats apply with concurrent calls to <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> and <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This may be any directory node within the tree, as long as the filename is expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openFlags</em>&nbsp;</td><td>Specified as per the Core RIP Device Interface, indicating the required level of access to the file. The Memory File System allows concurrent read access, but write access is always exclusive. This parameter can also indicate whether to create a new file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppDesc</em>&nbsp;</td><td>If the function succeeds, receives a pointer to the file descriptor. This pointer must subsequently be passed into all functions used to access the file while it is open. Ultimately, the pointer must be passed to <code><a class="el" href="memfs_8c.html#a8752395e361736b14aef4c5851217234" title="Close a file that was previously opened with MFSOpen().">MFSClose()</a></code> in order to close the file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. Note that the Core RIP Device Interfaces uses a different return convention for the <code>open_file()</code> function. When implementing such a function in terms of <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, you must convert TRUE to 0, and FALSE to -1 respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="a559666aba4a9ff415231bef57568badd"></a><!-- doxytag: member="memfs.h::MFSRead" ref="a559666aba4a9ff415231bef57568badd" args="(MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a specified number of bytes from the current location of an open file. </p>
<p>This function has no side-effects on the underlying file. Therefore, it is permissible to call this function concurrently for different descriptors on the same file, but <em>not</em> with identical descriptors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with read access: <code>SW_RDONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to caller-managed data buffer, which will receive the bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbLen</em>&nbsp;</td><td>The maximum number of bytes to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually read, which will not be greater than <code>cbLen</code>, but which might be less. Returns zero if the end of file has been reached. Returns -1 upon failure. This return convention is directly compatible with <code>read_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ace205408816af77dc43b4423e99e9a99"></a><!-- doxytag: member="memfs.h::MFSReleaseRoot" ref="ace205408816af77dc43b4423e99e9a99" args="(MFSNODE *pMFSRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSReleaseRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pMFSRoot</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the given root node, and the entire virtual filesystem descended from it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pMFSRoot</em>&nbsp;</td><td>The root node, which must have previously been allocated with either <code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> or <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code>. <em>Never</em> call <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> with a non-root node from within another virtual filesystem. Use <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25a08607c320c75bb89ae429896b2e4b"></a><!-- doxytag: member="memfs.h::MFSRename" ref="a25a08607c320c75bb89ae429896b2e4b" args="(MFSNODE *pRoot, char *pszFromName, char *pszToName, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSRename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFromName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszToName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a file, preserving all of its contents and other properties. </p>
<p>It is permissible to call this function concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This can be any directory node, as long as the filenames are expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFromName</em>&nbsp;</td><td>The pathname of the source file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements. The function will fail if this pathname designates a file that is currently open with any level of access. The function will also fail if this pathname does not exist, or if it designates a directory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszToName</em>&nbsp;</td><td>The pathname of the destination file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements. If this pathname denotes any file or directory that already exists, the function will fail.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, -1 on failure. This return convention is directly compatible with <code>delete_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a13abcc96cdda1890358797cec74087be"></a><!-- doxytag: member="memfs.h::MFSSeek" ref="a13abcc96cdda1890358797cec74087be" args="(MFSFILEDESC *pDesc, Hq32x2 *pDestination, int32 flags, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSSeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set (or query) the current the position in an open file. </p>
<p>It is never permissible to call this function concurrently with the same file descriptor. It <em>is</em>, however, permissible to call the function concurrently with different descriptors on the same underlying file, <em>provided that there are no open descriptors with write access on the file.</em></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code> (with any level of access).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestination</em>&nbsp;</td><td>Specifies the file pointer adjustment, and receives the absolute file position if the function returns successfully.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One of <code>SW_SET</code>, <code>SW_INCR</code> or <code>SW_XTND</code>, as per the Core RIP Device Interface. This determines how the <code>pDestination</code> argument is treated on entry. However, the updated <code>pDestination</code> is always an absolute file pointer on exit. To query the current file pointer without modifying it, use <code>SW_INCR</code> and supply a pointer to a <em>zero-valued</em> <code><a class="el" href="structHq32x2.html" title="Signed 64 bit integer, represented as a 2s complement pair.">Hq32x2</a></code> (note that this <em>does not</em> mean a NULL pointer).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success, in which case <code>pDestination</code> is updated with the current file pointer. FALSE upon failure, in which case <code>pDestination</code> is not updated. This return convention is directly compatible with <code>seek_file</code> in the Core RIP Device Interface </dd></dl>

</div>
</div>
<a class="anchor" id="afeb21268e98b1f3b1a0139b22dd4e7aa"></a><!-- doxytag: member="memfs.h::MFSSetCompression" ref="afeb21268e98b1f3b1a0139b22dd4e7aa" args="(MFSFILEDESC *pDesc, uint32 fCompress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSSetCompression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fCompress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls whether the file's data buffer will be compressed (or re-compressed) when the file is closed. </p>
<p>This function can only be called when the file's data buffer is currently in an uncompressed state. This will be the case if the file was opened for writing, or for random-access reading. In other cases, it is less certain.</p>
<p>Normally, when a file is closed, its data buffer is retained in a compressed state to save on memory usage. There might be cases where this is undesirable. For instance, if a large file is opened and closed many times in rapid succession, a runtime expense will be incurred in decompression (and re-compression) of the data. The caller might use this function to de-activate the compression for periods of such activity. The caller might also use this function when storing data that has already been compressed, in which case there is little point in trying to compress it again.</p>
<p>The most typical use of this function is immediately after creation of a <em>new</em> file with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fCompress</em>&nbsp;</td><td>Supply <code>TRUE</code> to indicate that the file buffer should be compressed when the file is closed, or <code>FALSE</code> to indicate that it shouldn't.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a95bd7667a5f6ce08df29a326fa7ff390"></a><!-- doxytag: member="memfs.h::MFSWrite" ref="a95bd7667a5f6ce08df29a326fa7ff390" args="(MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a specified number of bytes to an open file at the current location, expanding the file as necessary. </p>
<p>This function has side-effects on the underlying file. Therefore, it is never permissible to call this function concurrently with descriptors on the same file. It is also never permissible to call <code><a class="el" href="memfs_8c.html#a559666aba4a9ff415231bef57568badd" title="Read a specified number of bytes from the current location of an open file.">MFSRead()</a></code> concurrently with <code><a class="el" href="memfs_8c.html#a95bd7667a5f6ce08df29a326fa7ff390" title="Write a specified number of bytes to an open file at the current location, expanding...">MFSWrite()</a></code> with descriptors on the same underlying file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to caller-managed data buffer, from which bytes will be copied into the file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbLen</em>&nbsp;</td><td>The maximum number of bytes to write.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, which will not be greater than <code>cbLen</code>, but which might be less. Returns -1 upon failure. This return convention is directly compatible with <code>write_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a5af100d6d7bf19e3a05fbb46eb2cf"></a><!-- doxytag: member="memfs.h::MFSWriteString" ref="aa5a5af100d6d7bf19e3a05fbb46eb2cf" args="(MFSFILEDESC *pDesc, char *pszString, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSWriteString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a specified NUL-terminated character string to an open file at the current location, expanding the file as necessary. The terminating NUL character itself is not written. </p>
<p>This function has side-effects on the underlying file. Therefore, it is never permissible to call this function concurrently with descriptors on the same file. It is also never permissible to call <code><a class="el" href="memfs_8c.html#a559666aba4a9ff415231bef57568badd" title="Read a specified number of bytes from the current location of an open file.">MFSRead()</a></code> or <code><a class="el" href="memfs_8c.html#a95bd7667a5f6ce08df29a326fa7ff390" title="Write a specified number of bytes to an open file at the current location, expanding...">MFSWrite()</a></code> concurrently with <code><a class="el" href="memfs_8c.html#aa5a5af100d6d7bf19e3a05fbb46eb2cf" title="Write a specified NUL-terminated character string to an open file at the current...">MFSWriteString()</a></code>, with descriptors on the same underlying file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>A pointer to caller-managed string memory. The string should be NUL-terminated, and should be an ANSI or multi-byte encoded character string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, which will not be greater than the length of the string <em>in bytes</em>, but which might be less. Returns -1 upon failure. This return convention is directly compatible with <code>write_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
