<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: hqbitvector.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_9f69e5f1ce79f527fb07efef95800849.html">standard</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_e271fd8159723d90b7e0fb7f56e944fe.html">export</a>
  </div>
</div>
<div class="contents">
<h1>hqbitvector.h File Reference</h1>
<p>Macros implementing bit vectors.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbitvector__iterator__t.html">bitvector_iterator_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator structure for walking bit vectors.  <a href="structbitvector__iterator__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a06a254ca671f506de85d848c228cbbc3">BITVECTOR_SHIFT_ELEMENTS</a>&nbsp;&nbsp;&nbsp;(3 + 2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right shift to convert bit indices to element indices.  <a href="#a06a254ca671f506de85d848c228cbbc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd6dae8fb9cc6bd2bfc0395af94b0a6b"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ELEMENT_BITS" ref="afd6dae8fb9cc6bd2bfc0395af94b0a6b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#afd6dae8fb9cc6bd2bfc0395af94b0a6b">BITVECTOR_ELEMENT_BITS</a>&nbsp;&nbsp;&nbsp;(1u &lt;&lt; BITVECTOR_SHIFT_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit vector element size in bits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1237f33701143fd64b4191c36240e535"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ELEMENT_MASK" ref="a1237f33701143fd64b4191c36240e535" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a1237f33701143fd64b4191c36240e535">BITVECTOR_ELEMENT_MASK</a>&nbsp;&nbsp;&nbsp;(BITVECTOR_ELEMENT_BITS - 1u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask to extract bit index within element from bit index. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd8ba92e08e18de3a51534b55f5ff1c"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ELEMENT_ZEROS" ref="a1fd8ba92e08e18de3a51534b55f5ff1c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a1fd8ba92e08e18de3a51534b55f5ff1c">BITVECTOR_ELEMENT_ZEROS</a>&nbsp;&nbsp;&nbsp;(<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitvector element containing all zeros. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32656c86749dd421dfc4160bc0cb9164"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ELEMENT_ONES" ref="a32656c86749dd421dfc4160bc0cb9164" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a32656c86749dd421dfc4160bc0cb9164">BITVECTOR_ELEMENT_ONES</a>&nbsp;&nbsp;&nbsp;(<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)(~BITVECTOR_ELEMENT_ZEROS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitvector element containing all ones. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4">BITVECTOR_SIZE_ELEMENTS</a>(length_)&nbsp;&nbsp;&nbsp;(((length_) + BITVECTOR_ELEMENT_BITS - 1u) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a bitvector containing <code>length_</code> bits, in elements.  <a href="#aa440bb878d99d554a732367975f249e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#af8c9910c6617696847e6dc453901f97a">BITVECTOR_SIZE_BYTES</a>(length_)&nbsp;&nbsp;&nbsp;(BITVECTOR_SIZE_ELEMENTS(length_) &lt;&lt; 2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a bitvector containing <code>length_</code> bits, in bytes.  <a href="#af8c9910c6617696847e6dc453901f97a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#ad4b24afe40420835e89ced3a06e4e433">bitvector_t</a>(name_, size_)&nbsp;&nbsp;&nbsp;<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a> name_[BITVECTOR_SIZE_ELEMENTS(size_)]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a bitvector variable or field.  <a href="#ad4b24afe40420835e89ced3a06e4e433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a4d071c655c1e3a3b16ea341ecef4410d">BITVECTOR_SET_ELEMENTS</a>(vec_, size_, value_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all of the bits in a bit vector to a value.  <a href="#a4d071c655c1e3a3b16ea341ecef4410d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a8719958eaa7e9fed99d8f830dd6ab0da">BITVECTOR_COPY_FLIP</a>(dest_, src_, size_, flip_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the contents of one bit vector to another, with an optional exclusive-or operation.  <a href="#a8719958eaa7e9fed99d8f830dd6ab0da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#af41c8ad0fb1f78cfca1a555e6024c462">BITVECTOR_CLEAR</a>(vec_, bit_)&nbsp;&nbsp;&nbsp;(vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] &amp;= ~((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear a single bit in a bit vector.  <a href="#af41c8ad0fb1f78cfca1a555e6024c462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#acce124318a11a1ae733bc2473049b65d">BITVECTOR_SET</a>(vec_, bit_)&nbsp;&nbsp;&nbsp;(vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] |= ((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a single bit in a bit vector.  <a href="#acce124318a11a1ae733bc2473049b65d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#ab7db1f11c4fff52fde7de9320066c7b6">BITVECTOR_IS_SET</a>(vec_, bit_)&nbsp;&nbsp;&nbsp;(((vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] &amp; ((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))) != 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a bit in a bit vector is set.  <a href="#ab7db1f11c4fff52fde7de9320066c7b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#af7552d04a25045d769aebadfa6d7523f">BITVECTOR_ELEMENT_BIT_MASK</a>(element_, bit_)&nbsp;&nbsp;&nbsp;(((element_) == ((bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS)) &lt;&lt; ((bit_) &amp; BITVECTOR_ELEMENT_MASK))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a mask which can be used to test and isolate a bit in an identified element.  <a href="#af7552d04a25045d769aebadfa6d7523f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a69e934908d4ba99738d002938534573e">BITVECTOR_ITERATE_BITS</a>(iterator_, size_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise per-bit iteration over a bit vector using an element, mask pair.  <a href="#a69e934908d4ba99738d002938534573e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21">BITVECTOR_ITERATE_BITS_MORE</a>(iterator_)&nbsp;&nbsp;&nbsp;((iterator_).element &gt;= 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if per-bit iteration over a bitvector using an element, mask pair is complete.  <a href="#a7022846da7834dd86e2ba36871c6da21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#afa8c22855c60f0c5a9647e1a6d59596e">BITVECTOR_ITERATE_BITS_NEXT</a>(iterator_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue per-bit iteration over a bit vector using an element, mask pair.  <a href="#afa8c22855c60f0c5a9647e1a6d59596e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a0eeca6ee7a6f6d098e651daabdbc41d9">BITVECTOR_ITERATE_BITS_N</a>(iterator_, size_, chunk_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise multi-bit iteration over a bit vector using an element, mask pair.  <a href="#a0eeca6ee7a6f6d098e651daabdbc41d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a072e4eb1a069d9883b7dfa94ee16bd4d">BITVECTOR_ITERATE_BITS_NEXT_N</a>(iterator_, chunk_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue multi-bit iteration over a bit vector using an element, mask pair.  <a href="#a072e4eb1a069d9883b7dfa94ee16bd4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a655a7d85155de9369d5a11065db77ae0">BITVECTOR_ITERATE_ELEMENTS</a>(iterator_, size_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise per-element iteration over a bit vector using an element, mask pair.  <a href="#a655a7d85155de9369d5a11065db77ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#a147b2aa40ea2892f2bdc60b6cef6b639">BITVECTOR_ITERATE_ELEMENTS_MORE</a>(iterator_)&nbsp;&nbsp;&nbsp;((iterator_).element &gt;= 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if per-element iteration over a bitvector using an element, mask pair is complete.  <a href="#a147b2aa40ea2892f2bdc60b6cef6b639"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#ade8aebb4f7efb5cc797fceb2888b8b3b">BITVECTOR_ITERATE_ELEMENTS_NEXT</a>(iterator_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue per-element iteration over a bit vector using an element, mask pair.  <a href="#ade8aebb4f7efb5cc797fceb2888b8b3b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf2a3ef96e9be8656e3330129429f201"></a><!-- doxytag: member="hqbitvector.h::bitvector_element_t" ref="abf2a3ef96e9be8656e3330129429f201" args="" -->
typedef <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unsigned type used to implement bit vectors. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Macros implementing bit vectors. </p>
<dl class="rcs"><dt><b>HopeName</b></dt><dd>HQNc-standard!export:<a class="el" href="hqbitvector_8h.html" title="Macros implementing bit vectors.">hqbitvector.h</a>(EBDSDK_P.1) </dd></dl>
<p>Copyright (C) 2008-2014 Global Graphics Software Ltd. All rights reserved. This source code contains the confidential and trade secret information of Global Graphics Software Ltd. It may not be used, copied or distributed for any reason except as set forth in the applicable Global Graphics license agreement. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="af41c8ad0fb1f78cfca1a555e6024c462"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_CLEAR" ref="af41c8ad0fb1f78cfca1a555e6024c462" args="(vec_, bit_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_CLEAR</td>
          <td>(</td>
          <td class="paramtype">vec_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] &amp;= ~((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear a single bit in a bit vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_</em>&nbsp;</td><td>The bitvector to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bit_</em>&nbsp;</td><td>The bit index to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8719958eaa7e9fed99d8f830dd6ab0da"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_COPY_FLIP" ref="a8719958eaa7e9fed99d8f830dd6ab0da" args="(dest_, src_, size_, flip_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_COPY_FLIP</td>
          <td>(</td>
          <td class="paramtype">dest_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">src_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flip_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START \
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _i_ = <a class="code" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4" title="Size of a bitvector containing length_ bits, in elements.">BITVECTOR_SIZE_ELEMENTS</a>(size_) ; \
  HQASSERT(_i_ &gt; 0, <span class="stringliteral">&quot;Bitvector has no elements&quot;</span>) ;    \
  <span class="keywordflow">do</span> {                                                \
    --_i_ ;                                           \
    (dest_)[_i_] = (src_)[_i_] ^ ((<a class="code" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201" title="An unsigned type used to implement bit vectors.">bitvector_element_t</a>)!(flip_) - 1u) ;  \
  } <span class="keywordflow">while</span> ( _i_ &gt; 0 ) ;                               \
MACRO_END
</pre></div>
<p>Copy the contents of one bit vector to another, with an optional exclusive-or operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest_</em>&nbsp;</td><td>The destination bitvector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_</em>&nbsp;</td><td>The source bitvector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>The number of bits in the vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flip_</em>&nbsp;</td><td>A boolean, indicating if the destination should be the inverse of the source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7552d04a25045d769aebadfa6d7523f"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ELEMENT_BIT_MASK" ref="af7552d04a25045d769aebadfa6d7523f" args="(element_, bit_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ELEMENT_BIT_MASK</td>
          <td>(</td>
          <td class="paramtype">element_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((element_) == ((bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS)) &lt;&lt; ((bit_) &amp; BITVECTOR_ELEMENT_MASK))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a mask which can be used to test and isolate a bit in an identified element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element_</em>&nbsp;</td><td>The element index being processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bit_</em>&nbsp;</td><td>The bit index to derive a mask for.</td></tr>
  </table>
  </dd>
</dl>
<p>The return value is a mask that is zero if <code>bit</code> is not in <code>element</code>, or set to the bit mask within <code>element</code> if it is.</p>
<p>This can be used to implement bulk operations in clients, without having to test if particular bits that should be treated specially are present in each element. </p>

</div>
</div>
<a class="anchor" id="ab7db1f11c4fff52fde7de9320066c7b6"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_IS_SET" ref="ab7db1f11c4fff52fde7de9320066c7b6" args="(vec_, bit_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_IS_SET</td>
          <td>(</td>
          <td class="paramtype">vec_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] &amp; ((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))) != 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if a bit in a bit vector is set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_</em>&nbsp;</td><td>The bitvector to test. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bit_</em>&nbsp;</td><td>The bit index to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69e934908d4ba99738d002938534573e"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_BITS" ref="a69e934908d4ba99738d002938534573e" args="(iterator_, size_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_BITS</td>
          <td>(</td>
          <td class="paramtype">iterator_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(iterator_).bit = (size_) - 1, \
    (iterator_).element = (<span class="keywordtype">int</span>)<a class="code" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4" title="Size of a bitvector containing length_ bits, in elements.">BITVECTOR_SIZE_ELEMENTS</a>(size_) - 1, \
    (iterator_).mask = ((<a class="code" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201" title="An unsigned type used to implement bit vectors.">bitvector_element_t</a>)1 &lt;&lt; ((iterator_).bit &amp; <a class="code" href="hqbitvector_8h.html#a1237f33701143fd64b4191c36240e535" title="Mask to extract bit index within element from bit index.">BITVECTOR_ELEMENT_MASK</a>))
</pre></div>
<p>Initialise per-bit iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>A <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to initialise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>The size of the bit vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop initialisation statement. Note that the iteration goes from the highest to lowest bits. The iterator will be initialised correctly for bitvectors of size zero or more. The idiom will usually look like this:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a> iterator ;
   <a class="code" href="hqbitvector_8h.html#ad4b24afe40420835e89ced3a06e4e433" title="Declare a bitvector variable or field.">bitvector_t</a>(vector, MAXBITS) ;

   <span class="keywordflow">for</span> ( <a class="code" href="hqbitvector_8h.html#a69e934908d4ba99738d002938534573e" title="Initialise per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS</a>(iterator, bits_used) ;
         <a class="code" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a>(iterator) ;
         <a class="code" href="hqbitvector_8h.html#afa8c22855c60f0c5a9647e1a6d59596e" title="Continue per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_NEXT</a>(iterator) ) {
     <span class="keywordflow">if</span> ( (vector[iterator.<a class="code" href="structbitvector__iterator__t.html#abac81d587e0ea127f7db4ab3012a47c8">element</a>] &amp; iterator.<a class="code" href="structbitvector__iterator__t.html#aff7ff27c1a65aedcae65b0f1e83e668b">mask</a>) != 0 ) {
       ...bit iterator.<a class="code" href="structbitvector__iterator__t.html#af6ab42716c00cc6f35b828c18d9fc721">bit</a> is <span class="keyword">set</span>...
     }
   }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a>, <a class="el" href="hqbitvector_8h.html#afa8c22855c60f0c5a9647e1a6d59596e" title="Continue per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_NEXT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7022846da7834dd86e2ba36871c6da21"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_BITS_MORE" ref="a7022846da7834dd86e2ba36871c6da21" args="(iterator_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_BITS_MORE</td>
          <td>(</td>
          <td class="paramtype">iterator_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((iterator_).element &gt;= 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if per-bit iteration over a bitvector using an element, mask pair is complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to test.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop condition statement. Note that the iteration goes from the highest to lowest bits.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a69e934908d4ba99738d002938534573e" title="Initialise per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS</a>, <a class="el" href="hqbitvector_8h.html#afa8c22855c60f0c5a9647e1a6d59596e" title="Continue per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_NEXT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0eeca6ee7a6f6d098e651daabdbc41d9"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_BITS_N" ref="a0eeca6ee7a6f6d098e651daabdbc41d9" args="(iterator_, size_, chunk_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_BITS_N</td>
          <td>(</td>
          <td class="paramtype">iterator_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">chunk_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">HQASSERT_EXPR(((chunk_) &amp; ((chunk_) - 1)) == 0 &amp;&amp; (size_) % (chunk_) == 0, \
    <span class="stringliteral">&quot;Iteration chunk or size mismatch&quot;</span>, \
    ((iterator_).bit = (size_) - (chunk_), \
     (iterator_).element = (<span class="keywordtype">int</span>)<a class="code" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4" title="Size of a bitvector containing length_ bits, in elements.">BITVECTOR_SIZE_ELEMENTS</a>(size_) - 1, \
     (iterator_).mask = ((<a class="code" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201" title="An unsigned type used to implement bit vectors.">bitvector_element_t</a>)((1 &lt;&lt; (chunk_)) - 1) &lt;&lt; ((iterator_).bit &amp; <a class="code" href="hqbitvector_8h.html#a1237f33701143fd64b4191c36240e535" title="Mask to extract bit index within element from bit index.">BITVECTOR_ELEMENT_MASK</a>))))
</pre></div>
<p>Initialise multi-bit iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>A <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to initialise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>The size of the bit vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chunk_</em>&nbsp;</td><td>The number of bits to iterate at a time. This should be a power of 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop initialisation statement. Note that the iteration goes from the highest to lowest bits. The iterator will be initialised correctly for bitvectors of size zero or more. The idiom will usually look like this:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a> iterator ;
   <a class="code" href="hqbitvector_8h.html#ad4b24afe40420835e89ced3a06e4e433" title="Declare a bitvector variable or field.">bitvector_t</a>(vector, MAXLEN * 2) ;

   <span class="keywordflow">for</span> ( <a class="code" href="hqbitvector_8h.html#a0eeca6ee7a6f6d098e651daabdbc41d9" title="Initialise multi-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_N</a>(iterator, bits_used, 2) ;
         <a class="code" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a>(iterator) ;
         <a class="code" href="hqbitvector_8h.html#a072e4eb1a069d9883b7dfa94ee16bd4d" title="Continue multi-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_NEXT_N</a>(iterator, 2) ) {
     <span class="keywordtype">int</span> chunk = ((vector[iterator.<a class="code" href="structbitvector__iterator__t.html#abac81d587e0ea127f7db4ab3012a47c8">element</a>] &amp; iterator.<a class="code" href="structbitvector__iterator__t.html#aff7ff27c1a65aedcae65b0f1e83e668b">mask</a>) &gt;&gt; iterator.<a class="code" href="structbitvector__iterator__t.html#af6ab42716c00cc6f35b828c18d9fc721">bit</a>) ;
     ...
   }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a>, <a class="el" href="hqbitvector_8h.html#a072e4eb1a069d9883b7dfa94ee16bd4d" title="Continue multi-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_NEXT_N</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa8c22855c60f0c5a9647e1a6d59596e"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_BITS_NEXT" ref="afa8c22855c60f0c5a9647e1a6d59596e" args="(iterator_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_BITS_NEXT</td>
          <td>(</td>
          <td class="paramtype">iterator_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(iterator_).bit -= 1, \
    (iterator_).element -= (int)((iterator_).mask &amp; 1), \
    (iterator_).mask = ((iterator_).mask &gt;&gt; 1) | ((iterator_).mask &lt;&lt; (<a class="code" href="hqbitvector_8h.html#afd6dae8fb9cc6bd2bfc0395af94b0a6b" title="Bit vector element size in bits.">BITVECTOR_ELEMENT_BITS</a> - 1u))
</pre></div>
<p>Continue per-bit iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to step.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop continuation statement. Note that the iteration goes from the highest to lowest bits.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a69e934908d4ba99738d002938534573e" title="Initialise per-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS</a>, <a class="el" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a072e4eb1a069d9883b7dfa94ee16bd4d"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_BITS_NEXT_N" ref="a072e4eb1a069d9883b7dfa94ee16bd4d" args="(iterator_, chunk_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_BITS_NEXT_N</td>
          <td>(</td>
          <td class="paramtype">iterator_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">chunk_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">HQASSERT_EXPR(((chunk_) &amp; ((chunk_) - 1)) == 0 &amp;&amp; (iterator_).bit % (chunk_) == 0, \
    <span class="stringliteral">&quot;Iteration chunk or size mismatch&quot;</span>, \
    ((iterator_).bit -= (chunk_), \
     (iterator_).element -= (<span class="keywordtype">int</span>)((iterator_).mask &amp; 1), \
     (iterator_).mask = (((iterator_).mask &gt;&gt; (chunk_)) | \
                         ((iterator_).mask &lt;&lt; (<a class="code" href="hqbitvector_8h.html#afd6dae8fb9cc6bd2bfc0395af94b0a6b" title="Bit vector element size in bits.">BITVECTOR_ELEMENT_BITS</a> - (chunk_))))))
</pre></div>
<p>Continue multi-bit iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to step. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chunk_</em>&nbsp;</td><td>The number of bits to iterate at a time. This should be a power of 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop continuation statement. Note that the iteration goes from the highest to lowest bits.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a7022846da7834dd86e2ba36871c6da21" title="Test if per-bit iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_BITS_MORE</a>, <a class="el" href="hqbitvector_8h.html#a0eeca6ee7a6f6d098e651daabdbc41d9" title="Initialise multi-bit iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_BITS_N</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a655a7d85155de9369d5a11065db77ae0"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_ELEMENTS" ref="a655a7d85155de9369d5a11065db77ae0" args="(iterator_, size_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_ELEMENTS</td>
          <td>(</td>
          <td class="paramtype">iterator_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(iterator_).bit = ((size_) - 1), \
    (iterator_).element = (int)<a class="code" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4" title="Size of a bitvector containing length_ bits, in elements.">BITVECTOR_SIZE_ELEMENTS</a>(size_) - 1, \
    (iterator_).mask = (<a class="code" href="hqbitvector_8h.html#a32656c86749dd421dfc4160bc0cb9164" title="Bitvector element containing all ones.">BITVECTOR_ELEMENT_ONES</a> &gt;&gt; ((<a class="code" href="hqbitvector_8h.html#afd6dae8fb9cc6bd2bfc0395af94b0a6b" title="Bit vector element size in bits.">BITVECTOR_ELEMENT_BITS</a> - (size_)) &amp; <a class="code" href="hqbitvector_8h.html#a1237f33701143fd64b4191c36240e535" title="Mask to extract bit index within element from bit index.">BITVECTOR_ELEMENT_MASK</a>))
</pre></div>
<p>Initialise per-element iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to initialise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>The size of the bit vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop initialisation statement. Note that the iteration goes from the highest to lowest element. The iterator will be initialised correctly for bitvectors of size zero or more. The iteration idiom will usually look like this:</p>
<div class="fragment"><pre class="fragment">   <a class="code" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a> iterator ;
   <a class="code" href="hqbitvector_8h.html#ad4b24afe40420835e89ced3a06e4e433" title="Declare a bitvector variable or field.">bitvector_t</a>(vector, MAXBITS) ;

   <span class="keywordflow">for</span> ( <a class="code" href="hqbitvector_8h.html#a655a7d85155de9369d5a11065db77ae0" title="Initialise per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS</a>(iterator, bits_used) ;
         <a class="code" href="hqbitvector_8h.html#a147b2aa40ea2892f2bdc60b6cef6b639" title="Test if per-element iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_ELEMENTS_MORE</a>(iterator) ;
         <a class="code" href="hqbitvector_8h.html#ade8aebb4f7efb5cc797fceb2888b8b3b" title="Continue per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS_NEXT</a>(iterator) ) {
     <span class="keywordflow">if</span> ( (vector[iterator.<a class="code" href="structbitvector__iterator__t.html#abac81d587e0ea127f7db4ab3012a47c8">element</a>] &amp; iterator.<a class="code" href="structbitvector__iterator__t.html#aff7ff27c1a65aedcae65b0f1e83e668b">mask</a>) == iterator.<a class="code" href="structbitvector__iterator__t.html#aff7ff27c1a65aedcae65b0f1e83e668b">mask</a> ) {
       ...all bits <span class="keyword">set</span>...
     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (vector[iterator.<a class="code" href="structbitvector__iterator__t.html#abac81d587e0ea127f7db4ab3012a47c8">element</a>] &amp; iterator.<a class="code" href="structbitvector__iterator__t.html#aff7ff27c1a65aedcae65b0f1e83e668b">mask</a>) == 0 ) {
       ...no bits <span class="keyword">set</span>...
     } ...etc...
   }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a147b2aa40ea2892f2bdc60b6cef6b639" title="Test if per-element iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_ELEMENTS_MORE</a>, <a class="el" href="hqbitvector_8h.html#ade8aebb4f7efb5cc797fceb2888b8b3b" title="Continue per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS_NEXT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a147b2aa40ea2892f2bdc60b6cef6b639"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_ELEMENTS_MORE" ref="a147b2aa40ea2892f2bdc60b6cef6b639" args="(iterator_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_ELEMENTS_MORE</td>
          <td>(</td>
          <td class="paramtype">iterator_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((iterator_).element &gt;= 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if per-element iteration over a bitvector using an element, mask pair is complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to test.</td></tr>
  </table>
  </dd>
</dl>
<p>The bits index to test. This macro is written such that it can be used in a for-loop condition statement. Note that the iteration goes from the highest to lowest element.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a655a7d85155de9369d5a11065db77ae0" title="Initialise per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS</a>, <a class="el" href="hqbitvector_8h.html#ade8aebb4f7efb5cc797fceb2888b8b3b" title="Continue per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS_NEXT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade8aebb4f7efb5cc797fceb2888b8b3b"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_ITERATE_ELEMENTS_NEXT" ref="ade8aebb4f7efb5cc797fceb2888b8b3b" args="(iterator_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_ITERATE_ELEMENTS_NEXT</td>
          <td>(</td>
          <td class="paramtype">iterator_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(iterator_).bit = ((iterator_).bit &amp; ~<a class="code" href="hqbitvector_8h.html#a1237f33701143fd64b4191c36240e535" title="Mask to extract bit index within element from bit index.">BITVECTOR_ELEMENT_MASK</a>) - 1, \
  (iterator_).element -= 1, (iterator_).mask = <a class="code" href="hqbitvector_8h.html#a32656c86749dd421dfc4160bc0cb9164" title="Bitvector element containing all ones.">BITVECTOR_ELEMENT_ONES</a>
</pre></div>
<p>Continue per-element iteration over a bit vector using an element, mask pair. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator_</em>&nbsp;</td><td>The <code><a class="el" href="structbitvector__iterator__t.html" title="Iterator structure for walking bit vectors.">bitvector_iterator_t</a></code> variable to step.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is written such that it can be used in a for-loop continuation statement. Note that the iteration goes from the highest to lowest element.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hqbitvector_8h.html#a655a7d85155de9369d5a11065db77ae0" title="Initialise per-element iteration over a bit vector using an element, mask pair.">BITVECTOR_ITERATE_ELEMENTS</a>, <a class="el" href="hqbitvector_8h.html#a147b2aa40ea2892f2bdc60b6cef6b639" title="Test if per-element iteration over a bitvector using an element, mask pair is complete...">BITVECTOR_ITERATE_ELEMENTS_MORE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acce124318a11a1ae733bc2473049b65d"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_SET" ref="acce124318a11a1ae733bc2473049b65d" args="(vec_, bit_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_SET</td>
          <td>(</td>
          <td class="paramtype">vec_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(vec_)[(bit_) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS] |= ((<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a>)1 &lt;&lt; (BITVECTOR_ELEMENT_MASK &amp; (bit_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a single bit in a bit vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_</em>&nbsp;</td><td>The bitvector to modify. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bit_</em>&nbsp;</td><td>The bit index to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d071c655c1e3a3b16ea341ecef4410d"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_SET_ELEMENTS" ref="a4d071c655c1e3a3b16ea341ecef4410d" args="(vec_, size_, value_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_SET_ELEMENTS</td>
          <td>(</td>
          <td class="paramtype">vec_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START   \
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _i_ = <a class="code" href="hqbitvector_8h.html#aa440bb878d99d554a732367975f249e4" title="Size of a bitvector containing length_ bits, in elements.">BITVECTOR_SIZE_ELEMENTS</a>(size_) ; \
  HQASSERT(_i_ &gt; 0, <span class="stringliteral">&quot;Bitvector has no elements&quot;</span>) ;    \
  <span class="keywordflow">do</span> {                                                \
    (vec_)[--_i_] = (value_) ;                        \
  } <span class="keywordflow">while</span> ( _i_ &gt; 0 ) ;                               \
MACRO_END
</pre></div>
<p>Set all of the bits in a bit vector to a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_</em>&nbsp;</td><td>The bitvector to clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>The number of bits in the vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_</em>&nbsp;</td><td>This should be <code>BITVECTOR_ELEMENT_ZEROS</code> to clear the vector, <code>BITVECTOR_ELEMENT_ONES</code> to set the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06a254ca671f506de85d848c228cbbc3"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_SHIFT_ELEMENTS" ref="a06a254ca671f506de85d848c228cbbc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_SHIFT_ELEMENTS&nbsp;&nbsp;&nbsp;(3 + 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Right shift to convert bit indices to element indices. </p>
<p>The relationship:</p>
<p>(1 &lt;&lt; (BITVECTOR_SHIFT_ELEMENTS - 3)) == sizeof(bitvector_element_t)</p>
<p>should always hold. </p>

</div>
</div>
<a class="anchor" id="af8c9910c6617696847e6dc453901f97a"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_SIZE_BYTES" ref="af8c9910c6617696847e6dc453901f97a" args="(length_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_SIZE_BYTES</td>
          <td>(</td>
          <td class="paramtype">length_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(BITVECTOR_SIZE_ELEMENTS(length_) &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of a bitvector containing <code>length_</code> bits, in bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length_</em>&nbsp;</td><td>Length of the bitvector, in bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa440bb878d99d554a732367975f249e4"></a><!-- doxytag: member="hqbitvector.h::BITVECTOR_SIZE_ELEMENTS" ref="aa440bb878d99d554a732367975f249e4" args="(length_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITVECTOR_SIZE_ELEMENTS</td>
          <td>(</td>
          <td class="paramtype">length_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((length_) + BITVECTOR_ELEMENT_BITS - 1u) &gt;&gt; BITVECTOR_SHIFT_ELEMENTS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of a bitvector containing <code>length_</code> bits, in elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length_</em>&nbsp;</td><td>Length of the bitvector, in bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b24afe40420835e89ced3a06e4e433"></a><!-- doxytag: member="hqbitvector.h::bitvector_t" ref="ad4b24afe40420835e89ced3a06e4e433" args="(name_, size_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bitvector_t</td>
          <td>(</td>
          <td class="paramtype">name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;<a class="el" href="hqbitvector_8h.html#abf2a3ef96e9be8656e3330129429f201">bitvector_element_t</a> name_[BITVECTOR_SIZE_ELEMENTS(size_)]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a bitvector variable or field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name_</em>&nbsp;</td><td>The name of the bitvector name or field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_</em>&nbsp;</td><td>A constant expression, giving the number of bits in the vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro can be used anywhere that a variable or parameter declaration can occur. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
