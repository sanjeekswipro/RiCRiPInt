<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: pgbdev.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>pgbdev.c File Reference</h1>
<p>An example implementation of the PageBuffer device type.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="hqstr_8h.html">hqstr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="kit_8h.html">kit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="file_8h.html">file.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swdevice_8h.html">swdevice.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skindevs_8h.html">skindevs.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swoften_8h.html">swoften.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="zlibutil_8h.html">zlibutil.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="devparam_8h.html">devparam.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skinkit_8h.html">skinkit.h</a>&quot;</code><br/>
<code>#include &quot;ktime.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="swevents_8h.html">swevents.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swtimelines_8h.html">swtimelines.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqmemset_8h.html">hqmemset.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqmemcpy_8h.html">hqmemcpy.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBandHolder.html">BandHolder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A container for band data delivered during partial paint or transparency compositing, and optionally then compressed.  <a href="structBandHolder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBandIndex.html">BandIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entry in disk cache file's table to hold the details of a band.  <a href="structBandIndex.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBandMemory.html">BandMemory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure holding memory for use by band cache.  <a href="structBandMemory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBandCache.html">BandCache</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top-level structure representing a cache of bands. One of these is used if a partial paint is happening (see sections 6.4 - 6.6 of the RIP Programmer's Reference Manual - HqnRIP_SDK_ProgRef.pdf).  <a href="structBandCache.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPGBDescription.html">PGBDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> structure contains a RasterDescription, which is the part exported to the raster callback, and some local fields for keeping track of partial paints.  <a href="structPGBDescription.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPGBDeviceState.html">PGBDeviceState</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold device-specific state.  <a href="structPGBDeviceState.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPageBufferInParameters.html">PageBufferInParameters</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following structures will hold all of the device parameters so that we can write it all in one go. After the type definition is a static initialization of an instance of the structure to provide suitable defaults for all the parameters; these will be replaced as new values are received.  <a href="structPageBufferInParameters.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5cda3c3d532846e0e30623981058fec"></a><!-- doxytag: member="pgbdev.c::MAX_MEMORY_CACHE_SIZE_BYTES" ref="ad5cda3c3d532846e0e30623981058fec" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ad5cda3c3d532846e0e30623981058fec">MAX_MEMORY_CACHE_SIZE_BYTES</a>&nbsp;&nbsp;&nbsp;(1 * 512 * 1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrarily chosen maximum size for the in-memory band cache. When this much memory is used by compressed band data, the band data is flushed to disk. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa3eab80f4e7dd4fe11ccef850b1e715"></a><!-- doxytag: member="pgbdev.c::BAND_CACHE_FD_UNSET" ref="aaa3eab80f4e7dd4fe11ccef850b1e715" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#aaa3eab80f4e7dd4fe11ccef850b1e715">BAND_CACHE_FD_UNSET</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A magic value to denote that the disk band cache file descriptor is currently unset. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5c578190228da48ff2bfc87b5fc304"></a><!-- doxytag: member="pgbdev.c::BAND_NOT_PRESENT_IN_TABLE" ref="acd5c578190228da48ff2bfc87b5fc304" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#acd5c578190228da48ff2bfc87b5fc304">BAND_NOT_PRESENT_IN_TABLE</a>&nbsp;&nbsp;&nbsp;NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A magic value set in the band cache band array to denote a band which has never been sent to the PageBuffer device for storage. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac636a870baf14b5ff286778db6fb0105"></a><!-- doxytag: member="pgbdev.c::BAND_SLOT_EVACUATED" ref="ac636a870baf14b5ff286778db6fb0105" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ac636a870baf14b5ff286778db6fb0105">BAND_SLOT_EVACUATED</a>&nbsp;&nbsp;&nbsp;((<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *)(intptr_t)-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A magic value set in the band cache band array to denote a band which has been flushed from memory to disk. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6efee52493c12d35edd3d431282e6f24"></a><!-- doxytag: member="pgbdev.c::NO_BAND_YET" ref="a6efee52493c12d35edd3d431282e6f24" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a6efee52493c12d35edd3d431282e6f24">NO_BAND_YET</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A magic value set in the band index table to denote a band which cannot yet be entered into the table, because it has not been sent to the PageBuffer device for storage. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885a6481fc6d474d0be18bc0facf648d"></a><!-- doxytag: member="pgbdev.c::MAX_PARAMS" ref="a885a6481fc6d474d0be18bc0facf648d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a885a6481fc6d474d0be18bc0facf648d">MAX_PARAMS</a>&nbsp;&nbsp;&nbsp;(sizeof(devparams)/sizeof(devparams[0]))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of parameters in devparams array. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae52c7b46dbd94782385189e2a2497d86"></a><!-- doxytag: member="pgbdev.c::PARAM_IS_SET" ref="ae52c7b46dbd94782385189e2a2497d86" args="(_index_)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae52c7b46dbd94782385189e2a2497d86">PARAM_IS_SET</a>(_index_)&nbsp;&nbsp;&nbsp;((devparams[_index_].flags &amp; PARAM_SET) != 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a parameter has been set. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a2d6c31c5c5823cab9a6ca7df9365db9b">totalBandMemory</a> (<a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *req, size_t *sizes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ac8171440d76fc61aa485af867b43ebb8">bandCache_New</a> (<a class="el" href="structBandCache.html">BandCache</a> **ppValue, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> numBands, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> numSeparations)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor function for <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> structs.  <a href="#ac8171440d76fc61aa485af867b43ebb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89101cbc662aceb808dab47fdbfa6172"></a><!-- doxytag: member="pgbdev.c::initBandCache" ref="a89101cbc662aceb808dab47fdbfa6172" args="(PGBDescription *pPGB, HqBool first_time)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a89101cbc662aceb808dab47fdbfa6172">initBandCache</a> (<a class="el" href="structPGBDescription.html">PGBDescription</a> *pPGB, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> first_time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> structure for the current separation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07e004dc7d2d1174e70087340178b8a0"></a><!-- doxytag: member="pgbdev.c::closeBandCache" ref="a07e004dc7d2d1174e70087340178b8a0" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a07e004dc7d2d1174e70087340178b8a0">closeBandCache</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> exists, close (delete) it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8a1eda7c694b883f1d45bfee190783c"></a><!-- doxytag: member="pgbdev.c::deleteDiskCacheFile" ref="ac8a1eda7c694b883f1d45bfee190783c" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ac8a1eda7c694b883f1d45bfee190783c">deleteDiskCacheFile</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a disk cache file exists, delete it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07465e92e0ab007c4343c32bf21d8f94"></a><!-- doxytag: member="pgbdev.c::closeDiskCacheFile" ref="a07465e92e0ab007c4343c32bf21d8f94" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a07465e92e0ab007c4343c32bf21d8f94">closeDiskCacheFile</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the disk cache file if it is open. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a5f6915fe0c3ad04007f70eeee2064893">storeBandInCache</a> (<a class="el" href="structPGBDeviceState.html">PGBDeviceState</a> *pDeviceState, <a class="el" href="structPGBDescription.html">PGBDescription</a> *pPGB, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuff, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store bytes in the PGB store.  <a href="#a5f6915fe0c3ad04007f70eeee2064893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae7c0ca8c78dfd66d3319235305768af3">getBand</a> (<a class="el" href="structPGBDescription.html">PGBDescription</a> *pPGB, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuff, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pExpectedLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the band described by the state of a <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> into a buffer, either from memory or from disk. This is the highest level getter function for bands.  <a href="#ae7c0ca8c78dfd66d3319235305768af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ad27d714df3889023e7b462d34ce45b0e">initDiskCacheFileName</a> (const char *pszLeafDiskCacheFileName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialises the full path name of the disk cache file. The file will be in the SW\tmp directory, and will have the name specified by pszLeafDiskCacheFileName.  <a href="#ad27d714df3889023e7b462d34ce45b0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a3ec32cb9d6be22dd8d7603c941f3560f">updateDiskCache</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the disk cache, flushing all currently in-memory bands to the cache. This function creates a disk cache if one does not already exist.  <a href="#a3ec32cb9d6be22dd8d7603c941f3560f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a45759df87152a9532859104e92f23f35">KInitializePGBDescription</a> (<a class="el" href="structPGBDescription.html">PGBDescription</a> *pgb, const char *filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> struct.  <a href="#a45759df87152a9532859104e92f23f35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a85253d9786d1680e6775dfcbb662f557">KParseColorant</a> (<a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *changedp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a7a8da079018a43554f1505824e8ef91d">KFreePGBDescription</a> (<a class="el" href="structPGBDescription.html">PGBDescription</a> *pgb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor function for <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> structs.  <a href="#a7a8da079018a43554f1505824e8ef91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a8fbc90301c78515c9fed884ea71b15f6">pgb_init_device</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The init_device routine for the pagebuffer device type.  <a href="#a8fbc90301c78515c9fed884ea71b15f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa916460d9a2cbf4d5007b6d3639d0700"></a><!-- doxytag: member="pgbdev.c::pgb_open_file" ref="aa916460d9a2cbf4d5007b6d3639d0700" args="(DEVICELIST *dev, uint8 *filename, int32 openflags)" -->
static DEVICE_FILEDESCRIPTOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#aa916460d9a2cbf4d5007b6d3639d0700">pgb_open_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The open_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6a4284527a3f640b86886bfcf8d9db"></a><!-- doxytag: member="pgbdev.c::pgb_read_file" ref="abb6a4284527a3f640b86886bfcf8d9db" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#abb6a4284527a3f640b86886bfcf8d9db">pgb_read_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a244473e2c8e9c5eb55e67a94a7d26a71"></a><!-- doxytag: member="pgbdev.c::pgb_write_file" ref="a244473e2c8e9c5eb55e67a94a7d26a71" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a244473e2c8e9c5eb55e67a94a7d26a71">pgb_write_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The write_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a57d3b58b87e73557e55d513898913ac8">pgb_close_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The close_file routine for the pagebuffer device type.  <a href="#a57d3b58b87e73557e55d513898913ac8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a03d651789a9bfcc3ab698b93fc3607c2">pgb_abort_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abort_file function for the pagebuffer device type.  <a href="#a03d651789a9bfcc3ab698b93fc3607c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a139349f0fb1f0afc2b2e442bffdbc0b4">pgb_seek_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> whence)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The seek_file routine for the pagebuffer device type.  <a href="#a139349f0fb1f0afc2b2e442bffdbc0b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae456b0392fe55eead28a6dc33f5588d4"></a><!-- doxytag: member="pgbdev.c::pgb_bytes_file" ref="ae456b0392fe55eead28a6dc33f5588d4" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *bytes, int32 reason)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae456b0392fe55eead28a6dc33f5588d4">pgb_bytes_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bytes_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4101cef5a52c94453ad315447ca60e6e"></a><!-- doxytag: member="pgbdev.c::pgb_status_file" ref="a4101cef5a52c94453ad315447ca60e6e" args="(DEVICELIST *dev, uint8 *filename, STAT *statbuff)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a4101cef5a52c94453ad315447ca60e6e">pgb_status_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d2ab7a5c533d86656956f178bd84e18"></a><!-- doxytag: member="pgbdev.c::pgb_start_file_list" ref="a4d2ab7a5c533d86656956f178bd84e18" args="(DEVICELIST *dev, uint8 *pattern)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a4d2ab7a5c533d86656956f178bd84e18">pgb_start_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The start_file_list routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4334a5654c17577ba03f0e4512f27d3e"></a><!-- doxytag: member="pgbdev.c::pgb_next_file" ref="a4334a5654c17577ba03f0e4512f27d3e" args="(DEVICELIST *dev, void **handle, uint8 *pattern, FILEENTRY *entry)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a4334a5654c17577ba03f0e4512f27d3e">pgb_next_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void **handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="structFILEENTRY.html">FILEENTRY</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The next_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90a0ac4187a1338f3ce75ee8459b086d"></a><!-- doxytag: member="pgbdev.c::pgb_end_file_list" ref="a90a0ac4187a1338f3ce75ee8459b086d" args="(DEVICELIST *dev, void *handle)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a90a0ac4187a1338f3ce75ee8459b086d">pgb_end_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The end_file_list routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35eeba18124c26ba4fdb36d721a1473a"></a><!-- doxytag: member="pgbdev.c::pgb_rename_file" ref="a35eeba18124c26ba4fdb36d721a1473a" args="(DEVICELIST *dev, uint8 *file1, uint8 *file2)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a35eeba18124c26ba4fdb36d721a1473a">pgb_rename_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file1, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rename_file routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4e8cfde4c43a8589fdf7e6dde51776e"></a><!-- doxytag: member="pgbdev.c::pgb_delete_file" ref="ae4e8cfde4c43a8589fdf7e6dde51776e" args="(DEVICELIST *dev, uint8 *filename)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae4e8cfde4c43a8589fdf7e6dde51776e">pgb_delete_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The delete_file routine for the pagebuffer device type. It closes and destroys an in-memory or disk-based cache of PGB data that was created in earlier calls to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a56b6f14133ca0364b9bc8ec3dd61cdd9">pgb_set_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set_param function for the pagebuffer device type.  <a href="#a56b6f14133ca0364b9bc8ec3dd61cdd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a647f17c068e00d35d8d0554a9c1410fb"></a><!-- doxytag: member="pgbdev.c::pgb_start_param" ref="a647f17c068e00d35d8d0554a9c1410fb" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a647f17c068e00d35d8d0554a9c1410fb">pgb_start_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pgb_start_param <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a4f89ce2b7cddee8863fb14d8179a0369">pgb_status_device</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVSTAT *devstat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status_device function for the pagebuffer device type.  <a href="#a4f89ce2b7cddee8863fb14d8179a0369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a49b25a829aa780d94889c26e1cca5"></a><!-- doxytag: member="pgbdev.c::pgb_noerror" ref="a71a49b25a829aa780d94889c26e1cca5" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a71a49b25a829aa780d94889c26e1cca5">pgb_noerror</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The noerror routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31039897252fed94f2ab7a43ace666a"></a><!-- doxytag: member="pgbdev.c::pgb_ioerror" ref="ae31039897252fed94f2ab7a43ace666a" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae31039897252fed94f2ab7a43ace666a">pgb_ioerror</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ioerror routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438e98c050eb2c89ef9abdaa51829e5c"></a><!-- doxytag: member="pgbdev.c::pgb_void" ref="a438e98c050eb2c89ef9abdaa51829e5c" args="(DEVICELIST *dev)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a438e98c050eb2c89ef9abdaa51829e5c">pgb_void</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The void routine for the pagebuffer device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbadeed1f1247515bb62ee48214ad57b"></a><!-- doxytag: member="pgbdev.c::pgb_spare" ref="adbadeed1f1247515bb62ee48214ad57b" args="(void)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#adbadeed1f1247515bb62ee48214ad57b">pgb_spare</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pgb_spare <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a9646fc377dea76e734ecd2ed0c27a972">SwLePgbSetCallback</a> (const char *name, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> type, <a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *pfnPGBCallback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a callback functions for the named pagebuffer device parameter.  <a href="#a9646fc377dea76e734ecd2ed0c27a972"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91b8d6e529246572c12354e804d42441"></a><!-- doxytag: member="pgbdev.c::SwLePgbSetOverrideToNone" ref="a91b8d6e529246572c12354e804d42441" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a91b8d6e529246572c12354e804d42441">SwLePgbSetOverrideToNone</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Records that the user of the application has, from the command line, overridden the PageBuffer type default value by requesting "None", i.e. that output should be discarded. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#afc87dc0a2b9e994cb37a1619b9e0a83f">SwLePgbSetMultipleCopies</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fFlag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the default value of MultipleCopies to be overriden.  <a href="#afc87dc0a2b9e994cb37a1619b9e0a83f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a9ebcff9266b5640d7707b257b40a2e52">SwLePgbUseFrameBuffer</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fFlag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on testing of the framebuffer mode in the pgb device. We allocate a singleton framebuffer for the whole page. We deliberately allocate memory outside the rip's memory pool to emphasise the testing nature of this function.  <a href="#a9ebcff9266b5640d7707b257b40a2e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a0c27387dd64dc06727bcc38cd7834248">KGetBandCacheDev</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the underlying device of the PGB device, through which all IO operations are carried out.  <a href="#a0c27387dd64dc06727bcc38cd7834248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a526caa8f242b78fea0760de0a73ac421">bandCache_Free</a> (<a class="el" href="structBandCache.html">BandCache</a> *pValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor function for a <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> struct.  <a href="#a526caa8f242b78fea0760de0a73ac421"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#af4a964e4293ecde20b216d518461792e">openDiskCacheFile</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens the disk cache file for reading and writing, and stores the file descriptor of the opened cache file in bandCacheFD for later use.  <a href="#af4a964e4293ecde20b216d518461792e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#abde273ce67e8d332393977b2e3a7a478">diskCacheFileExists</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests for existence of the disk cache file.  <a href="#abde273ce67e8d332393977b2e3a7a478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#acb253a4e539a4f9e011d3474ee145329">makeDiskCacheFile</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates the disk cache file, and leaves it open for writing, assigning its file descriptor to bandCacheFD.  <a href="#acb253a4e539a4f9e011d3474ee145329"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a9ac4c9975b1ef6d9b3d4651bba969b4c">getLengthOfDiskCacheFile</a> (<a class="el" href="structHq32x2.html">Hq32x2</a> *pNumBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the length, in bytes, of the disk cache file. The file should have been opened with openDiskCacheFile or makeDiskCacheFile before calling.  <a href="#a9ac4c9975b1ef6d9b3d4651bba969b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a3fe4e78648ce9acbc203ec1e007b0e3b">getBandInfoFromDiskCache</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> bandIndex, <a class="el" href="structHq32x2.html">Hq32x2</a> *pLocation, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the disk cache file's header information on the band numbered bandNum. This information is the byte location of the band, and the length of the band, within the disk cache file.  <a href="#a3fe4e78648ce9acbc203ec1e007b0e3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a0fc47d59c27aa5f0cc601987b26ce553">createNewDiskCache</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new disk cache file, if it does not exist already.  <a href="#a0fc47d59c27aa5f0cc601987b26ce553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a92c9e3e713a74ca898e31c8a83be74d9">getMemoryForBand</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates the next len bytes of gBandMemory.pBandMemory for use by a band. If there is insufficient free memory in gBandMemory.pBandMemory then the entire in-memory band-cache is first flushed to a disk-based cache to free up the required memory.  <a href="#a92c9e3e713a74ca898e31c8a83be74d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#afe11a5e3ab34751cdb8ba4a8efd27f7b">seekToBandInDiskCache</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> bandIndex, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeks within the disk cache file to the start position of the band requested, with the length of the band returned in pLength.  <a href="#afe11a5e3ab34751cdb8ba4a8efd27f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a35ae5442b1c9414c45a763d4a19aa17a">readBytesFromDiskCache</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the requested number of bytes from the current seek position in the disk cache file, with the bytes returned in ppBuffer, which must be allocated by the caller and of the correct length.  <a href="#a35ae5442b1c9414c45a763d4a19aa17a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a0693b9add97bf6730febc693a29e0a61">getBandFromDiskCache</a> (<a class="el" href="structBandHolder.html">BandHolder</a> *pBandHolder, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> bandIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the band with the given index number from the disk cache file.  <a href="#a0693b9add97bf6730febc693a29e0a61"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15bd4c057c20663e3523eb84a0cb820"></a><!-- doxytag: member="pgbdev.c::bandCacheFD" ref="aa15bd4c057c20663e3523eb84a0cb820" args="" -->
static DEVICE_FILEDESCRIPTOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#aa15bd4c057c20663e3523eb84a0cb820">bandCacheFD</a> = (-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File descriptor of file to which the partial paint band cache is flushed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e3172fd9958d750dc0c2748f242d9a"></a><!-- doxytag: member="pgbdev.c::pszDiskCacheFullFileName" ref="a13e3172fd9958d750dc0c2748f242d9a" args="" -->
static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a13e3172fd9958d750dc0c2748f242d9a">pszDiskCacheFullFileName</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full path to disk cache file name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc8bca6a7da7b9b6a265359af97bf500"></a><!-- doxytag: member="pgbdev.c::pBandCache" ref="afc8bca6a7da7b9b6a265359af97bf500" args="" -->
static <a class="el" href="structBandCache.html">BandCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#afc8bca6a7da7b9b6a265359af97bf500">pBandCache</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If a partial paint is happening, a cache of in-memory bands will be stored here. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57b307f6e22968c02a084b0d32e1b44"></a><!-- doxytag: member="pgbdev.c::ppMemSize" ref="ab57b307f6e22968c02a084b0d32e1b44" args="" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ab57b307f6e22968c02a084b0d32e1b44">ppMemSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total memory required to store partial paint separations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a2cb210e957e977dfabc1c9e628a08908">skin_has_framebuffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating whether the skin has provided a complete, uncompressed framebuffer.  <a href="#a2cb210e957e977dfabc1c9e628a08908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a894c4a27cb5eb1d89f3f593836b74472">p_band_directory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acace78f52d268cce77c60103dcd49a08"></a><!-- doxytag: member="pgbdev.c::guPageHeightPixels" ref="acace78f52d268cce77c60103dcd49a08" args="" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#acace78f52d268cce77c60103dcd49a08">guPageHeightPixels</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The page size in pixels. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31165613e45460f7c0da08b5dae686e8"></a><!-- doxytag: member="pgbdev.c::guBandHeight" ref="a31165613e45460f7c0da08b5dae686e8" args="" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a31165613e45460f7c0da08b5dae686e8">guBandHeight</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The height in lines of each RIP band destined for the framebuffer, if present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b0817bbaf2cefeabb22ef1dcbcb9298"></a><!-- doxytag: member="pgbdev.c::guBytesPerLine" ref="a5b0817bbaf2cefeabb22ef1dcbcb9298" args="" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a5b0817bbaf2cefeabb22ef1dcbcb9298">guBytesPerLine</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of bytes per line in each RIP band destined for the framebuffer, if present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ccff1b46022035f9bc19ac2a1c38485"></a><!-- doxytag: member="pgbdev.c::guComponentsPerBand" ref="a1ccff1b46022035f9bc19ac2a1c38485" args="" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#a1ccff1b46022035f9bc19ac2a1c38485">guComponentsPerBand</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of color components in each RIP band destined for the framebuffer, if present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade5cc0f1cc3503cdf71306fd181e7c0b"></a><!-- doxytag: member="pgbdev.c::fUseFrameBuffer" ref="ade5cc0f1cc3503cdf71306fd181e7c0b" args="" -->
static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ade5cc0f1cc3503cdf71306fd181e7c0b">fUseFrameBuffer</a> = FALSE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating whether to test framebuffer functionality. It is set by SwLePgbUseFrameBuffer if the application has turned it on from the command line. This is for Testing Only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa541eefe9134a5809255ab838574ce6b"></a><!-- doxytag: member="pgbdev.c::override_to_none" ref="aa541eefe9134a5809255ab838574ce6b" args="" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#aa541eefe9134a5809255ab838574ce6b">override_to_none</a> = FALSE</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will be set to TRUE by SwLePgbSetOverrideToNone if the application has, from the command line, overridden the PostScript configuration of the PageBuffer type to be "None". FALSE otherwise. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae44a60d2568864df41ae58667cc57e8f"></a><!-- doxytag: member="pgbdev.c::last_param" ref="ae44a60d2568864df41ae58667cc57e8f" args="" -->
static <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html#ae44a60d2568864df41ae58667cc57e8f">last_param</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The start_param and get_param functions for the pagebuffer device type use last_param to maintain the local state. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>An example implementation of the PageBuffer device type. </p>
<p>This example is a minimal implementation illustrating a technique for handling large numbers of device parameters, and the subsidiary use of one device type from another. The exact semantics of the pagebuffer% device are described in Chapter 6 of the PostScript Language Reference Manual.</p>
<p>The pagebuffer device type is the medium for delivering the output raster data from the rip to its final destination. A device called pagebuffer% must exist in every implementation (otherwise the system will not start), and it is communicated with during the starting sequence, so it must be created in the Sys/ExtraDevices file (any later is too late) with the usual incantation: </p>
<pre>
     (pagebuffer%) dup statusdict begin devmount pop end
     &lt;&lt;
       /Enable true
       /DeviceType 16#ffff0003
       /Password 0
     &gt;&gt; setdevparams
 </pre><p> There is no reason ever to have more than one device mounted of pagebuffer type; and the device is non-relative, so at any time there will only be one file open on it (in practice, for either writing or read/write).</p>
<p>The device must be enabled because parameters are set for it in PostScript (indeed you may need to write PostScript to do this), but you would never open a file on the device explicitly in PostScript (though there is nothing that actually prevents you doing so). With the exception of device parameters, the pagebuffer% device and associated files are controlled entirely by the rip.</p>
<p>Each page is treated as a file on the pagebuffer% device, which is opened before the page contents are delivered and closed again afterwards. The raster data is communicated by the rip via write calls (and sometimes demanded back again via read calls), and essential data about the page of output and the capabilities of the particular implementation of the pagebuffer device is communicated (in both directions) with parameters of the device in the set_param and get_param functions.</p>
<p>Though the intended functionality of the device is rather specialized, the functional interface between the rip and files on the device is exactly the same as any other device. It was stated above that that the pagebuffer% device must exist for the rip to start, but that does not mean initially that its type need be special: it is possible to assign the pagebufer% device a device type of 10 (decimal) - see <a class="el" href="ripthread_8h.html" title="RIP lifecycle code.">ripthread.h</a> - which just implements it as a file on the filing system. This will allow the rip to start - which getting to that point is the most difficult part of the development - and later the device can be specialized to its intended purpose by reassigning its type number. (This is only possible because by definition device parameters are ignored when not recognized).</p>
<p>This example implementation is very similar to the idea outlined above. It does supply routines for its own device type rather than using a built-in device type, but these simply write the data to and from a named file on the os% device using subsidiary calls to that device's functions.</p>
<p>As well as illustrating this as a technique, another feature shown in this example is the handling of the large numbers of device parameters associated with the pagebuffer device. These parameters, which describe the page, are written as a header in the underlying file created by the pagebuffer device.</p>
<p>Producing a functional pagebuffer device for the output desired is the main purpose of your development. Among the considerations you will need to take into account when relacing this minimal implementation are:</p>
<p>o Timing. Real output devices are particularly sensitive to the timing behavior of the system.</p>
<p>o Dealing with different data formats, and rejecting those which are inappropriate. (Careful use of the SensePageDevice key to the setpagedevice operator can help to restrict the formats the pagebuffer will see).</p>
<p>o Correct handling of errors returned to the rip by the pagebuffer device type functions is important for the correct operation of the rip. A real output recorder would generate a variety of error conditions, some of which require a page to be reoutput, others of which will require the rip to abandon the page. For this reason there are some additional error codes which the only the pagebuffer last error function can return.</p>
<p>o Storage of incomplete page data (or correct handling of this case as an error). If the rip is short of memory it will render the page built up so far and pass it to the pagebuffer% device; it will then ask for it back later. To do so it would typically save the data to disk, probably compressing it as it does so. If the pagebuffer% device is incapable of doing this, it would need to report a DeviceVMError when the attempt is made to open the pagebuffer file when the PrintPage device parameter is false. This would, of course restrict the complexity of pages which the system can print; though this situation will not arise if the whole page can be represented in memory at once. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a526caa8f242b78fea0760de0a73ac421"></a><!-- doxytag: member="pgbdev.c::bandCache_Free" ref="a526caa8f242b78fea0760de0a73ac421" args="(BandCache *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bandCache_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBandCache.html">BandCache</a> *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor function for a <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> struct. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pValue</em>&nbsp;</td><td>Pointer to the <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> to free.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this does not free any memory allocated through gBandMemory, e.g. the array of BandHolders (ppBands). </p>

</div>
</div>
<a class="anchor" id="ac8171440d76fc61aa485af867b43ebb8"></a><!-- doxytag: member="pgbdev.c::bandCache_New" ref="ac8171440d76fc61aa485af867b43ebb8" args="(BandCache **ppValue, int32 numBands, int32 numSeparations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> bandCache_New </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBandCache.html">BandCache</a> **&nbsp;</td>
          <td class="paramname"> <em>ppValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>numBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>numSeparations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor function for <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> structs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ppValue</em>&nbsp;</td><td>A non-NULL <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> pointer to which the allocated <a class="el" href="structBandCache.html" title="Top-level structure representing a cache of bands. One of these is used if a partial...">BandCache</a> will be assigned.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numBands</em>&nbsp;</td><td>The number of bands that will be stored in the cache. This is the number of bands required to hold one separation.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numSeparations</em>&nbsp;</td><td>The number of separations in the job.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fc47d59c27aa5f0cc601987b26ce553"></a><!-- doxytag: member="pgbdev.c::createNewDiskCache" ref="a0fc47d59c27aa5f0cc601987b26ce553" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> createNewDiskCache </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new disk cache file, if it does not exist already. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abde273ce67e8d332393977b2e3a7a478"></a><!-- doxytag: member="pgbdev.c::diskCacheFileExists" ref="abde273ce67e8d332393977b2e3a7a478" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> diskCacheFileExists </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests for existence of the disk cache file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the file exists on disk; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c0ca8c78dfd66d3319235305768af3"></a><!-- doxytag: member="pgbdev.c::getBand" ref="ae7c0ca8c78dfd66d3319235305768af3" args="(PGBDescription *pPGB, uint8 *pBuff, uint32 *pExpectedLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> getBand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPGBDescription.html">PGBDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pPGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pExpectedLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the band described by the state of a <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> into a buffer, either from memory or from disk. This is the highest level getter function for bands. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPGB</em>&nbsp;</td><td>The PGB descriptor whose seek band is obtained.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pBuff</em>&nbsp;</td><td>The buffer into which the band data is read. This must be allocated by the caller -- ultimately the RIP itself.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pExpectedLength</em>&nbsp;</td><td>Expected length of the decompressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0693b9add97bf6730febc693a29e0a61"></a><!-- doxytag: member="pgbdev.c::getBandFromDiskCache" ref="a0693b9add97bf6730febc693a29e0a61" args="(BandHolder *pBandHolder, uint32 bandIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> getBandFromDiskCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBandHolder.html">BandHolder</a> *&nbsp;</td>
          <td class="paramname"> <em>pBandHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>bandIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the band with the given index number from the disk cache file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pBandHolder</em>&nbsp;</td><td>A pointer to <a class="el" href="structBandHolder.html" title="A container for band data delivered during partial paint or transparency compositing...">BandHolder</a> that will be set to describe the band.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bandIndex</em>&nbsp;</td><td>The index number of the band for which to get information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fe4e78648ce9acbc203ec1e007b0e3b"></a><!-- doxytag: member="pgbdev.c::getBandInfoFromDiskCache" ref="a3fe4e78648ce9acbc203ec1e007b0e3b" args="(uint32 bandIndex, Hq32x2 *pLocation, int32 *pLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> getBandInfoFromDiskCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>bandIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the disk cache file's header information on the band numbered bandNum. This information is the byte location of the band, and the length of the band, within the disk cache file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bandIndex</em>&nbsp;</td><td>The index number of the band for which to get information.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pLocation</em>&nbsp;</td><td>On success, the location of the band will be written into this argument. This value could be zero if the band has not yet been written out to this PageBuffer device.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pLength</em>&nbsp;</td><td>On success, the length in bytes of the band will be written into this argument. This value could be zero if the band has not yet been written out to this PageBuffer device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac4c9975b1ef6d9b3d4651bba969b4c"></a><!-- doxytag: member="pgbdev.c::getLengthOfDiskCacheFile" ref="a9ac4c9975b1ef6d9b3d4651bba969b4c" args="(Hq32x2 *pNumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> getLengthOfDiskCacheFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pNumBytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the length, in bytes, of the disk cache file. The file should have been opened with openDiskCacheFile or makeDiskCacheFile before calling. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNumBytes</em>&nbsp;</td><td>If it exists, the number of bytes in the disk cache file will be written into this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a92c9e3e713a74ca898e31c8a83be74d9"></a><!-- doxytag: member="pgbdev.c::getMemoryForBand" ref="a92c9e3e713a74ca898e31c8a83be74d9" args="(uint32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a>* getMemoryForBand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates the next len bytes of gBandMemory.pBandMemory for use by a band. If there is insufficient free memory in gBandMemory.pBandMemory then the entire in-memory band-cache is first flushed to a disk-based cache to free up the required memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>The size of the band.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to memory to hold the band on success; NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad27d714df3889023e7b462d34ce45b0e"></a><!-- doxytag: member="pgbdev.c::initDiskCacheFileName" ref="ad27d714df3889023e7b462d34ce45b0e" args="(const char *pszLeafDiskCacheFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> initDiskCacheFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszLeafDiskCacheFileName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises the full path name of the disk cache file. The file will be in the SW\tmp directory, and will have the name specified by pszLeafDiskCacheFileName. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pszLeafDiskCacheFileName</em>&nbsp;</td><td>Leaf name of the disk cache file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a8da079018a43554f1505824e8ef91d"></a><!-- doxytag: member="pgbdev.c::KFreePGBDescription" ref="a7a8da079018a43554f1505824e8ef91d" args="(PGBDescription *pgb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void KFreePGBDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPGBDescription.html">PGBDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pgb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor function for <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> structs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgb</em>&nbsp;</td><td>Pointer to the PGB to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c27387dd64dc06727bcc38cd7834248"></a><!-- doxytag: member="pgbdev.c::KGetBandCacheDev" ref="a0c27387dd64dc06727bcc38cd7834248" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdevicelist.html">DEVICELIST</a>* KGetBandCacheDev </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the underlying device of the PGB device, through which all IO operations are carried out. </p>
<p>The PGB device sometimes needs to store temporary portions of raster data, such as in low-memory situations, or when the RIP is compositing transparent regions. For reasons of flexibility, the RIP uses a secondary (or "underlying") device for this storage. Once the underlying device has been selected, it will be used for the remainder of this RIP session. The device is chosen according to a preferential search pattern as follows:-</p>
<ul>
<li>Any device called <code>jobtmp</code> is the first choice. The implementation of this device may not preserve files between jobs. If the SW resources folder has been compiled into RAM, or has been designated read-only, a <code>jobtmp</code> device can be mounted during RIP initialization, as demonstrated by MountOtherDevices() in skintest::c. This device can designate a disk directory for temporary cache data, such as the PGB band cache, and so can avoid any undue consumption of RAM for such data.</li>
</ul>
<ul>
<li>Any device called <code>tmp</code> is the second choice. If the SW resources folder is a writable directory, there will not be a <code>jobtmp</code> device by default, because MountOtherDevices() does not mount one. The <code>tmp</code> device is typically a sub-directory of SW, which is suitable when this directory is writable. When the SW folder is read-only, the <code>tmp</code> device is actually serviced by RAM, which is why it is beneficial to mount a <code>jobtmp</code> device in preference.</li>
</ul>
<ul>
<li>The <code>os</code> device is the final choice, since neither of <code>tmp</code> or <code>jobtmp</code> are guaranteed to exist. The <code>os</code> device is always present. Like <code>tmp</code>, it will be disk-based when the SW folder is writable, and RAM-based otherwise. </li>
</ul>

</div>
</div>
<a class="anchor" id="a45759df87152a9532859104e92f23f35"></a><!-- doxytag: member="pgbdev.c::KInitializePGBDescription" ref="a45759df87152a9532859104e92f23f35" args="(PGBDescription *pgb, const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KInitializePGBDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPGBDescription.html">PGBDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pgb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> struct. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgb</em>&nbsp;</td><td>Pointer to the <a class="el" href="structPGBDescription.html" title="The PGBDescription structure contains a RasterDescription, which is the part exported...">PGBDescription</a> to initialize.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>Name of the file to create for storing PGB data in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a85253d9786d1680e6775dfcbb662f557"></a><!-- doxytag: member="pgbdev.c::KParseColorant" ref="a85253d9786d1680e6775dfcbb662f557" args="(DEVICEPARAM *param, HqBool *changedp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KParseColorant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *&nbsp;</td>
          <td class="paramname"> <em>changedp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a colorant description parameter, and add it to the current list of colorants. </p>

</div>
</div>
<a class="anchor" id="acb253a4e539a4f9e011d3474ee145329"></a><!-- doxytag: member="pgbdev.c::makeDiskCacheFile" ref="acb253a4e539a4f9e011d3474ee145329" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> makeDiskCacheFile </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the disk cache file, and leaves it open for writing, assigning its file descriptor to bandCacheFD. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af4a964e4293ecde20b216d518461792e"></a><!-- doxytag: member="pgbdev.c::openDiskCacheFile" ref="af4a964e4293ecde20b216d518461792e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openDiskCacheFile </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the disk cache file for reading and writing, and stores the file descriptor of the opened cache file in bandCacheFD for later use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a03d651789a9bfcc3ab698b93fc3607c2"></a><!-- doxytag: member="pgbdev.c::pgb_abort_file" ref="a03d651789a9bfcc3ab698b93fc3607c2" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_abort_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The abort_file function for the pagebuffer device type. </p>
<p>This function will be called in place of close_file when an error is reported during rendering which causes rendering to be abandoned.</p>
<p>For this example, cleans up in the event of an error by closing and deleting the underlying file. </p>

</div>
</div>
<a class="anchor" id="a57d3b58b87e73557e55d513898913ac8"></a><!-- doxytag: member="pgbdev.c::pgb_close_file" ref="a57d3b58b87e73557e55d513898913ac8" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_close_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The close_file routine for the pagebuffer device type. </p>
<p>Note that this function may be called multiple times on the same page if partial painting is invoked. </p>

</div>
</div>
<a class="anchor" id="a8fbc90301c78515c9fed884ea71b15f6"></a><!-- doxytag: member="pgbdev.c::pgb_init_device" ref="a8fbc90301c78515c9fed884ea71b15f6" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_init_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The init_device routine for the pagebuffer device type. </p>
<p>In this example, it is required to fill in the parameter name lengths, which we cannot conveniently initialize statically. </p>

</div>
</div>
<a class="anchor" id="a139349f0fb1f0afc2b2e442bffdbc0b4"></a><!-- doxytag: member="pgbdev.c::pgb_seek_file" ref="a139349f0fb1f0afc2b2e442bffdbc0b4" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *destination, int32 whence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_seek_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>whence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The seek_file routine for the pagebuffer device type. </p>
<p>This function is required. Because we have set the WriteAllOutput parameter to TRUE, we know that we will receive all data, but only on the final paint. Partial paints may leave "holes" in the file. We do not have to fill them with zeros, because of the behavior of WriteAllOutput on the final paint. If we had set it to FALSE, we would have had to supply a zero band.</p>
<p>The seek is to the first line of a band. The PGB parameter BandLines indicates how many lines are in this band.</p>
<p>For this example, this is just a matter of seeking in the underlying file, not forgetting to add the size of the header we put at the beginning. </p>

</div>
</div>
<a class="anchor" id="a56b6f14133ca0364b9bc8ec3dd61cdd9"></a><!-- doxytag: member="pgbdev.c::pgb_set_param" ref="a56b6f14133ca0364b9bc8ec3dd61cdd9" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_set_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The set_param function for the pagebuffer device type. </p>
<p>This implementation uses the structures defined at the head of the file to record the parameters.</p>
<p>This is done by a simple search on the name. However, given the very large number of parameters it would be more efficient to use a hashing technique or a binary chop on a table organised alphabetically or something of the kind. </p>

</div>
</div>
<a class="anchor" id="a4f89ce2b7cddee8863fb14d8179a0369"></a><!-- doxytag: member="pgbdev.c::pgb_status_device" ref="a4f89ce2b7cddee8863fb14d8179a0369" args="(DEVICELIST *dev, DEVSTAT *devstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> pgb_status_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVSTAT *&nbsp;</td>
          <td class="paramname"> <em>devstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The status_device function for the pagebuffer device type. </p>
<p>This function has a rather specialized interpretation for the pagebuffer device. It can be used to give more memory to the rip in which it can render: either a whole page's worth (and we know from the pgbparams structure how big that is going to be) to operate as a frame device, or any spare memory so that it can get further ahead of the real printer if it has time to do so.</p>
<p>In this example, we supply no additional memory. </p>

</div>
</div>
<a class="anchor" id="a35ae5442b1c9414c45a763d4a19aa17a"></a><!-- doxytag: member="pgbdev.c::readBytesFromDiskCache" ref="a35ae5442b1c9414c45a763d4a19aa17a" args="(uint8 *pBuffer, int32 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> readBytesFromDiskCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the requested number of bytes from the current seek position in the disk cache file, with the bytes returned in ppBuffer, which must be allocated by the caller and of the correct length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>The output buffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read, and write into ppBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afe11a5e3ab34751cdb8ba4a8efd27f7b"></a><!-- doxytag: member="pgbdev.c::seekToBandInDiskCache" ref="afe11a5e3ab34751cdb8ba4a8efd27f7b" args="(uint32 bandIndex, int32 *pLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> seekToBandInDiskCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>bandIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seeks within the disk cache file to the start position of the band requested, with the length of the band returned in pLength. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bandIndex</em>&nbsp;</td><td>The index number of the band for which to get information.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pLength</em>&nbsp;</td><td>The number of bytes in the band bandNum will be written into this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f6915fe0c3ad04007f70eeee2064893"></a><!-- doxytag: member="pgbdev.c::storeBandInCache" ref="a5f6915fe0c3ad04007f70eeee2064893" args="(PGBDeviceState *pDeviceState, PGBDescription *pPGB, uint8 *pBuff, uint32 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> storeBandInCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPGBDeviceState.html">PGBDeviceState</a> *&nbsp;</td>
          <td class="paramname"> <em>pDeviceState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPGBDescription.html">PGBDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pPGB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store bytes in the PGB store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pDeviceState</em>&nbsp;</td><td>The pagebuffer device state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pPGB</em>&nbsp;</td><td>The PGB containing the store that will be accessed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pBuff</em>&nbsp;</td><td>The buffer containing the bytes to be stored. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read from pBuff.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if store succeeded; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9646fc377dea76e734ecd2ed0c27a972"></a><!-- doxytag: member="pgbdev.c::SwLePgbSetCallback" ref="a9646fc377dea76e734ecd2ed0c27a972" args="(const char *name, int32 type, SwLeParamCallback *pfnPGBCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> SwLePgbSetCallback </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>paramtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnPGBCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a callback functions for the named pagebuffer device parameter. </p>
<p>If a callback function is registered correctly, it will be called whenever the value of the pagebuffer device parameter is <em>changed</em>. There is exactly one callback for each parameter; setting the callback will override the previous callback definition. To remove a callback hook, call this function with a <code>NULL</code> function pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>paramname</em>&nbsp;</td><td>The parameter name to monitor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paramtype</em>&nbsp;</td><td>The type of the parameter name to monitor. The callback functions use a generic pointer to pass the changed parameter value. Passing the expected type in with the hook function lets the skinkit check that the hook function will be passed the type it expects.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnPGBCallback</em>&nbsp;</td><td>Pointer to a function though which the RIP informs the skin of pagebuffer type changes. The skin may call <code>SwLeSetCallbacks</code> in this routine, to route callbacks to different backends.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>If the callback could not be set (either the name or type of the PGB param is incorrect).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>If the callback was set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc87dc0a2b9e994cb37a1619b9e0a83f"></a><!-- doxytag: member="pgbdev.c::SwLePgbSetMultipleCopies" ref="afc87dc0a2b9e994cb37a1619b9e0a83f" args="(int32 fFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLePgbSetMultipleCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fFlag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the default value of MultipleCopies to be overriden. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fFlag</em>&nbsp;</td><td>The desired value of MultipleCopies, TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ebcff9266b5640d7707b257b40a2e52"></a><!-- doxytag: member="pgbdev.c::SwLePgbUseFrameBuffer" ref="a9ebcff9266b5640d7707b257b40a2e52" args="(int32 fFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLePgbUseFrameBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fFlag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns on testing of the framebuffer mode in the pgb device. We allocate a singleton framebuffer for the whole page. We deliberately allocate memory outside the rip's memory pool to emphasise the testing nature of this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fFlag</em>&nbsp;</td><td>TRUE to turn the test on. Default is FALSE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d6c31c5c5823cab9a6ca7df9365db9b"></a><!-- doxytag: member="pgbdev.c::totalBandMemory" ref="a2d6c31c5c5823cab9a6ca7df9365db9b" args="(RASTER_REQUIREMENTS *req, size_t *sizes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t totalBandMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sizes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the amount of band memory needed for this page. </p>

</div>
</div>
<a class="anchor" id="a3ec32cb9d6be22dd8d7603c941f3560f"></a><!-- doxytag: member="pgbdev.c::updateDiskCache" ref="a3ec32cb9d6be22dd8d7603c941f3560f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> updateDiskCache </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the disk cache, flushing all currently in-memory bands to the cache. This function creates a disk cache if one does not already exist. </p>
<p>The disk cache is a file containing compressed band data. It has a header section, which is an index of band positions and lengths, consisting of an unsigned 32-bit integer for each of the values. Seeking within the disk cache involves reading the header entry for the band number required, and seeking to the position described in the entry. Reading from the disk cache then involves reading the band length entry's number of bytes from the current byte position. Writing to the disk cache involves writing the band to the end of the file when the band arrives in the PageBuffer device for the first time. If an updated version of the band is sent to disk again, updateDiskCache will check the size of the original compressed band: if the new band is not bigger, it can be written into its original slot (with the length part of the header entry for the band updated if necessary). If the updated band is too big for its original slot in the disk cache file, it is written to the end of the file, and the position part of the header entry is updated to point to the new location, as well as the length part being updated. This means that if bands are updated and after compression are bigger than they were before, the disk cache file will become fragmented.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a894c4a27cb5eb1d89f3f593836b74472"></a><!-- doxytag: member="pgbdev.c::p_band_directory" ref="a894c4a27cb5eb1d89f3f593836b74472" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>* <a class="el" href="pgbdev_8c.html#a894c4a27cb5eb1d89f3f593836b74472">p_band_directory</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An array of flags indicating if the band has been written by a partial paint.</p>
<p>Array index is the band number in the separation. </p>

</div>
</div>
<a class="anchor" id="a2cb210e957e977dfabc1c9e628a08908"></a><!-- doxytag: member="pgbdev.c::skin_has_framebuffer" ref="a2cb210e957e977dfabc1c9e628a08908" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> <a class="el" href="pgbdev_8c.html#a2cb210e957e977dfabc1c9e628a08908">skin_has_framebuffer</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag indicating whether the skin has provided a complete, uncompressed framebuffer. </p>
<p>If the skin has provided a framebuffer, it will be used for partial paints in preference to the band cache. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
