<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: xpsbuild.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_30ea0f072a45d4235daf97fe839164a5.html">export</a>
  </div>
</div>
<div class="contents">
<h1>xpsbuild.h File Reference</h1>
<p>Provides an API for building XPS package parts using the in-memory virtual filesystem (MFS).  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="std_8h.html">std.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="file_8h.html">file.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="memfs_8h.html">memfs.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="streams_8h.html">streams.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__URIContextMapping.html">_URIContextMapping</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linked list entry describing the document, page and resource type context for a given URI.  <a href="struct__URIContextMapping.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__URIContextMappingsList.html">_URIContextMappingsList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates a single linked list of <code>URIContextMapping</code> objects.  <a href="struct__URIContextMappingsList.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__URIContextMapping.html">_URIContextMapping</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a0914d5e01fa493dbd0c3390e0733f23b">URIContextMapping</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linked list entry describing the document, page and resource type context for a given URI.  <a href="#a0914d5e01fa493dbd0c3390e0733f23b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5f8697f46b9d9e64b549042d6cc03e"></a><!-- doxytag: member="xpsbuild.h::URIContextMappingsList" ref="aef5f8697f46b9d9e64b549042d6cc03e" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__URIContextMappingsList.html">_URIContextMappingsList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#aef5f8697f46b9d9e64b549042d6cc03e">URIContextMappingsList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates a single linked list of <code>URIContextMapping</code> objects. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__URIContextMapping.html">URIContextMapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a6bd614cbd1aa9b5c4768079285f1a0c3">lookupContextMapping</a> (<a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *pMappings, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszPartName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper utility for looking up a single entry in a list of URI context mappings.  <a href="#a6bd614cbd1aa9b5c4768079285f1a0c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a1ac54b1c8e97f3a7e092558fc301a03e">buildXPSPackageInMemory</a> (<a class="el" href="struct__XPSPackageDescription.html">XPSPackageDescription</a> *pXPD, <a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *pMappings, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pDevErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an XPS package in memory, and return a pointer to the build context.  <a href="#a1ac54b1c8e97f3a7e092558fc301a03e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#ac5c497c27983fd53b384778faf045039">addFixedPageToXPSPackage</a> (void *pContext, <a class="el" href="struct__XPSPageDescription.html">XPSPageDescription</a> *pPage, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pDevErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new XPS Fixed Page to a package.  <a href="#ac5c497c27983fd53b384778faf045039"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#ab120896495d835af48a58606116f62c5">addFixedDocumentToXPSPackage</a> (void *pContext, <a class="el" href="struct__XPSDocumentDescription.html">XPSDocumentDescription</a> *pDocument, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pDevErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new XPS Fixed Document to a package.  <a href="#ab120896495d835af48a58606116f62c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a0ff279061f9b23046343f07a2d190d17">getXPSPackageRoot</a> (void *pContext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the root node of RAM filesystem storage for the XPS package.  <a href="#a0ff279061f9b23046343f07a2d190d17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a05aa11a7ec116780d7d26bdd750eeb44">commitXPSPackageInMemory</a> (void *pContext, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pDevErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal that an XPS package is complete.  <a href="#a05aa11a7ec116780d7d26bdd750eeb44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html#a435ff8580afc32e6f63e19e77a3c3388">freeXPSPackageInMemory</a> (void *pContext, <a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *pMappings)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release all memory associated with an XPS package that was previously built with <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>.  <a href="#a435ff8580afc32e6f63e19e77a3c3388"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides an API for building XPS package parts using the in-memory virtual filesystem (MFS). </p>
<p>This interface is primarily aimed at supporting the <code>XPS Input Device Type</code> (xpsdev), as implemented in <a class="el" href="xpsdev_8c.html" title="Implementation of an input device for obtaining XPS page parts from an external source...">xpsdev.c</a> in the skinkit. Independent use of this interface for other purposes is not recommended. Future releases might change this interface in arbitrary ways.</p>
<p>The purpose of this interface is to transform an abstract description of an XPS package into a RAM filesystem. Package descriptions are provided by the <code>XPSPackageDescription</code> structure and its various nested elements, as defined in <a class="el" href="streams_8h.html" title="A simple streaming abstraction to handle RIP I/O when using the Reference API.">streams.h</a> in the skinkit. The package description gives the number of documents in the package, the number of pages in each document, and the content types for the resources used by each page. (It does not include actual page markup or resource data). This information is used to build a tree of in-memory files, which form the backbone of the XPS container. This includes the Fixed Document Sequence (.fdseq) file for the package, the Fixed Document (.fdoc) file for each document, and all of the relationships (.rels) files. It also includes a single [Content_Types].xml file. The <code>XPSPackageDescription</code> contains enough information for all of this to be created. The in-memory files are built using the Memory File System (MFS) interface, as defined in <a class="el" href="memfs_8h.html" title="Simple API for managing an in-memory, virtual file system.">memfs.h</a> within the skinkit.</p>
<p>Once the virtual filesystem is built, it is captured by the xpsdev device state. This package backbone provides a basic fileset that guides the RIP through the interpretation and rendering of the package. Of course, most of the package is effectively "missing" from this fileset. The markup and resource files are not present. When the RIP attempts to open these, xpsdev intercepts the calls, and transforms them into corresponding <code>OpenResourceStream()</code> calls in its <code>XPSPackageStreamManager</code>, which is also part of the device state. As the RIP executes a package from xpsdev, it is transparently using a mixture of in-memory files (for overall structure and relationships) and externally-implemented streams (for actual markup and resource content). This part of the interface just takes care of generating the in-memory parts. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0914d5e01fa493dbd0c3390e0733f23b"></a><!-- doxytag: member="xpsbuild.h::URIContextMapping" ref="a0914d5e01fa493dbd0c3390e0733f23b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__URIContextMapping.html">_URIContextMapping</a>  <a class="el" href="struct__URIContextMapping.html">URIContextMapping</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linked list entry describing the document, page and resource type context for a given URI. </p>
<p>This structure is used to help the xpsdev make outgoing calls to the <code>OpenResourceStream()</code> function in <code>XPSPackageStreamManager</code>. The URI scheme used internally by xpsdev need not necessarily match the scheme being used by the external package manager. The only cases where a precise match can be assumed is where the URIs have been explicitly declared by the external manager already, as is the case with resource streams such as fonts and images. For other parts, such as page markups and print tickets, the stream is addressed by its <code>context</code>, rather than by a URI string. This structure maps the internal part name onto the correct context, allowing xpsdev to pass out the context information instead of the URI itself.</p>
<p>For example, suppose the external manager has described an XPS package with a single document of 10 pages. When this package representation is built within the MFS virtual file tree, the URI of the fifth page will be <code>"/documents/1/pages/5.fpage"</code>. When the RIP needs to read the markup for this page, the part will not be addressed using this URI. This because the URI is an internal fabrication within xpsdev, and the external package manager may not understand it. The external manager might employ a completely different scheme, whereby the URI of the markup part does not match <code>"/documents/1/pages/5.fpage"</code>. So, instead of passing this internal URI out to the stream manager, it will simply ask for a resource of type <code>ResourceType_Page_Markup</code>, where <code>(iDocument == 0 &amp;&amp; iPage == 4)</code> (rather than 1 and 5, since the indexes are zero-based). The external manager can then transform this logical part address according to its own scheme for finding the markup. The same applies to print tickets. The RIP would address the print ticket for page 5 (if there is one), using <code>ResourceType_Page_PT</code>, with the same values for <code>iDocument</code> and <code>iPage</code>.</p>
<p>When an XPS document description is built using MFS, a list of these mappings is produced as a by-product. When a particular part file is opened on xpdev, the list can be scanned for an entry whose URI matches the file name. If a match is found, then this determines the context. If no match is found, then the document and page contexts are assumed to be unchanged, and the resource type is the generic <code>ResourceType_URI</code>. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab120896495d835af48a58606116f62c5"></a><!-- doxytag: member="xpsbuild.h::addFixedDocumentToXPSPackage" ref="ab120896495d835af48a58606116f62c5" args="(void *pContext, XPSDocumentDescription *pDocument, int32 *pDevErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> addFixedDocumentToXPSPackage </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__XPSDocumentDescription.html">XPSDocumentDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pDevErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new XPS Fixed Document to a package. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>A pointer to the build context. This <em>must</em> be a pointer that was returned from an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>..</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDocument</em>&nbsp;</td><td>A pointer to a description of the new document, which may include one or more pages. It is permissible to add a new document /e before adding any of its pages. This, in fact, would be typical when integrating the RIP with a pipeline architecture. It might be better to think of this function as /e starting a new document, rather than adding it in its entirity (although the interface also allows that). Subsequent calls to <code><a class="el" href="xpsbuild_8c.html#ac5c497c27983fd53b384778faf045039" title="Add a new XPS Fixed Page to a package.">addFixedPageToXPSPackage()</a></code> can be considered as adding pages to this document, until a further document is added, or the package is closed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDevErr</em>&nbsp;</td><td>If there is a failure, this parameter will receive a standard error code, according to the conventions of the Core RIP Device Interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c497c27983fd53b384778faf045039"></a><!-- doxytag: member="xpsbuild.h::addFixedPageToXPSPackage" ref="ac5c497c27983fd53b384778faf045039" args="(void *pContext, XPSPageDescription *pPage, int32 *pDevErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> addFixedPageToXPSPackage </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__XPSPageDescription.html">XPSPageDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pPage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pDevErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new XPS Fixed Page to a package. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>A pointer to the build context. This <em>must</em> be a pointer that was returned from an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>..</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPage</em>&nbsp;</td><td>A pointer to a description of the new page, including the URIs and content types of all resources used by the page. This interface does not support incremental process at any level finer than a single page. For instance, it is not possible to add further resource URIs or content types for a page, after calling this function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDevErr</em>&nbsp;</td><td>If there is a failure, this parameter will receive a standard error code, according to the conventions of the Core RIP Device Interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac54b1c8e97f3a7e092558fc301a03e"></a><!-- doxytag: member="xpsbuild.h::buildXPSPackageInMemory" ref="a1ac54b1c8e97f3a7e092558fc301a03e" args="(XPSPackageDescription *pXPD, URIContextMappingsList *pMappings, int32 *pDevErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* buildXPSPackageInMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__XPSPackageDescription.html">XPSPackageDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>pXPD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *&nbsp;</td>
          <td class="paramname"> <em>pMappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pDevErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build an XPS package in memory, and return a pointer to the build context. </p>
<p>Use <code><a class="el" href="xpsbuild_8c.html#a435ff8580afc32e6f63e19e77a3c3388" title="Release all memory associated with an XPS package that was previously built with...">freeXPSPackageInMemory()</a></code> to completely delete the package when it is no longer needed. Failure to do this will incur memory leaks.</p>
<p>XPS Packages built using this function are built using the Memory File System (MFS). Therefore, they only persist while the host process is alive. The root directory of the package is returned by <code><a class="el" href="xpsbuild_8c.html#a0ff279061f9b23046343f07a2d190d17" title="Returns the root node of RAM filesystem storage for the XPS package.">getXPSPackageRoot()</a></code>. This root directory should be used to mount a new instance of the XPS input device (<a class="el" href="xpsdev_8c.html">xpsdev.c</a>). It is then possible to render the package using the <code>xmlexec</code> operator, using the "_rels/.rels" filename to bootstrap the interpretation.</p>
<p>It is possible to add further pages and documents to the package while it is being interpreted. The XPS input device arranges to automatically block the interpreter when the RIP reaches a part that is not yet available. For this reason, it is <em>vital</em> to call the <code><a class="el" href="xpsbuild_8c.html#a05aa11a7ec116780d7d26bdd750eeb44" title="Signal that an XPS package is complete.">commitXPSPackageInMemory()</a></code> function when there are no more parts to be added. Failure to call this function will cause the RIP to stall indefinitely, expecting further parts to be added. The functions <code><a class="el" href="xpsbuild_8c.html#ac5c497c27983fd53b384778faf045039" title="Add a new XPS Fixed Page to a package.">addFixedPageToXPSPackage()</a></code> and <code><a class="el" href="xpsbuild_8c.html#ab120896495d835af48a58606116f62c5" title="Add a new XPS Fixed Document to a package.">addFixedDocumentToXPSPackage()</a></code> can be used to extend the package while the RIP is processing it. This method of delivery is very useful when integrating the RIP with pipelined architectures, such as the XPSDrv Filter Pipeline. When pre-RIP components are generating package parts incrementally, it is more efficient to start RIPping the package immediately, rather than to wait until all parts are available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pXPD</em>&nbsp;</td><td>Pointer to the complete description of the XPS package.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMappings</em>&nbsp;</td><td>Pointer to an empty list of URI context mappings. The list will be populated by this function, if it succeeds. The caller should not free this list, or any of its elements. The list as a whole will be freed by the later call to <code><a class="el" href="xpsbuild_8c.html#a435ff8580afc32e6f63e19e77a3c3388" title="Release all memory associated with an XPS package that was previously built with...">freeXPSPackageInMemory()</a></code>, which the caller is expected to make when the package is no longer required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDevErr</em>&nbsp;</td><td>If there is a failure, this parameter will receive a standard error code, according to the conventions of the Core RIP Device Interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the function succeeds, the return value is a pointer to a build context. This is an opaque token that must be used in all later calls to <code><a class="el" href="xpsbuild_8c.html#ab120896495d835af48a58606116f62c5" title="Add a new XPS Fixed Document to a package.">addFixedDocumentToXPSPackage()</a></code>, <code><a class="el" href="xpsbuild_8c.html#ac5c497c27983fd53b384778faf045039" title="Add a new XPS Fixed Page to a package.">addFixedPageToXPSPackage()</a></code>, <code><a class="el" href="xpsbuild_8c.html#a0ff279061f9b23046343f07a2d190d17" title="Returns the root node of RAM filesystem storage for the XPS package.">getXPSPackageRoot()</a></code>, <code><a class="el" href="xpsbuild_8c.html#a05aa11a7ec116780d7d26bdd750eeb44" title="Signal that an XPS package is complete.">commitXPSPackageInMemory()</a></code> and <code><a class="el" href="xpsbuild_8c.html#a435ff8580afc32e6f63e19e77a3c3388" title="Release all memory associated with an XPS package that was previously built with...">freeXPSPackageInMemory()</a></code>. If the function fails, the return value is <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a05aa11a7ec116780d7d26bdd750eeb44"></a><!-- doxytag: member="xpsbuild.h::commitXPSPackageInMemory" ref="a05aa11a7ec116780d7d26bdd750eeb44" args="(void *pContext, int32 *pDevErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void commitXPSPackageInMemory </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pDevErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal that an XPS package is complete. </p>
<p>This function should be called when there are no further pages or documents to be added to the package.</p>
<p>The RIP cannot finish rendering an XPS package until this function has been called. Even if the initial package description is complete when passed to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>, it is still necessary to call <code><a class="el" href="xpsbuild_8c.html#a05aa11a7ec116780d7d26bdd750eeb44" title="Signal that an XPS package is complete.">commitXPSPackageInMemory()</a></code> afterwards. Failure to call this function will cause a deadlock in the RIP.</p>
<p>Once this function has been called for a particular XPS package, it is no longer legal to add any further contents to the package with <code><a class="el" href="xpsbuild_8c.html#ac5c497c27983fd53b384778faf045039" title="Add a new XPS Fixed Page to a package.">addFixedPageToXPSPackage()</a></code> or <code><a class="el" href="xpsbuild_8c.html#ab120896495d835af48a58606116f62c5" title="Add a new XPS Fixed Document to a package.">addFixedDocumentToXPSPackage()</a></code>. Any attempt to do so may have undesirable consequences.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>A pointer to the build context. This <em>must</em> be a pointer that was returned from an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDevErr</em>&nbsp;</td><td>If there is a failure, this parameter will receive a standard error code, according to the conventions of the Core RIP Device Interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a435ff8580afc32e6f63e19e77a3c3388"></a><!-- doxytag: member="xpsbuild.h::freeXPSPackageInMemory" ref="a435ff8580afc32e6f63e19e77a3c3388" args="(void *pContext, URIContextMappingsList *pMappings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeXPSPackageInMemory </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *&nbsp;</td>
          <td class="paramname"> <em>pMappings</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release all memory associated with an XPS package that was previously built with <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>A pointer to the build context. This <em>must</em> be a pointer that was returned from an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMappings</em>&nbsp;</td><td>Pointer to a populated list of URI context mappings. This <em>must</em> be a list that was populated by an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ff279061f9b23046343f07a2d190d17"></a><!-- doxytag: member="xpsbuild.h::getXPSPackageRoot" ref="a0ff279061f9b23046343f07a2d190d17" args="(void *pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* getXPSPackageRoot </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the root node of RAM filesystem storage for the XPS package. </p>
<p>The node returned by this function will be a directory node. A file of the name "_rels/.rels" will exist relative to this root. This file can be used as input to the <code>xmlexec</code> operator, in order to interpret and render the package.</p>
<p>The node returned by this function should not be freed directly with <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code>. Instead, always free the package and all of its resources using <code><a class="el" href="xpsbuild_8c.html#a435ff8580afc32e6f63e19e77a3c3388" title="Release all memory associated with an XPS package that was previously built with...">freeXPSPackageInMemory()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>A pointer to the build context. This <em>must</em> be a pointer that was returned from an earlier, successful call to <code><a class="el" href="xpsbuild_8c.html#a1ac54b1c8e97f3a7e092558fc301a03e" title="Build an XPS package in memory, and return a pointer to the build context.">buildXPSPackageInMemory()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bd614cbd1aa9b5c4768079285f1a0c3"></a><!-- doxytag: member="xpsbuild.h::lookupContextMapping" ref="a6bd614cbd1aa9b5c4768079285f1a0c3" args="(URIContextMappingsList *pMappings, uint8 *pszPartName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__URIContextMapping.html">URIContextMapping</a>* lookupContextMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__URIContextMappingsList.html">URIContextMappingsList</a> *&nbsp;</td>
          <td class="paramname"> <em>pMappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszPartName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper utility for looking up a single entry in a list of URI context mappings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pMappings</em>&nbsp;</td><td>The list to be searched.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszPartName</em>&nbsp;</td><td>The part name acting as the search key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a matching entry within the given list, or <code>NULL</code> if there is no matching entry. When a pointer is returned, it is always a direct pointer to an entry within the given list. It is not a pointer to a copy of the entry. If a fresh copy of the entry is required, the caller is responsible for creating it. The caller should not free the returned structure directly. The mappings list as a whole will be freed automatically when the XPS package is destroyed with <code><a class="el" href="xpsbuild_8c.html#a435ff8580afc32e6f63e19e77a3c3388" title="Release all memory associated with an XPS package that was previously built with...">freeXPSPackageInMemory()</a></code>. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
