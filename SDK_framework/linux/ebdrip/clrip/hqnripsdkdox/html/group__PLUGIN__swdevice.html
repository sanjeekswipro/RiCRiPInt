<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: DEVICE interface</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>DEVICE interface<br/>
<small>
[<a class="el" href="group__interface.html">Harlequin RIP core interface.</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__pdf__filespec.html">_pdf_filespec</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PDF_FILESPEC - a pointer to PDF_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> when the opcode is <code>DeviceIOCtl_PDFFilenameToPS</code>.  <a href="struct__pdf__filespec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__os__filespec.html">_os_filespec</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to OS_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> routine when opcode is DeviceIOCtl_OSDeviceName.  <a href="struct__os__filespec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure describing the parameter to set and its value.  <a href="structDEVICEPARAM.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFILEENTRY.html">FILEENTRY</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls to <a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> must pass a <a class="el" href="structFILEENTRY.html" title="Calls to DEVICELIST_NEXT() must pass a FILEENTRY structure which the routine will...">FILEENTRY</a> structure which the routine will fill in.  <a href="structFILEENTRY.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSTAT.html">STAT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls to <a class="el" href="group__PLUGIN__swdevice.html#ga763b61136b7308649b2fcc83edb2f9d0" title="Call to check status of file.">DEVICELIST_STATUS_FILE()</a> must pass a <code><a class="el" href="structSTAT.html" title="Calls to DEVICELIST_STATUS_FILE() must pass a STAT structure to the routine which...">STAT</a></code> structure to the routine which it will fill in.  <a href="structSTAT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdevicelist.html">devicelist</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PostScript sees devices though the list of <code>devicelist</code> structures. These are instances of device types. Do not try to change any fields in this structure.  <a href="structdevicelist.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeviceType.html">DeviceType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the structure used to represent a device in the Harlequin RIP.  <a href="structDeviceType.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaebdb3b0d2114d44724119ec9c0bb8173"></a><!-- doxytag: member="PLUGIN_swdevice::OS_DEVICE_TYPE" ref="gaebdb3b0d2114d44724119ec9c0bb8173" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaebdb3b0d2114d44724119ec9c0bb8173">OS_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a device type with this number is always required <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab4ef21b127c996748b86c01658457156"></a><!-- doxytag: member="PLUGIN_swdevice::NULL_DEVICE_TYPE" ref="gab4ef21b127c996748b86c01658457156" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gab4ef21b127c996748b86c01658457156">NULL_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is a built in device type like the UNIX device /dev/null <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac724f1e8693501854b81960edc9cab47"></a><!-- doxytag: member="PLUGIN_swdevice::ABS_DEVICE_TYPE" ref="gac724f1e8693501854b81960edc9cab47" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac724f1e8693501854b81960edc9cab47">ABS_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is a device type provided for device absolute devices which map to a particular file on the os device: for example state% =&gt; osstate <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad96480123ec35da948baae50ca2a3079"></a><!-- doxytag: member="PLUGIN_swdevice::SEMAPHORE_DEVICE_TYPE" ref="gad96480123ec35da948baae50ca2a3079" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad96480123ec35da948baae50ca2a3079">SEMAPHORE_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;12</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">this is a device type which must be provided for any parallel core RIP implementation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa5912cab02399f4bd9a20bc9ff409dc"></a><!-- doxytag: member="PLUGIN_swdevice::RELATIVE_DEVICE_TYPE" ref="gafa5912cab02399f4bd9a20bc9ff409dc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gafa5912cab02399f4bd9a20bc9ff409dc">RELATIVE_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;17</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This makes multiple absolute devices look like one relative device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadffdb645e4f0e7b7dbc7bf006626ebb0"></a><!-- doxytag: member="PLUGIN_swdevice::TRAP_DEVICE_TYPE" ref="gadffdb645e4f0e7b7dbc7bf006626ebb0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gadffdb645e4f0e7b7dbc7bf006626ebb0">TRAP_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;25</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">used by the core for sending trapping info <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f8da42c5a1b7c611ec896d2d1d6a059"></a><!-- doxytag: member="PLUGIN_swdevice::FONT_ND_CRYPT_DEVICE_TYPE" ref="ga3f8da42c5a1b7c611ec896d2d1d6a059" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga3f8da42c5a1b7c611ec896d2d1d6a059">FONT_ND_CRYPT_DEVICE_TYPE</a>&nbsp;&nbsp;&nbsp;128</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">used by the core to encrypt or decrypt OEM encrypted fonts <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67a4fd0280a19d06d90291481562f52f"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceNoError" ref="ga67a4fd0280a19d06d90291481562f52f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga67a4fd0280a19d06d90291481562f52f">DeviceNoError</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga973c49ccbe372a7209be1096e631103f"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceInvalidAccess" ref="ga973c49ccbe372a7209be1096e631103f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga973c49ccbe372a7209be1096e631103f">DeviceInvalidAccess</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63a6ff0396cbed1b0722c902c7f31fad"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceIOError" ref="ga63a6ff0396cbed1b0722c902c7f31fad" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga63a6ff0396cbed1b0722c902c7f31fad">DeviceIOError</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1778fec64798702ab3268a6d5a83b7f8"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceLimitCheck" ref="ga1778fec64798702ab3268a6d5a83b7f8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga1778fec64798702ab3268a6d5a83b7f8">DeviceLimitCheck</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf087f9a6029f1d17f50c6c9f7e11d9d6"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceUndefined" ref="gaf087f9a6029f1d17f50c6c9f7e11d9d6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaf087f9a6029f1d17f50c6c9f7e11d9d6">DeviceUndefined</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac331878d499a6de3fc6e41dd8ec22ab4"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceUnregistered" ref="gac331878d499a6de3fc6e41dd8ec22ab4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac331878d499a6de3fc6e41dd8ec22ab4">DeviceUnregistered</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcc160c73a9cad61d260495e11cddd25"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceInterrupted" ref="gadcc160c73a9cad61d260495e11cddd25" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gadcc160c73a9cad61d260495e11cddd25">DeviceInterrupted</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga557c1b5476290b3b15f72efa4976d3b3"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceVMError" ref="ga557c1b5476290b3b15f72efa4976d3b3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga557c1b5476290b3b15f72efa4976d3b3">DeviceVMError</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab747bfc5eb898239e8cc491972f10e32"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceReOutput" ref="gab747bfc5eb898239e8cc491972f10e32" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gab747bfc5eb898239e8cc491972f10e32">DeviceReOutput</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga094eef896ef25422ba01c91fc98fc95e"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceNotReady" ref="ga094eef896ef25422ba01c91fc98fc95e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga094eef896ef25422ba01c91fc98fc95e">DeviceNotReady</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82a7acedc2c2086fdbf1e7b4b0c2b7ea"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceCancelPage" ref="ga82a7acedc2c2086fdbf1e7b4b0c2b7ea" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga82a7acedc2c2086fdbf1e7b4b0c2b7ea">DeviceCancelPage</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52cf5b8a72f67ba0d998e26e2ced1e11"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceReOutputPageBuffer" ref="ga52cf5b8a72f67ba0d998e26e2ced1e11" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga52cf5b8a72f67ba0d998e26e2ced1e11">DeviceReOutputPageBuffer</a>&nbsp;&nbsp;&nbsp;11</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga505413a12b9165c56d66a89899692579"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceTimeout" ref="ga505413a12b9165c56d66a89899692579" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga505413a12b9165c56d66a89899692579">DeviceTimeout</a>&nbsp;&nbsp;&nbsp;12</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returned by <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c" title="Return last error for this device.">DEVICELIST_LAST_ERROR()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2798e303fe4f551c65fbe6e96fcba4bb"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceIOCtl_ShortRead" ref="ga2798e303fe4f551c65fbe6e96fcba4bb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga2798e303fe4f551c65fbe6e96fcba4bb">DeviceIOCtl_ShortRead</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opcode for <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a>. Arg is number of bytes to read. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga764d0e8056059ad648105c17e3f15dd8"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceIOCtl_PDFFilenameToPS" ref="ga764d0e8056059ad648105c17e3f15dd8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga764d0e8056059ad648105c17e3f15dd8">DeviceIOCtl_PDFFilenameToPS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opcode for <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a>. Arg is a pointer to a PDF_FILESPEC. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga881f660791a6736e7175b65b1b7f432a"></a><!-- doxytag: member="PLUGIN_swdevice::DeviceIOCtl_OSDeviceName" ref="ga881f660791a6736e7175b65b1b7f432a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga881f660791a6736e7175b65b1b7f432a">DeviceIOCtl_OSDeviceName</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opcode for <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a>. Arg is a pointer to an OS_FILESPEC. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga102163aea639ef4bd329b016103f2106"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_None" ref="ga102163aea639ef4bd329b016103f2106" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga102163aea639ef4bd329b016103f2106">PDF_FILESPEC_None</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unspecified <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41501c82e10ce1946e08524b0e859896"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_PDF" ref="ga41501c82e10ce1946e08524b0e859896" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga41501c82e10ce1946e08524b0e859896">PDF_FILESPEC_PDF</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PDF filename. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9a1b55b9188b4c5cfdb5c1c3cc1189e"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_DOS" ref="gac9a1b55b9188b4c5cfdb5c1c3cc1189e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac9a1b55b9188b4c5cfdb5c1c3cc1189e">PDF_FILESPEC_DOS</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dos based filename. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac16286728e7c989eba73cae598c16a8f"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_Mac" ref="gac16286728e7c989eba73cae598c16a8f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac16286728e7c989eba73cae598c16a8f">PDF_FILESPEC_Mac</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mac based filename. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada4b32c6acff42e9073969bb42976307"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_Unix" ref="gada4b32c6acff42e9073969bb42976307" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gada4b32c6acff42e9073969bb42976307">PDF_FILESPEC_Unix</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unix based filename. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga803d4cc0bcb8297e2c3d47a3115eb252"></a><!-- doxytag: member="PLUGIN_swdevice::PDF_FILESPEC_FS" ref="ga803d4cc0bcb8297e2c3d47a3115eb252" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga803d4cc0bcb8297e2c3d47a3115eb252">PDF_FILESPEC_FS</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">filesystem slot is defined <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga243afdd785dfd9f3d991bed47e27ae04">VOIDPTR_TO_DEVICE_FILEDESCRIPTOR</a>(d)&nbsp;&nbsp;&nbsp;((DEVICE_FILEDESCRIPTOR)((uintptr_t)(d) &gt;&gt; 1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gab755f483422e2aa0d1ad2008c8a43bd3">DEVICE_FILEDESCRIPTOR_TO_VOIDPTR</a>(d)&nbsp;&nbsp;&nbsp;((void *)((uintptr_t)(d) &lt;&lt; 1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80e92a5ec9d866631e0c9910aaa7881e"></a><!-- doxytag: member="PLUGIN_swdevice::ParamBoolean" ref="ga80e92a5ec9d866631e0c9910aaa7881e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga80e92a5ec9d866631e0c9910aaa7881e">ParamBoolean</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac16760e89c86b7bdde05299f5030ac60"></a><!-- doxytag: member="PLUGIN_swdevice::ParamInteger" ref="gac16760e89c86b7bdde05299f5030ac60" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac16760e89c86b7bdde05299f5030ac60">ParamInteger</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga453f94a06b29f14bca3d7b5927918748"></a><!-- doxytag: member="PLUGIN_swdevice::ParamString" ref="ga453f94a06b29f14bca3d7b5927918748" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga453f94a06b29f14bca3d7b5927918748">ParamString</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94c61629d88cd9b913cc1479d1395964"></a><!-- doxytag: member="PLUGIN_swdevice::ParamFloat" ref="ga94c61629d88cd9b913cc1479d1395964" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga94c61629d88cd9b913cc1479d1395964">ParamFloat</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaef9ebcab564801e2b18b7808e7f541e6"></a><!-- doxytag: member="PLUGIN_swdevice::ParamArray" ref="gaef9ebcab564801e2b18b7808e7f541e6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaef9ebcab564801e2b18b7808e7f541e6">ParamArray</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad19484aec227463989e8b1e81f9a8bdf"></a><!-- doxytag: member="PLUGIN_swdevice::ParamDict" ref="gad19484aec227463989e8b1e81f9a8bdf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad19484aec227463989e8b1e81f9a8bdf">ParamDict</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a8090efde8450a12c3a156039184653"></a><!-- doxytag: member="PLUGIN_swdevice::ParamNull" ref="ga4a8090efde8450a12c3a156039184653" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga4a8090efde8450a12c3a156039184653">ParamNull</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of parameter passed to the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga456636b151f2cbdc3304a8ae028bd2e7"></a><!-- doxytag: member="PLUGIN_swdevice::ParamAccepted" ref="ga456636b151f2cbdc3304a8ae028bd2e7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga456636b151f2cbdc3304a8ae028bd2e7">ParamAccepted</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5a96e7ee9ede74d878f7b23087800af"></a><!-- doxytag: member="PLUGIN_swdevice::ParamTypeCheck" ref="gad5a96e7ee9ede74d878f7b23087800af" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad5a96e7ee9ede74d878f7b23087800af">ParamTypeCheck</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7460dcb73ccfcb692e88e8699ceb41f3"></a><!-- doxytag: member="PLUGIN_swdevice::ParamRangeCheck" ref="ga7460dcb73ccfcb692e88e8699ceb41f3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga7460dcb73ccfcb692e88e8699ceb41f3">ParamRangeCheck</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd713767b4cb5a636ba884b5abf9ec27"></a><!-- doxytag: member="PLUGIN_swdevice::ParamConfigError" ref="gadd713767b4cb5a636ba884b5abf9ec27" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gadd713767b4cb5a636ba884b5abf9ec27">ParamConfigError</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga681336b734b1aa7de61d3cd09efd99bb"></a><!-- doxytag: member="PLUGIN_swdevice::ParamIgnored" ref="ga681336b734b1aa7de61d3cd09efd99bb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga681336b734b1aa7de61d3cd09efd99bb">ParamIgnored</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b9efc890af14352ed0e274a57e1b8b5"></a><!-- doxytag: member="PLUGIN_swdevice::ParamError" ref="ga0b9efc890af14352ed0e274a57e1b8b5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga0b9efc890af14352ed0e274a57e1b8b5">ParamError</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return code from <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a>. Set if last_error should be checked <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga556fe25d151773616bcdca65a2904890"></a><!-- doxytag: member="PLUGIN_swdevice::SW_RDONLY" ref="ga556fe25d151773616bcdca65a2904890" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga556fe25d151773616bcdca65a2904890">SW_RDONLY</a>&nbsp;&nbsp;&nbsp;0x001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open for reading only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf365379e8acd8793d9ac4b840e40d22b"></a><!-- doxytag: member="PLUGIN_swdevice::SW_WRONLY" ref="gaf365379e8acd8793d9ac4b840e40d22b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaf365379e8acd8793d9ac4b840e40d22b">SW_WRONLY</a>&nbsp;&nbsp;&nbsp;0x002</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open for writing only. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga016072bb32827c93c091caef107e5557"></a><!-- doxytag: member="PLUGIN_swdevice::SW_RDWR" ref="ga016072bb32827c93c091caef107e5557" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga016072bb32827c93c091caef107e5557">SW_RDWR</a>&nbsp;&nbsp;&nbsp;0x004</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open for reading or writing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85ce456fbf6974bde67bedbb11881a44"></a><!-- doxytag: member="PLUGIN_swdevice::SW_APPEND" ref="ga85ce456fbf6974bde67bedbb11881a44" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga85ce456fbf6974bde67bedbb11881a44">SW_APPEND</a>&nbsp;&nbsp;&nbsp;0x008</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open (write guaranteed at end). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacaa347f19f300be718929377bbc73c19"></a><!-- doxytag: member="PLUGIN_swdevice::SW_CREAT" ref="gacaa347f19f300be718929377bbc73c19" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gacaa347f19f300be718929377bbc73c19">SW_CREAT</a>&nbsp;&nbsp;&nbsp;0x010</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open with file create. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05e6552ce686169e8732dbe54c390860"></a><!-- doxytag: member="PLUGIN_swdevice::SW_TRUNC" ref="ga05e6552ce686169e8732dbe54c390860" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga05e6552ce686169e8732dbe54c390860">SW_TRUNC</a>&nbsp;&nbsp;&nbsp;0x020</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open with truncation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8338401b162a81d9b22b00be21a7c76"></a><!-- doxytag: member="PLUGIN_swdevice::SW_EXCL" ref="gab8338401b162a81d9b22b00be21a7c76" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gab8338401b162a81d9b22b00be21a7c76">SW_EXCL</a>&nbsp;&nbsp;&nbsp;0x040</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open with exclusive access. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91d63be7a90c5e3d52545e9b14d922d9"></a><!-- doxytag: member="PLUGIN_swdevice::SW_FROMPS" ref="ga91d63be7a90c5e3d52545e9b14d922d9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga91d63be7a90c5e3d52545e9b14d922d9">SW_FROMPS</a>&nbsp;&nbsp;&nbsp;0x080</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Open by the PostScript "file" operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd01fc5e1c1cc9992971f5d1ceffaae2"></a><!-- doxytag: member="PLUGIN_swdevice::SW_FONT" ref="gabd01fc5e1c1cc9992971f5d1ceffaae2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gabd01fc5e1c1cc9992971f5d1ceffaae2">SW_FONT</a>&nbsp;&nbsp;&nbsp;0x100</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> flag. Possibly try to open font resource if any. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89ff323277a4be064bedff8eff536d9d"></a><!-- doxytag: member="PLUGIN_swdevice::SW_SET" ref="ga89ff323277a4be064bedff8eff536d9d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga89ff323277a4be064bedff8eff536d9d">SW_SET</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f" title="Call to seek file on device.">DEVICELIST_SEEK()</a> flag. Absolute offset. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ebf15ba156ae7adcfc6258c772d257b"></a><!-- doxytag: member="PLUGIN_swdevice::SW_INCR" ref="ga6ebf15ba156ae7adcfc6258c772d257b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga6ebf15ba156ae7adcfc6258c772d257b">SW_INCR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f" title="Call to seek file on device.">DEVICELIST_SEEK()</a> flag. Relative to current offset. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0602aa1556734c9b80155a74dd9611e8"></a><!-- doxytag: member="PLUGIN_swdevice::SW_XTND" ref="ga0602aa1556734c9b80155a74dd9611e8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga0602aa1556734c9b80155a74dd9611e8">SW_XTND</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f" title="Call to seek file on device.">DEVICELIST_SEEK()</a> flag. Relative to end of file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1730ecbfeef1655fb204c5a0fed2bdc"></a><!-- doxytag: member="PLUGIN_swdevice::SW_BYTES_AVAIL_REL" ref="gad1730ecbfeef1655fb204c5a0fed2bdc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad1730ecbfeef1655fb204c5a0fed2bdc">SW_BYTES_AVAIL_REL</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440" title="Call to get bytes available for open file.">DEVICELIST_BYTES()</a> reason code. Immediately available after current pos. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2022f0cc84830eadb46b46d8379a9b29"></a><!-- doxytag: member="PLUGIN_swdevice::SW_BYTES_TOTAL_ABS" ref="ga2022f0cc84830eadb46b46d8379a9b29" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga2022f0cc84830eadb46b46d8379a9b29">SW_BYTES_TOTAL_ABS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440" title="Call to get bytes available for open file.">DEVICELIST_BYTES()</a> reason code. Total extent of file in bytes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaefbaed6509dadbb40fca9b8134341b68"></a><!-- doxytag: member="PLUGIN_swdevice::FileNameNoMatch" ref="gaefbaed6509dadbb40fca9b8134341b68" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaefbaed6509dadbb40fca9b8134341b68">FileNameNoMatch</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> return code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea8cf3a92eb8734cdfc13869e3d70fb4"></a><!-- doxytag: member="PLUGIN_swdevice::FileNameMatch" ref="gaea8cf3a92eb8734cdfc13869e3d70fb4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaea8cf3a92eb8734cdfc13869e3d70fb4">FileNameMatch</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> return code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1407110de3e3067a79f683aff257cc7"></a><!-- doxytag: member="PLUGIN_swdevice::FileNameError" ref="gaa1407110de3e3067a79f683aff257cc7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaa1407110de3e3067a79f683aff257cc7">FileNameError</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> return code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaefb01d2217e3e71206361f772fac155a"></a><!-- doxytag: member="PLUGIN_swdevice::FileNameIOError" ref="gaefb01d2217e3e71206361f772fac155a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaefb01d2217e3e71206361f772fac155a">FileNameIOError</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> return code. Synonymous with <code>FileNameError</code>, for upward compatibility. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga886e7a862ee8753a50c331bce0bf869a"></a><!-- doxytag: member="PLUGIN_swdevice::FileNameRangeCheck" ref="ga886e7a862ee8753a50c331bce0bf869a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga886e7a862ee8753a50c331bce0bf869a">FileNameRangeCheck</a>&nbsp;&nbsp;&nbsp;(-2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> return code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga337b9f99d8c83fc6c5815f9513f86216"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICEABSOLUTE" ref="ga337b9f99d8c83fc6c5815f9513f86216" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga337b9f99d8c83fc6c5815f9513f86216">DEVICEABSOLUTE</a>&nbsp;&nbsp;&nbsp;0x0000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Flag "set" if device must not take file name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed9e39fa505dac5d7bed1173e5c44fd1"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICERELATIVE" ref="gaed9e39fa505dac5d7bed1173e5c44fd1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaed9e39fa505dac5d7bed1173e5c44fd1">DEVICERELATIVE</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Flag set if device must take file name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0dab18694e03d6af0a90f05bc91e5695"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICEWRITABLE" ref="ga0dab18694e03d6af0a90f05bc91e5695" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga0dab18694e03d6af0a90f05bc91e5695">DEVICEWRITABLE</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Set if device can be written to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2163436597072880f8ed719a2abc8f4"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICESMALLBUFF" ref="gab2163436597072880f8ed719a2abc8f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gab2163436597072880f8ed719a2abc8f4">DEVICESMALLBUFF</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. A smaller buffer is used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae566f488b64d00e5e34ca07c69aa971"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICELINEBUFF" ref="gaae566f488b64d00e5e34ca07c69aa971" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaae566f488b64d00e5e34ca07c69aa971">DEVICELINEBUFF</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Files of dev type will be line buffered. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2e684e311db40b99706bd226520eb65"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICEENABLED" ref="gae2e684e311db40b99706bd226520eb65" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gae2e684e311db40b99706bd226520eb65">DEVICEENABLED</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Flag set if device in search path. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73ba437f841160fcd0f20cfaa81c886e"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICEREMOVABLE" ref="ga73ba437f841160fcd0f20cfaa81c886e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga73ba437f841160fcd0f20cfaa81c886e">DEVICEREMOVABLE</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Set if media can be removed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb664563e087d9c742e116f14d2e1aec"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICENOSEARCH" ref="gacb664563e087d9c742e116f14d2e1aec" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gacb664563e087d9c742e116f14d2e1aec">DEVICENOSEARCH</a>&nbsp;&nbsp;&nbsp;0x0040</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Set if a general filenameforall omits the device (SearchOrder set to -1). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9944ae6a8caa94f20bc187086ea008f"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICEUNDISMOUNTABLE" ref="gaf9944ae6a8caa94f20bc187086ea008f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaf9944ae6a8caa94f20bc187086ea008f">DEVICEUNDISMOUNTABLE</a>&nbsp;&nbsp;&nbsp;0x0080</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device Type Flag. Set if device can't be dismounted. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga423fd00c9450161cdb06fe4afa903baa">SW_DEVICE_NAME_PROGRESS</a>&nbsp;&nbsp;&nbsp;&quot;progress&quot;</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__pdf__filespec.html">_pdf_filespec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad53c9734c44621529e4a4e1e322f5cb6">PDF_FILESPEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PDF_FILESPEC - a pointer to PDF_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> when the opcode is <code>DeviceIOCtl_PDFFilenameToPS</code>.  <a href="#gad53c9734c44621529e4a4e1e322f5cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__os__filespec.html">_os_filespec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga4412f957d569f7d721c334d3152fcf08">OS_FILESPEC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to OS_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> routine when opcode is DeviceIOCtl_OSDeviceName.  <a href="#ga4412f957d569f7d721c334d3152fcf08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32d7afe2296feed91e2d506feb55048b"></a><!-- doxytag: member="PLUGIN_swdevice::DEVICELIST" ref="ga32d7afe2296feed91e2d506feb55048b" args="" -->
typedef struct <a class="el" href="structdevicelist.html">devicelist</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga32d7afe2296feed91e2d506feb55048b">DEVICELIST</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PostScript sees devices though the list of <code>devicelist</code> structures. These are instances of device types. Do not try to change any fields in this structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga907785fa949ff5de052c03b9cc2c99d9">DEVICELIST_TICKLE</a> (struct <a class="el" href="structDeviceType.html">DeviceType</a> *dev, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> recursion)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Procedure for periodic service calls to the device.  <a href="#ga907785fa949ff5de052c03b9cc2c99d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c">DEVICELIST_LAST_ERROR</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return last error for this device.  <a href="#gad4dfeaff60559e2b3936806173feb86c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga6d5a100a189ff87d55e753a5c30d6ffc">DEVICELIST_INIT</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to initialise a device.  <a href="#ga6d5a100a189ff87d55e753a5c30d6ffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DEVICE_FILEDESCRIPTOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be">DEVICELIST_OPEN</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to open a file on device.  <a href="#ga85bb263ac9a1de667c57df529d9b09be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga1773113a2fdf552abfbf7f77479ef837">DEVICELIST_READ</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to read data from file on device.  <a href="#ga1773113a2fdf552abfbf7f77479ef837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaf9d8d01fc7f291720ee20a0424898198">DEVICELIST_WRITE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to write data to file on device.  <a href="#gaf9d8d01fc7f291720ee20a0424898198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga3c3c68995e66050fb42a9caa282aebc2">DEVICELIST_CLOSE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to close file on device.  <a href="#ga3c3c68995e66050fb42a9caa282aebc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gac59253945a1e4ec7018616852a4d43b9">DEVICELIST_ABORT</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to abort action on the device.  <a href="#gac59253945a1e4ec7018616852a4d43b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f">DEVICELIST_SEEK</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destn, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to seek file on device.  <a href="#ga2db8731fa4ca396fe986dff5ae7a935f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440">DEVICELIST_BYTES</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get bytes available for open file.  <a href="#ga4df4f08a5fd848197b67906bfe377440"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga763b61136b7308649b2fcc83edb2f9d0">DEVICELIST_STATUS_FILE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to check status of file.  <a href="#ga763b61136b7308649b2fcc83edb2f9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga68226e680ebb5b7639848f682c0b2a9d">DEVICELIST_START_LIST</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to start listing files.  <a href="#ga68226e680ebb5b7639848f682c0b2a9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7">DEVICELIST_NEXT</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void **handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="structFILEENTRY.html">FILEENTRY</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get next file in list.  <a href="#ga7b51f4d7da3ac7b278a0e55180e6e8e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaa3b7ed2931a39bbdf4fb73cfcaeb3da3">DEVICELIST_END_LIST</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to end listing.  <a href="#gaa3b7ed2931a39bbdf4fb73cfcaeb3da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga7c109d56a1e761215b1a6bdcdeba80de">DEVICELIST_RENAME</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file1, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename file on the device.  <a href="#ga7c109d56a1e761215b1a6bdcdeba80de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad1ca81dc9ecd629b09e4ac0fcabc2dd6">DEVICELIST_DELETE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove file from device.  <a href="#gad1ca81dc9ecd629b09e4ac0fcabc2dd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282">DEVICELIST_SET_PARAM</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to set a device parameter.  <a href="#gae619932b474a7fdead14405dc9ae4282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga7c655506f815c9f606fa361a97a89e12">DEVICELIST_START_PARAM</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to start getting device parameters.  <a href="#ga7c655506f815c9f606fa361a97a89e12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga28179fe012380bfc5b2bee0962865d06">DEVICELIST_GET_PARAM</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get the next device parameter.  <a href="#ga28179fe012380bfc5b2bee0962865d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga5717f71a4260330832b331b644e9dd05">DEVICELIST_STATUS_DEVICE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVSTAT *devstat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get the status of the device.  <a href="#ga5717f71a4260330832b331b644e9dd05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gada3f3556d37ca15183911afc928c1831">DEVICELIST_DISMOUNT</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to dismount the device.  <a href="#gada3f3556d37ca15183911afc928c1831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga0c5da82f8cac53a9a5f4d4e6197124a5">DEVICELIST_BUFFER_SIZE</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional call to return the buffer size that a device requires for best operation.  <a href="#ga0c5da82f8cac53a9a5f4d4e6197124a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513">DEVICELIST_IOCTL</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR fileDescriptor, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> opcode, intptr_t arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Miscellaneous control options.  <a href="#gad816a8beda346681b5ca06b6d9fe0513"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structDeviceType.html">DeviceType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga0490b739183a7c6d8fb11b8f4499b18f">DEVICETYPE</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the structure used to represent a device in the Harlequin RIP.  <a href="#ga0490b739183a7c6d8fb11b8f4499b18f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80a2ccf547abf59b80860bcc1efcfd57"></a><!-- doxytag: member="PLUGIN_swdevice::SwFindDevice" ref="ga80a2ccf547abf59b80860bcc1efcfd57" args="(uint8 *deviceName)" -->
<a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga80a2ccf547abf59b80860bcc1efcfd57">SwFindDevice</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *deviceName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SwFindDevice looks up a device by name, returns NULL on failure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga42ddf7256a20ad8b28c35cc1b66d87af">SwAlloc</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically allocate memory from the core rip's memory space.  <a href="#ga42ddf7256a20ad8b28c35cc1b66d87af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gadb9a2959b701907f33f22ab7d9e723e0">SwRealloc</a> (void *pointer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically allocate memory from the core rip's memory space.  <a href="#gadb9a2959b701907f33f22ab7d9e723e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga71af0a192224c94b0c58bd057efac847">SwFree</a> (void *pointer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically allocate memory from the core rip's memory space.  <a href="#ga71af0a192224c94b0c58bd057efac847"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3934fb3c7800cce0d690a38195cafd47"></a><!-- doxytag: member="PLUGIN_swdevice::SwPatternMatch" ref="ga3934fb3c7800cce0d690a38195cafd47" args="(uint8 *pattern, uint8 *string)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga3934fb3c7800cce0d690a38195cafd47">SwPatternMatch</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *string)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use in <a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> to assist pattern matching on file names. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad52d2b760eab20e4f17c5bedd0ac2e71"></a><!-- doxytag: member="PLUGIN_swdevice::SwLengthPatternMatch" ref="gad52d2b760eab20e4f17c5bedd0ac2e71" args="(uint8 *pattern, int32 plen, uint8 *string, int32 slen)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gad52d2b760eab20e4f17c5bedd0ac2e71">SwLengthPatternMatch</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plen, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *string, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> slen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use in <a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7" title="Call to get next file in list.">DEVICELIST_NEXT()</a> to assist pattern matching on file names. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82a03bc69304b1353039e5334f2f1e9c"></a><!-- doxytag: member="PLUGIN_swdevice::SwReadFilterBytes" ref="ga82a03bc69304b1353039e5334f2f1e9c" args="(DEVICELIST *dev, uint8 **ret_buff)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga82a03bc69304b1353039e5334f2f1e9c">SwReadFilterBytes</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ret_buff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use when adding custom filters via the device interface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafedefb4953288c0caf995b1ac8ce2987"></a><!-- doxytag: member="PLUGIN_swdevice::SwReplaceFilterBytes" ref="gafedefb4953288c0caf995b1ac8ce2987" args="(DEVICELIST *dev, int32 len)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gafedefb4953288c0caf995b1ac8ce2987">SwReplaceFilterBytes</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use when adding custom filters via the device interface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2dfb8641b2d5935f101f3c4bc34378bf"></a><!-- doxytag: member="PLUGIN_swdevice::SwWriteFilterBytes" ref="ga2dfb8641b2d5935f101f3c4bc34378bf" args="(DEVICELIST *dev, uint8 *buff, int32 len)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga2dfb8641b2d5935f101f3c4bc34378bf">SwWriteFilterBytes</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use when adding custom filters via the device interface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a388b7fbf8fa6d88dd3a287137d46f1"></a><!-- doxytag: member="PLUGIN_swdevice::SwSeekFilterBytes" ref="ga7a388b7fbf8fa6d88dd3a287137d46f1" args="(DEVICELIST *dev, int32 offset)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#ga7a388b7fbf8fa6d88dd3a287137d46f1">SwSeekFilterBytes</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use when adding custom filters via the device interface. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1f44a3b855d998fd4bf628a95184db3"></a><!-- doxytag: member="PLUGIN_swdevice::SwTestAndTickle" ref="gaf1f44a3b855d998fd4bf628a95184db3" args="(void)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PLUGIN__swdevice.html#gaf1f44a3b855d998fd4bf628a95184db3">SwTestAndTickle</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use when adding custom filters via the device interface. <br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gab755f483422e2aa0d1ad2008c8a43bd3"></a><!-- doxytag: member="swdevice.h::DEVICE_FILEDESCRIPTOR_TO_VOIDPTR" ref="gab755f483422e2aa0d1ad2008c8a43bd3" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEVICE_FILEDESCRIPTOR_TO_VOIDPTR</td>
          <td>(</td>
          <td class="paramtype">d&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((void *)((uintptr_t)(d) &lt;&lt; 1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a device file descriptor which was converted from a (void*) via the macro VOIDPTR_TO_DEVICE_FILEDESCRIPTOR back to its original value. </p>

</div>
</div>
<a class="anchor" id="ga423fd00c9450161cdb06fe4afa903baa"></a><!-- doxytag: member="swdevice.h::SW_DEVICE_NAME_PROGRESS" ref="ga423fd00c9450161cdb06fe4afa903baa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SW_DEVICE_NAME_PROGRESS&nbsp;&nbsp;&nbsp;&quot;progress&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A "well known" device name that can be passed to SwFindDevice. </p>

</div>
</div>
<a class="anchor" id="ga243afdd785dfd9f3d991bed47e27ae04"></a><!-- doxytag: member="swdevice.h::VOIDPTR_TO_DEVICE_FILEDESCRIPTOR" ref="ga243afdd785dfd9f3d991bed47e27ae04" args="(d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VOIDPTR_TO_DEVICE_FILEDESCRIPTOR</td>
          <td>(</td>
          <td class="paramtype">d&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((DEVICE_FILEDESCRIPTOR)((uintptr_t)(d) &gt;&gt; 1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a (void*) to a device file descriptor. Allocated data structures are assumed to be 4 byte aligned. Right shift is to ensure that the device file descriptor is not a negative value which is an invalid device file descriptor. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac59253945a1e4ec7018616852a4d43b9"></a><!-- doxytag: member="swdevice.h::DEVICELIST_ABORT" ref="gac59253945a1e4ec7018616852a4d43b9" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gac59253945a1e4ec7018616852a4d43b9">DEVICELIST_ABORT</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to abort action on the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c5da82f8cac53a9a5f4d4e6197124a5"></a><!-- doxytag: member="swdevice.h::DEVICELIST_BUFFER_SIZE" ref="ga0c5da82f8cac53a9a5f4d4e6197124a5" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga0c5da82f8cac53a9a5f4d4e6197124a5">DEVICELIST_BUFFER_SIZE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optional call to return the buffer size that a device requires for best operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer size requested in bytes. If this is less than zero, then the <code>DEVICESMALLBUFF</code> flag is examined to determine the size of the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4df4f08a5fd848197b67906bfe377440"></a><!-- doxytag: member="swdevice.h::DEVICELIST_BYTES" ref="ga4df4f08a5fd848197b67906bfe377440" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *bytes, int32 reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga4df4f08a5fd848197b67906bfe377440">DEVICELIST_BYTES</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to get bytes available for open file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>The number of bytes available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>One of <code>SW_BYTES_AVAIL_REL</code>, <code>SW_BYTES_AVAIL_ABS</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if there are bytes available (in which case return 0 in bytes if the number is not known), FALSE for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c3c68995e66050fb42a9caa282aebc2"></a><!-- doxytag: member="swdevice.h::DEVICELIST_CLOSE" ref="ga3c3c68995e66050fb42a9caa282aebc2" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga3c3c68995e66050fb42a9caa282aebc2">DEVICELIST_CLOSE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to close file on device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1ca81dc9ecd629b09e4ac0fcabc2dd6"></a><!-- doxytag: member="swdevice.h::DEVICELIST_DELETE" ref="gad1ca81dc9ecd629b09e4ac0fcabc2dd6" args="(DEVICELIST *dev, uint8 *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gad1ca81dc9ecd629b09e4ac0fcabc2dd6">DEVICELIST_DELETE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove file from device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of a file to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gada3f3556d37ca15183911afc928c1831"></a><!-- doxytag: member="swdevice.h::DEVICELIST_DISMOUNT" ref="gada3f3556d37ca15183911afc928c1831" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gada3f3556d37ca15183911afc928c1831">DEVICELIST_DISMOUNT</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to dismount the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. This should normally return 0, even if most device operations are not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3b7ed2931a39bbdf4fb73cfcaeb3da3"></a><!-- doxytag: member="swdevice.h::DEVICELIST_END_LIST" ref="gaa3b7ed2931a39bbdf4fb73cfcaeb3da3" args="(DEVICELIST *dev, void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gaa3b7ed2931a39bbdf4fb73cfcaeb3da3">DEVICELIST_END_LIST</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void *handle)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to end listing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A file list iterator pointer returned by the <code>DEVICELIST_START_LIST</code> routine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28179fe012380bfc5b2bee0962865d06"></a><!-- doxytag: member="swdevice.h::DEVICELIST_GET_PARAM" ref="ga28179fe012380bfc5b2bee0962865d06" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga28179fe012380bfc5b2bee0962865d06">DEVICELIST_GET_PARAM</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to get the next device parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>A structure in which to store the parameter value. If the <code>paramname</code> field is NULL, then store the next parameter in an iteration, otherwise store the value of the requested parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the values: <code>ParamIgnored</code>, <code>ParamAccepted</code>, <code>ParamError</code> (or -1). </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d5a100a189ff87d55e753a5c30d6ffc"></a><!-- doxytag: member="swdevice.h::DEVICELIST_INIT" ref="ga6d5a100a189ff87d55e753a5c30d6ffc" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga6d5a100a189ff87d55e753a5c30d6ffc">DEVICELIST_INIT</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to initialise a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gad816a8beda346681b5ca06b6d9fe0513"></a><!-- doxytag: member="swdevice.h::DEVICELIST_IOCTL" ref="gad816a8beda346681b5ca06b6d9fe0513" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR fileDescriptor, int32 opcode, intptr_t arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513">DEVICELIST_IOCTL</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR fileDescriptor, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> opcode, intptr_t arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Miscellaneous control options. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileDescriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opcode</em>&nbsp;</td><td>A device-specific value, or one of the generic values: <code>DeviceIOCtl_ShortRead</code> This indicates that the next file read should not be optimised for sequential access. <code>DeviceIOCtl_PDFFilenameToPS</code> The data value <code>arg</code> should be cast to a <code>PDF_FILESPEC</code>. The filename in this structure should be converted from a platform specific form to a generic form. <code>DeviceIOCtl_OSDeviceName</code> The data value <code>arg</code> should be cast to an <code>OS_FILESPEC</code>. The filename in this structure should be converted from a platform specific form to a suitable form for to <code>os%</code> device. <code>DeviceIOCtl_RasterRequirements</code> The data value <code>arg</code> should be cast to a <code>RASTER_REQUIREMENTS</code> pointer. <code>DeviceIOCtl_RenderingStart</code> The data value <code>arg</code> should be cast to a <code>RASTER_REQUIREMENTS</code> pointer. <code>DeviceIOCtl_GetBufferForRaster</code> The data value <code>arg</code> should be cast to a <code>RASTER_DESTINATION</code> pointer. <code>DeviceIOCtl_RasterStride</code> The data value <code>arg</code> should be cast to a pointer to a uint32. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>A data parameter for the control function. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>for success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>for failure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-2</em>&nbsp;</td><td>if the opcode is not implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4dfeaff60559e2b3936806173feb86c"></a><!-- doxytag: member="swdevice.h::DEVICELIST_LAST_ERROR" ref="gad4dfeaff60559e2b3936806173feb86c" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gad4dfeaff60559e2b3936806173feb86c">DEVICELIST_LAST_ERROR</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return last error for this device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the values: <code>DeviceNoError</code>, <code>DeviceInvalidAccess</code>, <code>DeviceIOError</code>, <code>DeviceLimitCheck</code>, <code>DeviceUndefined</code>, <code>DeviceUnregistered</code>, <code>DeviceInterrupted</code>. The <code>pagebuffer%</code> device may also return one of: <code>DeviceVMError</code>, <code>DeviceReOutput</code>, <code>DeviceNotReady</code>, <code>DeviceCancelPage</code>, <code>DeviceReOutputPageBuffer</code>, </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b51f4d7da3ac7b278a0e55180e6e8e7"></a><!-- doxytag: member="swdevice.h::DEVICELIST_NEXT" ref="ga7b51f4d7da3ac7b278a0e55180e6e8e7" args="(DEVICELIST *dev, void **handle, uint8 *pattern, FILEENTRY *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga7b51f4d7da3ac7b278a0e55180e6e8e7">DEVICELIST_NEXT</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void **handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="structFILEENTRY.html">FILEENTRY</a> *entry)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to get next file in list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A file list iterator pointer returned by the <code>DEVICELIST_START_LIST</code> routine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>The pattern passed to the <code>DEVICELIST_START_LIST</code> routine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>A structure in which to store the next matching filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the values: <code>FileNameMatch</code>, <code>FileNameRangeCheck</code>, <code>FileNameNoMatch</code>, <code>FileNameError</code> (or -1). </dd></dl>

</div>
</div>
<a class="anchor" id="ga85bb263ac9a1de667c57df529d9b09be"></a><!-- doxytag: member="swdevice.h::DEVICELIST_OPEN" ref="ga85bb263ac9a1de667c57df529d9b09be" args="(DEVICELIST *dev, uint8 *filename, int32 openflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DEVICE_FILEDESCRIPTOR <a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be">DEVICELIST_OPEN</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to open a file on device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The file name to open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One of the following: <code>SW_RDONLY</code>, <code>SW_WRONLY</code>, <code>SW_RDWR</code>, <code>SW_APPEND</code>, <code>SW_CREAT</code>, <code>SW_TRUNC</code>, <code>SW_EXCL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A non-negative file descriptor if successful, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1773113a2fdf552abfbf7f77479ef837"></a><!-- doxytag: member="swdevice.h::DEVICELIST_READ" ref="ga1773113a2fdf552abfbf7f77479ef837" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga1773113a2fdf552abfbf7f77479ef837">DEVICELIST_READ</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to read data from file on device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>Buffer into which the data read is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes of data read on success, 0 if the file is at EOF, or -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c109d56a1e761215b1a6bdcdeba80de"></a><!-- doxytag: member="swdevice.h::DEVICELIST_RENAME" ref="ga7c109d56a1e761215b1a6bdcdeba80de" args="(DEVICELIST *dev, uint8 *file1, uint8 *file2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga7c109d56a1e761215b1a6bdcdeba80de">DEVICELIST_RENAME</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file1, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename file on the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file1</em>&nbsp;</td><td>The name of a file to rename. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file2</em>&nbsp;</td><td>The to which <code>file1</code> will be renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2db8731fa4ca396fe986dff5ae7a935f"></a><!-- doxytag: member="swdevice.h::DEVICELIST_SEEK" ref="ga2db8731fa4ca396fe986dff5ae7a935f" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *destn, int32 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f">DEVICELIST_SEEK</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destn, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to seek file on device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destn</em>&nbsp;</td><td>The location to seek to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One of <code>SW_SET</code>, <code>SW_INCR</code>, <code>SW_XTND</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE for success, FALSE for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gae619932b474a7fdead14405dc9ae4282"></a><!-- doxytag: member="swdevice.h::DEVICELIST_SET_PARAM" ref="gae619932b474a7fdead14405dc9ae4282" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282">DEVICELIST_SET_PARAM</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to set a device parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>A structure describing the parameter to set and its value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the values: <code>ParamAccepted</code>, <code>ParamTypeCheck</code>, <code>ParamRangeCheck</code>, <code>ParamConfigError</code>, <code>ParamIgnored</code>, <code>ParamError</code> (or -1).</dd></dl>
<p>Parameters provided by the setdevparams operator are passed to the device via <a class="el" href="group__PLUGIN__swdevice.html#gae619932b474a7fdead14405dc9ae4282" title="Call to set a device parameter.">DEVICELIST_SET_PARAM()</a> to interpret using the following types and constants: <code>ParamBoolean</code>, <code>ParamInteger</code>, <code>ParamString</code>, <code>ParamFloat</code>, <code>ParamArray</code>, <code>ParamDict</code>, <code>ParamNull</code>.</p>
<p>Note that composite PostScript values are not allowed as parameters. </p>

</div>
</div>
<a class="anchor" id="ga68226e680ebb5b7639848f682c0b2a9d"></a><!-- doxytag: member="swdevice.h::DEVICELIST_START_LIST" ref="ga68226e680ebb5b7639848f682c0b2a9d" args="(DEVICELIST *dev, uint8 *pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__PLUGIN__swdevice.html#ga68226e680ebb5b7639848f682c0b2a9d">DEVICELIST_START_LIST</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to start listing files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>A file pattern to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to an iterator structure if successful, NULL for failure. If it is known that no files match the pattern, then NULL may be returned, and an immediate call to the <code>DEVICELIST_LAST_ERROR</code> routine should return <code>DeviceNoError</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c655506f815c9f606fa361a97a89e12"></a><!-- doxytag: member="swdevice.h::DEVICELIST_START_PARAM" ref="ga7c655506f815c9f606fa361a97a89e12" args="(DEVICELIST *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga7c655506f815c9f606fa361a97a89e12">DEVICELIST_START_PARAM</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to start getting device parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of device parameters to enumerate (this may be 0 if there are no device parameters), or -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5717f71a4260330832b331b644e9dd05"></a><!-- doxytag: member="swdevice.h::DEVICELIST_STATUS_DEVICE" ref="ga5717f71a4260330832b331b644e9dd05" args="(DEVICELIST *dev, DEVSTAT *devstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga5717f71a4260330832b331b644e9dd05">DEVICELIST_STATUS_DEVICE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVSTAT *devstat)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to get the status of the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>devstat</em>&nbsp;</td><td>A structure in which to return the status of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga763b61136b7308649b2fcc83edb2f9d0"></a><!-- doxytag: member="swdevice.h::DEVICELIST_STATUS_FILE" ref="ga763b61136b7308649b2fcc83edb2f9d0" args="(DEVICELIST *dev, uint8 *filename, STAT *statbuff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga763b61136b7308649b2fcc83edb2f9d0">DEVICELIST_STATUS_FILE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to check status of file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The file to check status. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>statbuff</em>&nbsp;</td><td>Pointer to a structure in which to put the file status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga907785fa949ff5de052c03b9cc2c99d9"></a><!-- doxytag: member="swdevice.h::DEVICELIST_TICKLE" ref="ga907785fa949ff5de052c03b9cc2c99d9" args="(struct DeviceType *dev, int32 recursion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#ga907785fa949ff5de052c03b9cc2c99d9">DEVICELIST_TICKLE</a>(struct <a class="el" href="structDeviceType.html">DeviceType</a> *dev, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> recursion)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Procedure for periodic service calls to the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recursion</em>&nbsp;</td><td>Number of levels of call recursion for this tickle procedure. This will be 0 for calls from the Harlequin RIP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-4 indicates that progress information is generated for files being read. -3 causes the RIP to call any tickle functions that have timed out and are waiting to be called. -2 causes a PDL timeout error to be signalled. -1 causes an interrupt error to be signalled. 0 indicates no action need be taken. Positive values are looked up as keys in the dictionary <code>serviceinterrupt</code> (in <code>execdict</code>), and the value, a procedure, is executed. Entries may be defined by a startup file. Negative return values take priority over positive return values. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9d8d01fc7f291720ee20a0424898198"></a><!-- doxytag: member="swdevice.h::DEVICELIST_WRITE" ref="gaf9d8d01fc7f291720ee20a0424898198" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__PLUGIN__swdevice.html#gaf9d8d01fc7f291720ee20a0424898198">DEVICELIST_WRITE</a>(<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to write data to file on device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>The current device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>descriptor</em>&nbsp;</td><td>A descriptor returned by a previous open call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>Buffer from which the data written is taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes of data written on success, or -1 for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0490b739183a7c6d8fb11b8f4499b18f"></a><!-- doxytag: member="swdevice.h::DEVICETYPE" ref="ga0490b739183a7c6d8fb11b8f4499b18f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structDeviceType.html">DeviceType</a>  <a class="el" href="structDeviceType.html">DEVICETYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the structure used to represent a device in the Harlequin RIP. </p>
<p>A number of macros, eg <code>theIDevTypeNumber</code>, are for convenience in accessing the fields of the structures; OEM's: don't feel obliged to use them. You may want to call e.g. writes on a device in your own code, and the macros provide a notation for doing so. </p>

</div>
</div>
<a class="anchor" id="ga4412f957d569f7d721c334d3152fcf08"></a><!-- doxytag: member="swdevice.h::OS_FILESPEC" ref="ga4412f957d569f7d721c334d3152fcf08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__os__filespec.html">_os_filespec</a>  <a class="el" href="struct__os__filespec.html">OS_FILESPEC</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A pointer to OS_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> routine when opcode is DeviceIOCtl_OSDeviceName. </p>
<p>The filename specifies the name of a file for which an os% device filename is required.</p>
<p>On entry to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> the buffer member must contain a pointer to and the length of the buffer to be written to. If the call is successful buffer.len will contain the byte count of the contents written into the buffer. </p>

</div>
</div>
<a class="anchor" id="gad53c9734c44621529e4a4e1e322f5cb6"></a><!-- doxytag: member="swdevice.h::PDF_FILESPEC" ref="gad53c9734c44621529e4a4e1e322f5cb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__pdf__filespec.html">_pdf_filespec</a>  <a class="el" href="struct__pdf__filespec.html">PDF_FILESPEC</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PDF_FILESPEC - a pointer to PDF_FILESPEC will be passed as the arg to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> when the opcode is <code>DeviceIOCtl_PDFFilenameToPS</code>. </p>
<p>The constants PDF_FILESPEC_XXX specify information about the arguments passed through in the members filename and filesytem. All the other members must be specified.</p>
<p>On entry to <a class="el" href="group__PLUGIN__swdevice.html#gad816a8beda346681b5ca06b6d9fe0513" title="Miscellaneous control options.">DEVICELIST_IOCTL()</a> the buffer member must contain a pointer to and the length of the buffer to be written to. If the call is successful buffer.len will contain the byte count of the contents written into the buffer. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga42ddf7256a20ad8b28c35cc1b66d87af"></a><!-- doxytag: member="swdevice.h::SwAlloc" ref="ga42ddf7256a20ad8b28c35cc1b66d87af" args="(int32 bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a>* SwAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamically allocate memory from the core rip's memory space. </p>
<p>The three functions, <a class="el" href="group__PLUGIN__swdevice.html#ga42ddf7256a20ad8b28c35cc1b66d87af" title="Dynamically allocate memory from the core rip&#39;s memory space.">SwAlloc()</a>, <a class="el" href="group__PLUGIN__swdevice.html#gadb9a2959b701907f33f22ab7d9e723e0" title="Dynamically allocate memory from the core rip&#39;s memory space.">SwRealloc()</a>, and <a class="el" href="group__PLUGIN__swdevice.html#ga71af0a192224c94b0c58bd057efac847" title="Dynamically allocate memory from the core rip&#39;s memory space.">SwFree()</a>, allow external devices to dynamically allocate memory from the core rip's memory space. These functions can be safely called any time after SwStart, but large blocks should be freed as soon as possible to avoid interfering with jobs. </p>

</div>
</div>
<a class="anchor" id="ga71af0a192224c94b0c58bd057efac847"></a><!-- doxytag: member="swdevice.h::SwFree" ref="ga71af0a192224c94b0c58bd057efac847" args="(void *pointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwFree </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pointer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamically allocate memory from the core rip's memory space. </p>
<p>See <a class="el" href="group__PLUGIN__swdevice.html#ga42ddf7256a20ad8b28c35cc1b66d87af" title="Dynamically allocate memory from the core rip&#39;s memory space.">SwAlloc()</a>. </p>

</div>
</div>
<a class="anchor" id="gadb9a2959b701907f33f22ab7d9e723e0"></a><!-- doxytag: member="swdevice.h::SwRealloc" ref="gadb9a2959b701907f33f22ab7d9e723e0" args="(void *pointer, int32 bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a>* SwRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamically allocate memory from the core rip's memory space. </p>
<p>See <a class="el" href="group__PLUGIN__swdevice.html#ga42ddf7256a20ad8b28c35cc1b66d87af" title="Dynamically allocate memory from the core rip&#39;s memory space.">SwAlloc()</a>. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
