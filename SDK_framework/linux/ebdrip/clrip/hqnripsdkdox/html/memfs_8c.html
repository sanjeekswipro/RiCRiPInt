<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: memfs.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>memfs.c File Reference</h1>
<p>Implementation of an input/output device tied to in-memory data.  
<a href="#_details">More...</a></p>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="file_8h.html">file.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqstr_8h.html">hqstr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="memfs_8h.html">memfs.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swdevice_8h.html">swdevice.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="zlibutil_8h.html">zlibutil.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d51567e0f6916e91f5bd3719d56cce6"></a><!-- doxytag: member="memfs.c::INITIAL_BUFFER_SIZE" ref="a1d51567e0f6916e91f5bd3719d56cce6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a1d51567e0f6916e91f5bd3719d56cce6">INITIAL_BUFFER_SIZE</a>&nbsp;&nbsp;&nbsp;4096</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default allocation (in bytes) of RAM space for new files. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8658f9fba39b8e2a8b08aedc0b0e216a"></a><!-- doxytag: member="memfs.c::COMPRESSION_THRESHOLD" ref="a8658f9fba39b8e2a8b08aedc0b0e216a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a8658f9fba39b8e2a8b08aedc0b0e216a">COMPRESSION_THRESHOLD</a>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size (in bytes) below which we don't bother with compression. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63a28b2887bc0a75938bbdc55142d075"></a><!-- doxytag: member="memfs.c::BUFFER_GROWTH_FACTOR" ref="a63a28b2887bc0a75938bbdc55142d075" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a63a28b2887bc0a75938bbdc55142d075">BUFFER_GROWTH_FACTOR</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The factor by which file data buffers are expanded when the current buffer is exhausted. Must be greater than 1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb9c2a167afbf6fcc40ace6c9a789e8"></a><!-- doxytag: member="memfs.c::INITIAL_LIST_SIZE" ref="a1bb9c2a167afbf6fcc40ace6c9a789e8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a1bb9c2a167afbf6fcc40ace6c9a789e8">INITIAL_LIST_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default number of slots allocated for child nodes when a new directory node is added. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15c86b63f3f767feca2b80ad0a24c7e"></a><!-- doxytag: member="memfs.c::LIST_GROWTH_FACTOR" ref="af15c86b63f3f767feca2b80ad0a24c7e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#af15c86b63f3f767feca2b80ad0a24c7e">LIST_GROWTH_FACTOR</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The factor by which directory lists are grown when the current list size is not large enough to accommodate a new entry. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a22d98ddfb0a4a471e8e3702212ca547a">findRelativeNode</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pNode, char *pszName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags, <a class="el" href="struct__MFSNODE.html">MFSNODE</a> **ppParent, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pIndex, <a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pExistingFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find or create a file node within the tree.  <a href="#a22d98ddfb0a4a471e8e3702212ca547a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a3dbe238dd55adafa543f857e9b72ead5">prepareForAccess</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that the file data is ready for access according to the requirements of the given file descriptor.  <a href="#a3dbe238dd55adafa543f857e9b72ead5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#ab80a50c7b54bf074970aa3ce0f82ad25">linkNode</a> (<a class="el" href="struct__MFSDIR.html">MFSDIR</a> *pDir, <a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pChild, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link a node into the tree.  <a href="#ab80a50c7b54bf074970aa3ce0f82ad25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#ace38d27af6ca673f6cd518e1ce840e13">growFileBuffer</a> (<a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-allocate a larger data buffer for the given file.  <a href="#ace38d27af6ca673f6cd518e1ce840e13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a7e7aecaec1021f6f81d42dc55b8e4f9a">shedFileBuffer</a> (<a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <code>pFile-&gt;pData</code> to NULL, and de-allocate the buffer if it was runtime allocated.  <a href="#a7e7aecaec1021f6f81d42dc55b8e4f9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a6376e0fa7039f05a8a75ed9103f9ba9e">destroyNode</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pNode, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fDestroyBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Completely destroy a node and all of its descendants inclusively.  <a href="#a6376e0fa7039f05a8a75ed9103f9ba9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#af3da9b3296817d4403b84a7deaa98a0c">makeNode</a> (char *pszName, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fIsDirectory, <a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pExistingFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and return a single new node, without linking it into a directory tree.  <a href="#af3da9b3296817d4403b84a7deaa98a0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a172ada308dd0f2e7285c8a0231404b46">inflateData</a> (<a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decompress the file's data buffer using zlib.  <a href="#a172ada308dd0f2e7285c8a0231404b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a97d36fa4a6b4a8215c3fbae1b603b0dd">deflateData</a> (<a class="el" href="struct__MFSFILE.html">MFSFILE</a> *pFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compress the file's data buffer using zlib.  <a href="#a97d36fa4a6b4a8215c3fbae1b603b0dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a0f7d40da93c541898f2884de98d93d16">countOpenFiles</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pNode, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pnReaders, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pnWriters)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the degree of open file access beneath a particular node.  <a href="#a0f7d40da93c541898f2884de98d93d16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e">MFSNewRoot</a> (char *pszRootName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and return a completely new root directory node.  <a href="#a0587f175c00c055fc1946afbc329031e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99">MFSReleaseRoot</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *<a class="el" href="ramdev_8c.html#acd900ede0a17cd5e83852d00f96f59a6">pMFSRoot</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the given root node, and the entire virtual filesystem descended from it.  <a href="#ace205408816af77dc43b4423e99e9a99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676">MFSCopyTree</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *<a class="el" href="ramdev_8c.html#acd900ede0a17cd5e83852d00f96f59a6">pMFSRoot</a>, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fCopyFileData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and return a completely new filesystem tree by making a recursive copy of the given tree.  <a href="#a20b70d273f9ae48d72764195ba389676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a67feded02a5ca9f5409efdcab816a96b">MFSFindRelative</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="struct__MFSNODE.html">MFSNODE</a> **ppParent, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate a file node, relative to the given root, according to its pathname.  <a href="#a67feded02a5ca9f5409efdcab816a96b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995">MFSDelete</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a file or directory, and completely release all of its associated memory resources.  <a href="#a3ac4bc307460c87476fe6409c9147995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b">MFSRename</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFromName, char *pszToName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename a file, preserving all of its contents and other properties.  <a href="#a25a08607c320c75bb89ae429896b2e4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b">MFSOpen</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, char *pszFilename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openFlags, <a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> **ppDesc, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open or create a file for reading and/or writing.  <a href="#af345c05802dcf2b916cec75fa121ac1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a0670085c171a758c25934ab3dfedf7de">MFSGetFile</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the underlying file from its open descriptor.  <a href="#a0670085c171a758c25934ab3dfedf7de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a8752395e361736b14aef4c5851217234">MFSClose</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a file that was previously opened with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.  <a href="#a8752395e361736b14aef4c5851217234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a559666aba4a9ff415231bef57568badd">MFSRead</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbLen, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a specified number of bytes from the current location of an open file.  <a href="#a559666aba4a9ff415231bef57568badd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a95bd7667a5f6ce08df29a326fa7ff390">MFSWrite</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbLen, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a specified number of bytes to an open file at the current location, expanding the file as necessary.  <a href="#a95bd7667a5f6ce08df29a326fa7ff390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#aa5a5af100d6d7bf19e3a05fbb46eb2cf">MFSWriteString</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, char *pszString, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a specified NUL-terminated character string to an open file at the current location, expanding the file as necessary. The terminating NUL character itself is not written.  <a href="#aa5a5af100d6d7bf19e3a05fbb46eb2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a13abcc96cdda1890358797cec74087be">MFSSeek</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="structHq32x2.html">Hq32x2</a> *pDestination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set (or query) the current the position in an open file.  <a href="#a13abcc96cdda1890358797cec74087be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#afeb21268e98b1f3b1a0139b22dd4e7aa">MFSSetCompression</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fCompress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controls whether the file's data buffer will be compressed (or re-compressed) when the file is closed.  <a href="#afeb21268e98b1f3b1a0139b22dd4e7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#abeddd25e694b55a14cab9351c4aea56b">MFSAvail</a> (<a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *pDesc, <a class="el" href="structHq32x2.html">Hq32x2</a> *pAvail, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reasonFlag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes that are currently available to be read from an open file.  <a href="#abeddd25e694b55a14cab9351c4aea56b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361">MFSIterBegin</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pRoot, void *pPrivate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an iteration over all or part of the file system.  <a href="#aad7116548c147cdb4d352dca4145c361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a89444976e3dbc882a6ad34aace2fbdc5">MFSIterNext</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Proceed to the first (or next) file in an iteration sequence.  <a href="#a89444976e3dbc882a6ad34aace2fbdc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a35daf840b1298eb97c15e64d025fa7f3">MFSIterEnd</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close an iteration sequence.  <a href="#a35daf840b1298eb97c15e64d025fa7f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a16c6dcdf84410f84ce54015a3c107764">MFSIterNameLength</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fLeadingSlash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the pathname length of the file at the current iteration step.  <a href="#a16c6dcdf84410f84ce54015a3c107764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#ab2f686cf36a402d6dfcfcdbaa313d9fe">MFSIterName</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState, char *pszFilenameBuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> bufLen, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> fLeadingSlash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the pathname of the file at the current iteration step.  <a href="#ab2f686cf36a402d6dfcfcdbaa313d9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a5f65338d066ddde354923d78754a1874">MFSIterNode</a> (<a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a direct pointer to the <code>MFS_File</code> node of the current iteration step.  <a href="#a5f65338d066ddde354923d78754a1874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html#a7cfe51db1b9db4fcc46adb5e5b216d90">MFSMemUsage</a> (<a class="el" href="struct__MFSNODE.html">MFSNODE</a> *pNode, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pROMSize, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pRAMSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the amount of memory currently in use by the virtual filesystem descended from the given node.  <a href="#a7cfe51db1b9db4fcc46adb5e5b216d90"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of an input/output device tied to in-memory data. </p>
<p>This is used as the backend to the RAM device <code>ramdev%</code> described in <a class="el" href="ramdev_8c.html" title="Implementation of an input/output device tied to in-memory data.">ramdev.c</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0f7d40da93c541898f2884de98d93d16"></a><!-- doxytag: member="memfs.c::countOpenFiles" ref="a0f7d40da93c541898f2884de98d93d16" args="(MFSNODE *pNode, uint32 *pnReaders, uint32 *pnWriters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void countOpenFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pnReaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pnWriters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the degree of open file access beneath a particular node. </p>
<p>This function can be used to determine whether it is currently safe to delete a directory, for example.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>The node to descend from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnReaders</em>&nbsp;</td><td>Receives the number of open file descriptors for read access. Should be initialized to zero by the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pnWriters</em>&nbsp;</td><td>Receives the number of open file descriptors for write access. Should be initialized to zero by the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97d36fa4a6b4a8215c3fbae1b603b0dd"></a><!-- doxytag: member="memfs.c::deflateData" ref="a97d36fa4a6b4a8215c3fbae1b603b0dd" args="(MFSFILE *pFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> deflateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pFile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compress the file's data buffer using zlib. </p>
<p>If the given file already has a compressed data stream, and it has not been modified, then this function just throws away the uncompressed data, since it is not necessary to re-compress an unmodified file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pFile</em>&nbsp;</td><td>The file to compress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6376e0fa7039f05a8a75ed9103f9ba9e"></a><!-- doxytag: member="memfs.c::destroyNode" ref="a6376e0fa7039f05a8a75ed9103f9ba9e" args="(MFSNODE *pNode, uint32 fDestroyBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fDestroyBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Completely destroy a node and all of its descendants inclusively. </p>
<p>Because nodes have no internal pointers to their parent, this function <em>does not</em> unlink <code>pNode</code> from its directory. The caller is assumed to have done this separately, by NULLing out the appropriate slot in the directory's child node array, before calling this function to destroy the unlinked sub-tree.</p>
<p>All dynamically-allocated memory associated with <code>pNode</code> and its descendants will be freed, with the exception of file data buffers if <code>fDestroyBuffer</code> is <code>FALSE</code>.</p>
<p>Upon return from this function, <code>pNode</code> will be a stale pointer, and should not be used again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>The root of the sub-tree to destroy. This node will itself also be destroyed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fDestroyBuffer</em>&nbsp;</td><td>Controls whether the internal data buffers of file nodes are de-allocated. Normally, you would pass <code>TRUE</code>. The only sensible exception is where <code>pNode</code> is a leaf file, whose buffer has just been assigned elsewhere. In this case, operation is non-recursive. There is no value in recursively destroying a sub-tree without de-allocating the file buffers: they will simply leak. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22d98ddfb0a4a471e8e3702212ca547a"></a><!-- doxytag: member="memfs.c::findRelativeNode" ref="a22d98ddfb0a4a471e8e3702212ca547a" args="(MFSNODE *pNode, char *pszName, int32 flags, MFSNODE **ppParent, uint32 *pIndex, MFSFILE *pExistingFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct__MFSNODE.html">MFSNODE</a> * findRelativeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> **&nbsp;</td>
          <td class="paramname"> <em>ppParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pExistingFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find or create a file node within the tree. </p>
<p>This function can locate existing file nodes, as well as create new ones. It also returns enough information about the node's position within its parent directory, so that the caller could decide to unlink the node from the tree.</p>
<p>The function works recursively. Recursion is achieved by replacing the first argument with an inner tree node, and correspondingly advancing past the leftmost path element of <code>pszName</code>.</p>
<p>When creating new files, this function will automatically create any new directories required to house the file according to its specified pathname.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>Root of the tree to be searched.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>Pathname of the file to be located, which should be expressed relative to <code>pNode</code>. The caller should ensure that this string is in writable memory (it must not be a C literal string). In case of doubt, always make a copy of the string, but the caller must then also ensure that the copy is freed again later. The reason for this is that the implementation makes temporary changes within the string to assist its search algorithm. These changes are not persistent, but it is possible for the changes to trigger memory faults if the strings are in ROM (as literal strings may be).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Configured as per the <code>open_file</code> function prototype in the Core RIP Device Interface, indicating the required access to the file. Crucially, this argument determines whether or not to create a new file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppParent</em>&nbsp;</td><td>Upon success (including in the file-creation case), this receives a pointer to the parent node of the file. This will always be a node of type <code>MFS_Directory</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pIndex</em>&nbsp;</td><td>Upon success (including in the file-creation case), this receives the numeric index of the file within the parent directory's child array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pExistingFile</em>&nbsp;</td><td>Ignored, except in the file-creation case. When a file is being created, this can be used to specify an existing file, whose contents should be transferred to the new file. This feature is used, for example, when re-naming a file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the located file node. Returns <code>NULL</code> if the file was not found (and was not required to be created), or if the creation attempt failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ace38d27af6ca673f6cd518e1ce840e13"></a><!-- doxytag: member="memfs.c::growFileBuffer" ref="ace38d27af6ca673f6cd518e1ce840e13" args="(MFSFILE *pFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> * growFileBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pFile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-allocate a larger data buffer for the given file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pFile</em>&nbsp;</td><td>The file whose buffer is to be grown. The current buffer will be expanded by a factor <code>BUFFER_GROWTH_FACTOR</code>, memory-permitting. Otherwise, attempts will be made for less growth. If the re-allocation succeeds, the old buffer will automatically be freed (unless it is a static array). The old file contents are copied into the new buffer, and the <code>cbCapcity</code> and <code>fDynamicBuffer</code> fields of <code>pFile</code> are updated for the new buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new buffer, or <code>NULL</code> if the allocation failed due to memory exhaustion. </dd></dl>

</div>
</div>
<a class="anchor" id="a172ada308dd0f2e7285c8a0231404b46"></a><!-- doxytag: member="memfs.c::inflateData" ref="a172ada308dd0f2e7285c8a0231404b46" args="(MFSFILE *pFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> inflateData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pFile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decompress the file's data buffer using zlib. </p>
<p>If the file's <code>fCompressed</code> field is <code>TRUE</code>, use this function to decompress its data stream before trying to read/write the file.</p>
<p>This function is idempotent. If you call it redundantly, it will behave as a no-op and return <code>TRUE</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pFile</em>&nbsp;</td><td>The file to decompress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab80a50c7b54bf074970aa3ce0f82ad25"></a><!-- doxytag: member="memfs.c::linkNode" ref="ab80a50c7b54bf074970aa3ce0f82ad25" args="(MFSDIR *pDir, MFSNODE *pChild, uint32 *pIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> linkNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSDIR.html">MFSDIR</a> *&nbsp;</td>
          <td class="paramname"> <em>pDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Link a node into the tree. </p>
<p>Forms a link between a parent directory and a new node, which may be either a directory or a file, but which <em>must not</em> already be linked into the tree.</p>
<p>This function will automatically grow the directory's child node array as necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDir</em>&nbsp;</td><td>The parent directory, into which the new node is inserted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pChild</em>&nbsp;</td><td>The new node.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pIndex</em>&nbsp;</td><td>Upon successful return, receives the index of <code>pChild</code> within the child node array of <code>pDir</code>. On successful return, <code>pDir-&gt;entries[ *pIndex ] == pChild</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. Failure would be due to memory exhaustion when attempting to grow the child array. </dd></dl>

</div>
</div>
<a class="anchor" id="af3da9b3296817d4403b84a7deaa98a0c"></a><!-- doxytag: member="memfs.c::makeNode" ref="af3da9b3296817d4403b84a7deaa98a0c" args="(char *pszName, uint32 fIsDirectory, MFSFILE *pExistingFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct__MFSNODE.html">MFSNODE</a> * makeNode </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fIsDirectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pExistingFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct and return a single new node, without linking it into a directory tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszName</em>&nbsp;</td><td>The <em>leaf</em> name of the node. The implementation will create a freshly-allocated copy of this string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fIsDirectory</em>&nbsp;</td><td>Determines whether the new node should be of type <code>MFS_Directory</code> or <code>MFS_File</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pExistingFile</em>&nbsp;</td><td>When making a file node, this pointer can optionally specify a pre-existing file, whose fields (including the data buffer pointers) will be copied into the new file. If you pass <code>NULL</code>, then a fresh file will be made, with a freshly-allocated, empty data buffer of default initial size. This parameter is ignored completely if <code>fIsDirectory == TRUE</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abeddd25e694b55a14cab9351c4aea56b"></a><!-- doxytag: member="memfs.c::MFSAvail" ref="abeddd25e694b55a14cab9351c4aea56b" args="(MFSFILEDESC *pDesc, Hq32x2 *pAvail, int32 reasonFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSAvail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pAvail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>reasonFlag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the number of bytes that are currently available to be read from an open file. </p>
<p>It is never permissible to call this function concurrently with the same descriptor. It <em>is</em>, however, permissible to call the function concurrently with different descriptors on the same underlying file, <em>provided that there are no open descriptors with write access on the file.</em> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pAvail</em>&nbsp;</td><td>Receives a count of available bytes upon successful return.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reasonFlag</em>&nbsp;</td><td>One of <code>SW_BYTES_AVAIL_REL</code> or <code>SW_BYTES_TOTAL_ABS</code>, as per the Core RIP Device Interface. Since files are stored in memory, the maximum extent of the data is always known, so precise information can be returned in both cases.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. This return convention is directly compatible with <code>bytes_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a8752395e361736b14aef4c5851217234"></a><!-- doxytag: member="memfs.c::MFSClose" ref="a8752395e361736b14aef4c5851217234" args="(MFSFILEDESC *pDesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a file that was previously opened with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. Note that the Core RIP Device Interfaces uses a different return convention for the <code>open_file()</code> function. When implementing such a function in terms of <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, you must convert TRUE to 0, and FALSE to -1 respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="a20b70d273f9ae48d72764195ba389676"></a><!-- doxytag: member="memfs.c::MFSCopyTree" ref="a20b70d273f9ae48d72764195ba389676" args="(MFSNODE *pMFSRoot, uint32 fCopyFileData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSCopyTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pMFSRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fCopyFileData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct and return a completely new filesystem tree by making a recursive copy of the given tree. </p>
<p>Use <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> to recursively destroy the copy when it is no longer needed.</p>
<p><code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> and <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code> are the only two functions that can be used to create a completely fresh virtual filesystem tree. All other functions operate on nodes that are already linked into an existing tree.</p>
<p>The directory node returned by this function is stand-alone, and completely unlinked from any existing virtual filesystems being managed by MFS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pMFSRoot</em>&nbsp;</td><td>Pointer to the root of the tree to be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fCopyFileData</em>&nbsp;</td><td>Controls whether the underlying file data buffers are copied into the new tree. If you pass <code>TRUE</code>, then fresh copies of the file data will be made in the new tree. Otherwise, the underlying file data will be shared by the new tree and the original tree. Sharing the file data will use less memory, but it means that modifications to files in the new tree can potentially have side-effects on the files in the original tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the function succeeds, the return value is a pointer to a newly-allocated filesystem tree whose shape and contents exactly match the original tree. Every directory and file that exists in the original tree will also exist in the new tree. The files will also contain the same data, which will either be a copy of the original, or a duplicated pointer to memory shared with the original, depending on the value of <code>fCopyFileData</code>. If the function fails, the return value is <code>NULL</code>, which is best interpreted as being due to memory exhaustion. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac4bc307460c87476fe6409c9147995"></a><!-- doxytag: member="memfs.c::MFSDelete" ref="a3ac4bc307460c87476fe6409c9147995" args="(MFSNODE *pRoot, char *pszFilename, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a file or directory, and completely release all of its associated memory resources. </p>
<p>This function can be used to delete a single file, or to <em>recursively</em> delete a directory and all of its descendants, regardless of their contents. If you consider this function as being like the UNIX <code>rm</code> command, then there is an implicit <code>-rf</code>.</p>
<p>This function will fail if the specified file is currently open with any level of access. In the recursive case, the function will similarly fail if any open files are included amongst the directory's descendants.</p>
<p>It is permissible to call this function concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This can be any directory node, as long as the filename is expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file or directory, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, -1 on failure. This return convention is directly compatible with <code>delete_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a67feded02a5ca9f5409efdcab816a96b"></a><!-- doxytag: member="memfs.c::MFSFindRelative" ref="a67feded02a5ca9f5409efdcab816a96b" args="(MFSNODE *pRoot, char *pszFilename, MFSNODE **ppParent, uint32 *pIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSFindRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> **&nbsp;</td>
          <td class="paramname"> <em>ppParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locate a file node, relative to the given root, according to its pathname. </p>
<p>This function may be called concurrently, even on shared directory trees. However, it should not be called concurrently with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code> or <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code>, unless such concurrent calls are operating on disjoint (sub-)trees, otherwise race conditions result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>The root of the search.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppParent</em>&nbsp;</td><td>If the function succeeds, this output parameter receives a pointer to the target node's parent node, which will be of type <code>MFS_Directory</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pIndex</em>&nbsp;</td><td>If the function succeeds, this output parameter receives the index of the target node within its parent directory's child array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the located node, or <code>NULL</code> if no matching node was found. (This function never creates new nodes - you must use <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code> for that). If a pointer is returned, the node will always be of type <code>MFS_File</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0670085c171a758c25934ab3dfedf7de"></a><!-- doxytag: member="memfs.c::MFSGetFile" ref="a0670085c171a758c25934ab3dfedf7de" args="(MFSFILEDESC *pDesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSFILE.html">MFSFILE</a>* MFSGetFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the underlying file from its open descriptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The corresponding file within the virtual tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aad7116548c147cdb4d352dca4145c361"></a><!-- doxytag: member="memfs.c::MFSIterBegin" ref="aad7116548c147cdb4d352dca4145c361" args="(MFSNODE *pRoot, void *pPrivate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a>* MFSIterBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pPrivate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin an iteration over all or part of the file system. </p>
<p>This function can be used to visit <em>file</em> nodes beneath the given directory. The iteration will recursively enter all nested directories, but the directories themselves are not visited as an explicit iteration step.</p>
<p>The function returns a pointer to an internally-allocated <code>MFSITERSTATE</code> structure, which maintains information about the current iteration state. This structure is initialized at a notional position <em>before</em> the first file. To visit the first file, you must make an initial call to <code><a class="el" href="memfs_8c.html#a89444976e3dbc882a6ad34aace2fbdc5" title="Proceed to the first (or next) file in an iteration sequence.">MFSIterNext()</a></code>, and so on to visit subsequent files.</p>
<p>At each iteration step, you can call <code><a class="el" href="memfs_8c.html#a16c6dcdf84410f84ce54015a3c107764" title="Obtain the pathname length of the file at the current iteration step.">MFSIterNameLength()</a></code> and <code><a class="el" href="memfs_8c.html#ab2f686cf36a402d6dfcfcdbaa313d9fe" title="Obtain the pathname of the file at the current iteration step.">MFSIterName()</a></code> to obtain the pathname of the current file, expressed relative to <code>pRoot</code>. You can also call <code><a class="el" href="memfs_8c.html#a5f65338d066ddde354923d78754a1874" title="Obtain a direct pointer to the MFS_File node of the current iteration step.">MFSIterNode()</a></code> to obtain a direct pointer to the current file node.</p>
<p>To avoid resource leaks, all calls to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code> must be matched by a later call to <code><a class="el" href="memfs_8c.html#a35daf840b1298eb97c15e64d025fa7f3" title="Close an iteration sequence.">MFSIterEnd()</a></code>.</p>
<p>The following code fragment demonstrates the basic call pattern for iteration.</p>
<div class="fragment"><pre class="fragment">
  {
     char filename[ MAXFILENAMELENGTH ];
     MFSITERSTATE *pState = MFSIterBegin( pRoot, NULL );
     while ( MFSIterNext( pState ) )
     {
       if ( MFSIterName( pState, filename, sizeof( filename ), TRUE ) )
         printf( "Visiting %s\n", filename );
       else
         printf( "&lt;Filename too long&gt;\n" );
     }
     MFSIterEnd( pState );
  } 
  </pre></div><p>Backwards iteration is not supported, and no assumption should be made that files are visited in any particular order, such as alphabetical order.</p>
<p>It is legal to call <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> on the current file during iteration. It is also legal to call <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code>, although it is then undefined whether the destination file will then be visited later in the iteration.</p>
<p>The iteration function can be used to support an implementation of the <code>start_file_list</code> and <code>next_file</code> functions in the Core RIP Device Interface.</p>
<p>In general, iteration functions may be called concurrently, provided that they are "separate" iterations - that is, using different <code>MFSITERSTATE</code> structures.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system, or directory sub-tree to be traversed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>Arbitrary pointer to caller-managed memory. This pointer will be installed into the <code>pPrivate</code> field of the <code>MFSITERSTATE</code> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to an internally-managed data structure. This pointer remains legal until it is passed into <code><a class="el" href="memfs_8c.html#a35daf840b1298eb97c15e64d025fa7f3" title="Close an iteration sequence.">MFSIterEnd()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a35daf840b1298eb97c15e64d025fa7f3"></a><!-- doxytag: member="memfs.c::MFSIterEnd" ref="a35daf840b1298eb97c15e64d025fa7f3" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSIterEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close an iteration sequence. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>. This pointer becomes invalid upon return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2f686cf36a402d6dfcfcdbaa313d9fe"></a><!-- doxytag: member="memfs.c::MFSIterName" ref="ab2f686cf36a402d6dfcfcdbaa313d9fe" args="(MFSITERSTATE *pState, char *pszFilenameBuf, uint32 bufLen, uint32 fLeadingSlash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSIterName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilenameBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fLeadingSlash</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the pathname of the file at the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilenameBuf</em>&nbsp;</td><td>A pointer to caller-managed memory, which will receive the pathname. The pathname will be expressed relative to the directory that was specified to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>, and will use forward-slash characters as path separators. A leading foward-slash and a terminating NUL character are included.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufLen</em>&nbsp;</td><td>The number of bytes available in the buffer. If this does not accommodate the pathname (including its NUL terminator), the function will fail, and no bytes will be written into the buffer. Use <code><a class="el" href="memfs_8c.html#a16c6dcdf84410f84ce54015a3c107764" title="Obtain the pathname length of the file at the current iteration step.">MFSIterNameLength()</a></code> to obtain the required buffer length, and remember to use the same value for <code>fLeadingSlash</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeadingSlash</em>&nbsp;</td><td>Flag indicating whether a leading slash should be included in the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c6dcdf84410f84ce54015a3c107764"></a><!-- doxytag: member="memfs.c::MFSIterNameLength" ref="a16c6dcdf84410f84ce54015a3c107764" args="(MFSITERSTATE *pState, uint32 fLeadingSlash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> MFSIterNameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fLeadingSlash</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the pathname length of the file at the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fLeadingSlash</em>&nbsp;</td><td>Flag indicating whether a leading slash should be taken into account when computing the filename. This will just increase the returned value by 1 character, but the parameterization is in order to be consistent with <code><a class="el" href="memfs_8c.html#ab2f686cf36a402d6dfcfcdbaa313d9fe" title="Obtain the pathname of the file at the current iteration step.">MFSIterName()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of 8-bit characters, including a NUL terminator and all separating characters, required to store the pathname of the current file. </dd></dl>

</div>
</div>
<a class="anchor" id="a89444976e3dbc882a6ad34aace2fbdc5"></a><!-- doxytag: member="memfs.c::MFSIterNext" ref="a89444976e3dbc882a6ad34aace2fbdc5" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSIterNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Proceed to the first (or next) file in an iteration sequence. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the iteration has proceeded; FALSE if the iteration has been exhausted. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f65338d066ddde354923d78754a1874"></a><!-- doxytag: member="memfs.c::MFSIterNode" ref="a5f65338d066ddde354923d78754a1874" args="(MFSITERSTATE *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSIterNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSITERSTATE.html">MFSITERSTATE</a> *&nbsp;</td>
          <td class="paramname"> <em>pState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a direct pointer to the <code>MFS_File</code> node of the current iteration step. </p>
<p>For more information, see <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pState</em>&nbsp;</td><td>The current iteration state, as previously obtained from a call to <code><a class="el" href="memfs_8c.html#aad7116548c147cdb4d352dca4145c361" title="Begin an iteration over all or part of the file system.">MFSIterBegin()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cfe51db1b9db4fcc46adb5e5b216d90"></a><!-- doxytag: member="memfs.c::MFSMemUsage" ref="a7cfe51db1b9db4fcc46adb5e5b216d90" args="(MFSNODE *pNode, uint32 *pROMSize, uint32 *pRAMSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSMemUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pROMSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pRAMSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the amount of memory currently in use by the virtual filesystem descended from the given node. </p>
<p>This function recursively walks over the tree, and totals up the file data buffer space being used. The result is approximate, since the memory consumption of MFS internal data structures is not included, but this is generally small in comparison with the actual file data.</p>
<p>The function produces separate totals for ROM consumption and RAM consumption. ROM consumption extends to initial file data that was imported from an external source and embedded in the compiled binaries. RAM consumption extends to all further space that was allocated at runtime. RAM consumption will tend to fluctuate with usage of the filesystem, whereas ROM consumption is fixed (effectively at application link time).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>Root node of the virtual filesystem to be examined. This is allowed to be <code>NULL</code>, in which case the function does nothing.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pROMSize</em>&nbsp;</td><td>This number is increased by the number of bytes of ROM being consumed by the filesystem. The caller should initialize this to zero to obtain a total for just the given node. There is no handling for overflow. If files have been deleted from the tree, their ROM consumption is no longer included by this function, although the memory is effectively "leaked" and cannot be recovered. (RAM space, by comparison, is never leaked).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRAMSize</em>&nbsp;</td><td>This number is increased by the number of bytes of dynamic heap memory being consumed by the filesystem. The caller should initialize this to zero to obtain a total for just the given node. There is no handling for overflow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0587f175c00c055fc1946afbc329031e"></a><!-- doxytag: member="memfs.c::MFSNewRoot" ref="a0587f175c00c055fc1946afbc329031e" args="(char *pszRootName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__MFSNODE.html">MFSNODE</a>* MFSNewRoot </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszRootName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct and return a completely new root directory node. </p>
<p>Use <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> to destroy this root and the entire virtual filesystem descended from it.</p>
<p><code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> and <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code> are the only two functions that can be used to create a completely fresh virtual filesystem tree. All other functions operate on nodes that are already linked into an existing tree.</p>
<p>The directory node returned by this function is stand-alone, and completely unlinked from any existing virtual filesystems being managed by MFS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszRootName</em>&nbsp;</td><td>The identifier to use for the root node, since all nodes must have a name. Note that this name <em>does not</em> form a part of any path relative to this root.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new node, whose type will be <code>MFS_Directory</code>, or <code>NULL</code> if there has been a failure to allocate the necessary memory. </dd></dl>

</div>
</div>
<a class="anchor" id="af345c05802dcf2b916cec75fa121ac1b"></a><!-- doxytag: member="memfs.c::MFSOpen" ref="af345c05802dcf2b916cec75fa121ac1b" args="(MFSNODE *pRoot, char *pszFilename, int32 openFlags, MFSFILEDESC **ppDesc, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>openFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> **&nbsp;</td>
          <td class="paramname"> <em>ppDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open or create a file for reading and/or writing. </p>
<p>This function can be called concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument. Similar caveats apply with concurrent calls to <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> and <code><a class="el" href="memfs_8c.html#a25a08607c320c75bb89ae429896b2e4b" title="Rename a file, preserving all of its contents and other properties.">MFSRename()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This may be any directory node within the tree, as long as the filename is expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFilename</em>&nbsp;</td><td>The pathname of the required file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openFlags</em>&nbsp;</td><td>Specified as per the Core RIP Device Interface, indicating the required level of access to the file. The Memory File System allows concurrent read access, but write access is always exclusive. This parameter can also indicate whether to create a new file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppDesc</em>&nbsp;</td><td>If the function succeeds, receives a pointer to the file descriptor. This pointer must subsequently be passed into all functions used to access the file while it is open. Ultimately, the pointer must be passed to <code><a class="el" href="memfs_8c.html#a8752395e361736b14aef4c5851217234" title="Close a file that was previously opened with MFSOpen().">MFSClose()</a></code> in order to close the file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success; FALSE upon failure. Note that the Core RIP Device Interfaces uses a different return convention for the <code>open_file()</code> function. When implementing such a function in terms of <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>, you must convert TRUE to 0, and FALSE to -1 respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="a559666aba4a9ff415231bef57568badd"></a><!-- doxytag: member="memfs.c::MFSRead" ref="a559666aba4a9ff415231bef57568badd" args="(MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a specified number of bytes from the current location of an open file. </p>
<p>This function has no side-effects on the underlying file. Therefore, it is permissible to call this function concurrently for different descriptors on the same file, but <em>not</em> with identical descriptors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with read access: <code>SW_RDONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to caller-managed data buffer, which will receive the bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbLen</em>&nbsp;</td><td>The maximum number of bytes to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually read, which will not be greater than <code>cbLen</code>, but which might be less. Returns zero if the end of file has been reached. Returns -1 upon failure. This return convention is directly compatible with <code>read_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
<a class="anchor" id="ace205408816af77dc43b4423e99e9a99"></a><!-- doxytag: member="memfs.c::MFSReleaseRoot" ref="ace205408816af77dc43b4423e99e9a99" args="(MFSNODE *pMFSRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MFSReleaseRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pMFSRoot</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the given root node, and the entire virtual filesystem descended from it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pMFSRoot</em>&nbsp;</td><td>The root node, which must have previously been allocated with either <code><a class="el" href="memfs_8c.html#a0587f175c00c055fc1946afbc329031e" title="Construct and return a completely new root directory node.">MFSNewRoot()</a></code> or <code><a class="el" href="memfs_8c.html#a20b70d273f9ae48d72764195ba389676" title="Construct and return a completely new filesystem tree by making a recursive copy...">MFSCopyTree()</a></code>. <em>Never</em> call <code><a class="el" href="memfs_8c.html#ace205408816af77dc43b4423e99e9a99" title="Destroy the given root node, and the entire virtual filesystem descended from it...">MFSReleaseRoot()</a></code> with a non-root node from within another virtual filesystem. Use <code><a class="el" href="memfs_8c.html#a3ac4bc307460c87476fe6409c9147995" title="Delete a file or directory, and completely release all of its associated memory resources...">MFSDelete()</a></code> instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25a08607c320c75bb89ae429896b2e4b"></a><!-- doxytag: member="memfs.c::MFSRename" ref="a25a08607c320c75bb89ae429896b2e4b" args="(MFSNODE *pRoot, char *pszFromName, char *pszToName, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSRename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSNODE.html">MFSNODE</a> *&nbsp;</td>
          <td class="paramname"> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszFromName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszToName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a file, preserving all of its contents and other properties. </p>
<p>It is permissible to call this function concurrently, provided that all concurrent calls are given disjoint (sub-)trees as the first argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRoot</em>&nbsp;</td><td>Root of the file system or sub-tree. This can be any directory node, as long as the filenames are expressed relative to it.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszFromName</em>&nbsp;</td><td>The pathname of the source file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements. The function will fail if this pathname designates a file that is currently open with any level of access. The function will also fail if this pathname does not exist, or if it designates a directory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszToName</em>&nbsp;</td><td>The pathname of the destination file, expressed relative to <code>pRoot</code>, and with forward-slash characters separating the path elements. If this pathname denotes any file or directory that already exists, the function will fail.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, -1 on failure. This return convention is directly compatible with <code>delete_file</code> in the Core RIP Device Interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a13abcc96cdda1890358797cec74087be"></a><!-- doxytag: member="memfs.c::MFSSeek" ref="a13abcc96cdda1890358797cec74087be" args="(MFSFILEDESC *pDesc, Hq32x2 *pDestination, int32 flags, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSSeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>pDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set (or query) the current the position in an open file. </p>
<p>It is never permissible to call this function concurrently with the same file descriptor. It <em>is</em>, however, permissible to call the function concurrently with different descriptors on the same underlying file, <em>provided that there are no open descriptors with write access on the file.</em></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code> (with any level of access).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestination</em>&nbsp;</td><td>Specifies the file pointer adjustment, and receives the absolute file position if the function returns successfully.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One of <code>SW_SET</code>, <code>SW_INCR</code> or <code>SW_XTND</code>, as per the Core RIP Device Interface. This determines how the <code>pDestination</code> argument is treated on entry. However, the updated <code>pDestination</code> is always an absolute file pointer on exit. To query the current file pointer without modifying it, use <code>SW_INCR</code> and supply a pointer to a <em>zero-valued</em> <code><a class="el" href="structHq32x2.html" title="Signed 64 bit integer, represented as a 2s complement pair.">Hq32x2</a></code> (note that this <em>does not</em> mean a NULL pointer).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE upon success, in which case <code>pDestination</code> is updated with the current file pointer. FALSE upon failure, in which case <code>pDestination</code> is not updated. This return convention is directly compatible with <code>seek_file</code> in the Core RIP Device Interface </dd></dl>

</div>
</div>
<a class="anchor" id="afeb21268e98b1f3b1a0139b22dd4e7aa"></a><!-- doxytag: member="memfs.c::MFSSetCompression" ref="afeb21268e98b1f3b1a0139b22dd4e7aa" args="(MFSFILEDESC *pDesc, uint32 fCompress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSSetCompression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>fCompress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls whether the file's data buffer will be compressed (or re-compressed) when the file is closed. </p>
<p>This function can only be called when the file's data buffer is currently in an uncompressed state. This will be the case if the file was opened for writing, or for random-access reading. In other cases, it is less certain.</p>
<p>Normally, when a file is closed, its data buffer is retained in a compressed state to save on memory usage. There might be cases where this is undesirable. For instance, if a large file is opened and closed many times in rapid succession, a runtime expense will be incurred in decompression (and re-compression) of the data. The caller might use this function to de-activate the compression for periods of such activity. The caller might also use this function when storing data that has already been compressed, in which case there is little point in trying to compress it again.</p>
<p>The most typical use of this function is immediately after creation of a <em>new</em> file with <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fCompress</em>&nbsp;</td><td>Supply <code>TRUE</code> to indicate that the file buffer should be compressed when the file is closed, or <code>FALSE</code> to indicate that it shouldn't.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a95bd7667a5f6ce08df29a326fa7ff390"></a><!-- doxytag: member="memfs.c::MFSWrite" ref="a95bd7667a5f6ce08df29a326fa7ff390" args="(MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a specified number of bytes to an open file at the current location, expanding the file as necessary. </p>
<p>This function has side-effects on the underlying file. Therefore, it is never permissible to call this function concurrently with descriptors on the same file. It is also never permissible to call <code><a class="el" href="memfs_8c.html#a559666aba4a9ff415231bef57568badd" title="Read a specified number of bytes from the current location of an open file.">MFSRead()</a></code> concurrently with <code><a class="el" href="memfs_8c.html#a95bd7667a5f6ce08df29a326fa7ff390" title="Write a specified number of bytes to an open file at the current location, expanding...">MFSWrite()</a></code> with descriptors on the same underlying file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to caller-managed data buffer, from which bytes will be copied into the file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbLen</em>&nbsp;</td><td>The maximum number of bytes to write.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, which will not be greater than <code>cbLen</code>, but which might be less. Returns -1 upon failure. This return convention is directly compatible with <code>write_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a5af100d6d7bf19e3a05fbb46eb2cf"></a><!-- doxytag: member="memfs.c::MFSWriteString" ref="aa5a5af100d6d7bf19e3a05fbb46eb2cf" args="(MFSFILEDESC *pDesc, char *pszString, int32 *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> MFSWriteString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a specified NUL-terminated character string to an open file at the current location, expanding the file as necessary. The terminating NUL character itself is not written. </p>
<p>This function has side-effects on the underlying file. Therefore, it is never permissible to call this function concurrently with descriptors on the same file. It is also never permissible to call <code><a class="el" href="memfs_8c.html#a559666aba4a9ff415231bef57568badd" title="Read a specified number of bytes from the current location of an open file.">MFSRead()</a></code> or <code><a class="el" href="memfs_8c.html#a95bd7667a5f6ce08df29a326fa7ff390" title="Write a specified number of bytes to an open file at the current location, expanding...">MFSWrite()</a></code> concurrently with <code><a class="el" href="memfs_8c.html#aa5a5af100d6d7bf19e3a05fbb46eb2cf" title="Write a specified NUL-terminated character string to an open file at the current...">MFSWriteString()</a></code>, with descriptors on the same underlying file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A pointer to the file descriptor, obtained from an earlier call to <code><a class="el" href="memfs_8c.html#af345c05802dcf2b916cec75fa121ac1b" title="Open or create a file for reading and/or writing.">MFSOpen()</a></code>. The file must have been opened with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszString</em>&nbsp;</td><td>A pointer to caller-managed string memory. The string should be NUL-terminated, and should be an ANSI or multi-byte encoded character string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Pointer to an integer error code, specified according to the Core RIP Device Interface. If the function fails, this will receive the appropriate device error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, which will not be greater than the length of the string <em>in bytes</em>, but which might be less. Returns -1 upon failure. This return convention is directly compatible with <code>write_file</code> in the Core RIP Device interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dbe238dd55adafa543f857e9b72ead5"></a><!-- doxytag: member="memfs.c::prepareForAccess" ref="a3dbe238dd55adafa543f857e9b72ead5" args="(MFSFILEDESC *pDesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> prepareForAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="memfs_8h.html#a149dff2dc199b173cd81b48368ca72e2">MFSFILEDESC</a> *&nbsp;</td>
          <td class="paramname"> <em>pDesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure that the file data is ready for access according to the requirements of the given file descriptor. </p>
<p>If write access is required, this function calls <code><a class="el" href="memfs_8c.html#a172ada308dd0f2e7285c8a0231404b46" title="Decompress the file&#39;s data buffer using zlib.">inflateData()</a></code> to decompress the whole file.</p>
<p>If read-only access is required, this function prepares a zlib stream, so that the data can be read sequentially without decompressing the whole file. This is an optimization aimed at saving memory in some typical situations. The caller does not declare that all reads will be sequential, but it is useful for us to start by assuming that they will be. We can then avoid a full decompression until the caller performs the first arbitrary seek operation. If this happens, it will be detected by <code><a class="el" href="memfs_8c.html#a13abcc96cdda1890358797cec74087be" title="Set (or query) the current the position in an open file.">MFSSeek()</a></code>, which will discard the zlib stream, and call <code><a class="el" href="memfs_8c.html#a172ada308dd0f2e7285c8a0231404b46" title="Decompress the file&#39;s data buffer using zlib.">inflateData()</a></code> to decompress the whole file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDesc</em>&nbsp;</td><td>A valid new file descriptor, which has not yet been used for any I/O operations (unless the caller wishes to reset access to the beginning of the file). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e7aecaec1021f6f81d42dc55b8e4f9a"></a><!-- doxytag: member="memfs.c::shedFileBuffer" ref="a7e7aecaec1021f6f81d42dc55b8e4f9a" args="(MFSFILE *pFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void shedFileBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__MFSFILE.html">MFSFILE</a> *&nbsp;</td>
          <td class="paramname"> <em>pFile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <code>pFile-&gt;pData</code> to NULL, and de-allocate the buffer if it was runtime allocated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pFile</em>&nbsp;</td><td>The file whose buffer is being discarded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
