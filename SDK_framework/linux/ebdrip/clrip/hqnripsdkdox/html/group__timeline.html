<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: Timeline API</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Timeline API<br/>
<small>
[<a class="el" href="group__interface.html">Harlequin RIP core interface.</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="timelineapi_8h.html">timelineapi.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This header file provides the definition of the Timeline API. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="timeline_8c.html">timeline.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file provides the Timeline API. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler considerations for Timeline Events.  <a href="#ga61ccfbc6ffd1a12aa48a37a73414a3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeline units.  <a href="#ga5186a283db61b9276a111d9f37e61b3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeline priorities.  <a href="#gadcdf9f678aff874e7d8e6bb139fb7817"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeline extents and progress.  <a href="#ga298435e7f3b67a0a845bdd0c6c7cb7c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return values.  <a href="#ga91d0370ec5a7091e1717d91e51c62bf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Timeline context identifiers.  <a href="#gaaf625e19c8ca5dc9fb654e8590d79ffe"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Timeline states. </p>
 <a href="group__timeline.html#gad63240694c6dc2a28c24bfc2db90ad7a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Timeline event numbers. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caaac5b7024bd891d6d946d518f924701be">SW_TL_SUCCESS</a> =  0, 
<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caa68ac272ce85040f630f17e63acc639ad">SW_TL_ERROR</a>, 
<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caa0540e34d9584cc14c4c12ebdd3b306c6">SW_TL_ERROR_UNKNOWN</a>, 
<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caa39e95e34891f283dc90fd642c9c93ec2">SW_TL_ERROR_SYNTAX</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caa03246395df1d51db6b4ad2d2082e6fb5">SW_TL_ERROR_IN_USE</a>, 
<a class="el" href="group__timeline.html#gga70ad55be767ca0a42c9150d24618e4caabb9ba01baeb7b2547906b44b1b16585c">SW_TL_ERROR_MEMORY</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_tl_ref&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaef4163e657c0cd4f510e5686e2669061">SwTimelineStart</a> (<a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a> type, sw_tl_ref parent, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> start, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> end, <a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a> unit, <a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a> priority, void *context, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *title, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Timeline, issuing a Start Event immediately.  <a href="#gaef4163e657c0cd4f510e5686e2669061"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaee75ed447a1a7b8f95ebcf3f72d1614d">SwTimelineEnd</a> (sw_tl_ref ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Potentially end a Timeline. Whether the Timeline End Event is issued immediately depends on whether there are ongoing descendant Timelines of the same or higher priority.  <a href="#gaee75ed447a1a7b8f95ebcf3f72d1614d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaa1445a6682ed8e66a601959951d5cb2d">SwTimelineAbort</a> (sw_tl_ref ref, int reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Potentially abort a Timeline. Whether the Timeline Abort Event is issued immediately depends on whether there are ongoing descendant Timelines of the same or higher priority.  <a href="#gaa1445a6682ed8e66a601959951d5cb2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaa6505f8140b1c12f562eb93d21d05694">SwTimelineSetTitle</a> (sw_tl_ref ref, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *title, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the title of a Timeline. Issues an Event before changing the title.  <a href="#gaa6505f8140b1c12f562eb93d21d05694"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gafcb31d3652b8079c24bbb785c6c7eb7f">SwTimelineGetTitle</a> (sw_tl_ref ref, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buffer, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Timeline's title and length.  <a href="#gafcb31d3652b8079c24bbb785c6c7eb7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga57b698c88d63fc097c2b00217f5e5747">SwTimelineSetExtent</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> start, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the length of the Timeline. Issues an Event for a nonzero change.  <a href="#ga57b698c88d63fc097c2b00217f5e5747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaa6e0795673ed0e3451c6a849d8f09f9a">SwTimelineSetProgress</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> progress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the progress of the Timeline, in the units given when the Timeline was started. Issues an Event if the current value changes.  <a href="#gaa6e0795673ed0e3451c6a849d8f09f9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gaed87b66c01741b285e2848b660db43bf">SwTimelineGetProgress</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *start, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *end, <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *progress, <a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a> *unit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the extent, unit and progress through a Timeline.  <a href="#gaed87b66c01741b285e2848b660db43bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_tl_ref&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga7c7e5aa68988f7764068a39a4d02bda1">SwTimelineGetAncestor</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the NEAREST ancestor of the Timeline of the specified type.  <a href="#ga7c7e5aa68988f7764068a39a4d02bda1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_tl_ref&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga9aba6c2972cfaca924cee63bc527f66b">SwTimelineOfType</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure the Timeline or an ancestor is of the given type.  <a href="#ga9aba6c2972cfaca924cee63bc527f66b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#gacd4fa34dd20137cd5b963489e7991614">SwTimelineGetType</a> (sw_tl_ref ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Timeline type if known.  <a href="#gacd4fa34dd20137cd5b963489e7991614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga987a088199569961ed49a771fabe7cb6">SwTimelineGetPriority</a> (sw_tl_ref ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Timeline priority if known.  <a href="#ga987a088199569961ed49a771fabe7cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga3ff8c8ff573a862e77f1215f52c0cd62">SwTimelineSetContext</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a> id, void *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach a secondary context to a Timeline.  <a href="#ga3ff8c8ff573a862e77f1215f52c0cd62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timeline.html#ga169b6dbc3d797fe153b2f55787b450de">SwTimelineGetContext</a> (sw_tl_ref ref, <a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a> id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a context from the Timeline.  <a href="#ga169b6dbc3d797fe153b2f55787b450de"></a><br/></td></tr>
</table>


<h3><a class="anchor" id="timelineapi">The Timeline API</a></h3><p>The Timeline API allows entities with a finite lifespan to be uniquely identified, with a type and human-readable title. The resulting reference can then be used to identify the entity, and detect when it no longer exists.</p>
<p>Additionally, the lifespan of such entities can be managed, communicated to interested parties and negotiated. They can be linked to related superior or subordinate entities. Related information can be attached to a Timeline and retrieved later, even after the Timeline has ended.</p>
<p>Parties can communicate extent of, progress through and unit of measure of a Timeline, and send human-readable feedback, status messages, error reports or detailed logging related to a specific Timeline.</p>
<h2><a class="anchor" id="timelinerefs">
Timeline References</a></h2>
<p>Once started, a Timeline is referred to by a Timeline Reference. This is an opaque identifier which is guaranteed unique for the lifetime of the Timeline and for a significant time afterwards. Obsolete references will eventually be reused, but as the reference is an integer of at least 32bits, this should take some time.</p>
<h2><a class="anchor" id="timelinetypes">
Timeline Types</a></h2>
<p>Timeline types are enumerated in this file. Since a Timeline can represent a wide variety of entities - a print job, an ongoing process, cached data, removeable peripheral, physical sensor - the range of types is subdivided into subsets for customer use. A Timeline is not necessarily something that is communicated from the Core to the Skin, nor vice versa.</p>
<p>As any system is free to attach child Timelines to any other Timeline, no assumption should be made of the topography of a Timeline hierarchy. Calls are provided to find the type and title of a Timeline, and its parent of a particular type, if any. This allows clients to discover if Timeline Events relate to the Timeline it is most interested in, even if only distantly related.</p>
<p>Some uses of Timelines:</p>
<p>* Skin's concept of a "print job" * Core's concept of a "print job", which may not be the same thing * Font cartridge, so its removal can be negotiated * Fuser unit, so failure and current temperature can be reported * Print head and ink cartridges as a hierarchy for status monitoring</p>
<h2><a class="anchor" id="timelineevents">
Timeline Events</a></h2>
<p>All significant Timeline state changes issue Events. This allows interested parties to be informed immediately of the change, and in many cases allows such Handlers to modify or prevent the change from happening. For example, the interpreter can communicate the job title as it is discovered. The Core can object to a Font Cartridge being ejected if it is currently in use. A debugging extension can log all messages and errors emitted by a subsystem.</p>
<h2><a class="anchor" id="timelinenotes">
Timeline Notes</a></h2>
<p>The Timeline system is multi-thread and multi-client system. Timelines can therefore appear and disappear at unpredictable times. In particular, this means a Timeline can disappear after a call that returns some state from that Timeline, but before the caller uses that state. Care must be taken that no assumption is made of Timeline continuance where such Timelines could end unexpectedly. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaaf625e19c8ca5dc9fb654e8590d79ffe"></a><!-- doxytag: member="timelineapi.h::sw_tl_context" ref="gaaf625e19c8ca5dc9fb654e8590d79ffe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a> <a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timeline context identifiers. </p>
<p>Any producer or consumer of timelines may attach a void pointer to the timeline, so it can associate its own data with the timeline. Contexts are identified by a number, used by the <a class="el" href="group__timeline.html#ga169b6dbc3d797fe153b2f55787b450de" title="Return a context from the Timeline.">SwTimelineGetContext()</a> and <a class="el" href="group__timeline.html#ga3ff8c8ff573a862e77f1215f52c0cd62" title="Attach a secondary context to a Timeline.">SwTimelineSetContext()</a> calls to identify the particular piece of data. Timeline context identifier numbering follows the numbering conventions for DEVICETYPE numbers.</p>
<p>The value 0 is reserved for the creator of the timeline type, regardless of whether it is Global Graphics or a customer. The range 0x00000001-0x0000ffff is reserved for Global Graphics. The range 0xXXXX0000-0xXXXXffff is reserved for customer number XXXX. The range 0xffff0000-0xffffffff is for private use in closed environments.</p>
<p>These ranges are sub-allocated here and elsewhere.</p>
<p>The owner context (ID zero) may only be associated with the timeline by the creator of the timeline, as an argument to the <a class="el" href="group__timeline.html#gaef4163e657c0cd4f510e5686e2669061" title="Create a Timeline, issuing a Start Event immediately.">SwTimelineStart()</a> call.</p>
<p>Callers that associate data with a timeline must also take responsibility for managing the lifetime of that data. In particular, callers should be aware that timelines may be prolonged beyond their normal scope, if a child timeline with higher priority defers ending. The caller should either detach context references from the timeline when it sees an EVENT_TIMELINE_END, or use reference counting or another liveness management technique to ensure the context can survive until EVENT_TIMELINE_ENDED is issued. </p>

</div>
</div>
<a class="anchor" id="ga298435e7f3b67a0a845bdd0c6c7cb7c0"></a><!-- doxytag: member="timelineapi.h::sw_tl_extent" ref="ga298435e7f3b67a0a845bdd0c6c7cb7c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timeline extents and progress. </p>
<p>A Timeline can have an extent, measured in a unit. Progress along the Timeline is measured as a fraction of that extent.</p>
<p>A Timeline for which there is no way of knowing its extent can have an indeterminate extent.</p>
<p>Note that a UI will only display progress once a progress event has been received. </p>

</div>
</div>
<a class="anchor" id="gadcdf9f678aff874e7d8e6bb139fb7817"></a><!-- doxytag: member="timelineapi.h::sw_tl_priority" ref="gadcdf9f678aff874e7d8e6bb139fb7817" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timeline priorities. </p>
<p>Timelines within a hierarchy can have different priorities. These decide whether ending a Timeline automatically ends its children or affects its parent.</p>
<p>Higher priority Timelines outrank lower priority Timelines. The priority of the Timeline being Ended or Aborted is compared with all descendants (and ancestors, in the case of Abort) to decide whether to End or Abort immediately, or whether to propogate the Abort upwards. Timelines will only end children or abort children and/or parents if they are strictly greater priority than the child or parent.</p>
<p>See <a class="el" href="group__timeline.html#gaee75ed447a1a7b8f95ebcf3f72d1614d" title="Potentially end a Timeline. Whether the Timeline End Event is issued immediately...">SwTimelineEnd()</a> and <a class="el" href="group__timeline.html#gaa1445a6682ed8e66a601959951d5cb2d" title="Potentially abort a Timeline. Whether the Timeline Abort Event is issued immediately...">SwTimelineAbort()</a> for details. </p>

</div>
</div>
<a class="anchor" id="ga91d0370ec5a7091e1717d91e51c62bf0"></a><!-- doxytag: member="timelineapi.h::sw_tl_result" ref="ga91d0370ec5a7091e1717d91e51c62bf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return values. </p>
<p>If the Timeline reference passed in a call is not recognised, usually because that Timeline has ended, SW_TL_ERROR_UNKNOWN is returned.</p>
<p><a class="el" href="group__timeline.html#gaee75ed447a1a7b8f95ebcf3f72d1614d" title="Potentially end a Timeline. Whether the Timeline End Event is issued immediately...">SwTimelineEnd()</a> and <a class="el" href="group__timeline.html#gaa1445a6682ed8e66a601959951d5cb2d" title="Potentially abort a Timeline. Whether the Timeline Abort Event is issued immediately...">SwTimelineAbort()</a> may not immediately end the Timeline, either because the Timeline has a higher priority child or a Handler has Handled the Timeline End/Abort Event. In such a case, SW_TL_ERROR_IN_USE is returned. Note that this is purely informational - the caller does not need to do anything else, responsibility for the Timeline is taken by the Handler or the Timeline system. </p>

</div>
</div>
<a class="anchor" id="ga61ccfbc6ffd1a12aa48a37a73414a3e7"></a><!-- doxytag: member="timelineapi.h::sw_tl_type" ref="ga61ccfbc6ffd1a12aa48a37a73414a3e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a> <a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handler considerations for Timeline Events. </p>
<p>The Timeline system issues many Events. Authors must be careful to attach their Handlers to the appropriate Events and return the correct return codes.</p>
<p>EVENT_TIMELINE_START The Timeline has started. The Timeline reference is now valid, and children can be attached. Handlers should return SW_EVENT_CONTINUE. However, if a Handler returns SW_EVENT_HANDLED the Timeline will be ended immediately and the caller of <a class="el" href="group__timeline.html#gaef4163e657c0cd4f510e5686e2669061" title="Create a Timeline, issuing a Start Event immediately.">SwTimelineStart()</a> will get a SW_TL_REF_INVALID reference returned.</p>
<p>EVENT_TIMELINE_TITLE The Timeline is about to be renamed. Handlers can change the title pointer and length in the Event message if they wish to modify the title change. They can remove the title by setting the pointer or length to zero, or retain the existing title by returning SW_EVENT_HANDLED. Normally they should return SW_EVENT_CONTINUE.</p>
<p>EVENT_TIMELINE_EXTEND The extent of the Timeline has changed. Handlers should return SW_EVENT_CONTINUE. Returning anything else will merely prevent other Handlers getting the Event - the change has already occured.</p>
<p>EVENT_TIMELINE_PROGRESS The Timeline progress has changed. Handlers should return SW_EVENT_CONTINUE. Returning anything else will merely prevent other Handlers getting the Event</p>
<ul>
<li>the change has already occured.</li>
</ul>
<p>EVENT_TIMELINE_ENDING The Timeline may be about to end - if there are no objections. Handlers should return SW_EVENT_CONTINUE normally to signal that that they do not object. If a Handler returns SW_EVENT_HANDLED however, the Timeline will be prolonged. It is then that Handler's responsibility to arrange for the Timeline to end. Note that multiple ENDING Events may be issued for a Timeline before all Handlers agree to the end.</p>
<p>EVENT_TIMELINE_ENDED The Timeline has ended. The Timeline reference will only continue to be valid for the duration of the Event and will be unknown thereafter. There will only be one EVENT_TIMELINE_ENDED or EVENT_TIMELINE_ABORTED Event issued for a Timeline.</p>
<p>EVENT_TIMELINE_ABORTING The Timeline may be about to abort if there are no objections. Handlers should normally return SW_EVENT_CONTINUE to allow the abort to occur. If a Handler returns SW_EVENT_HANDLED to object to the abort, the Timeline will nevertheless stay in an about-to-abort state, and further attempts will be made to abort at an appropriate time. The Handler does not gain ownership of the Timeline as it does when objecting to an EVENT_TIMELINE_ENDING event.</p>
<p>EVENT_TIMELINE_ABORTED The Timeline has aborted. The Timeline reference will only continue to be valid for the duration of the Event and will be unknown thereafter. There will only be one EVENT_TIMELINE_ENDED or EVENT_TIMELINE_ABORTED Event issued for a Timeline. Timeline types Timeline numbering follows the numbering conventions for DEVICETYPE numbers.</p>
<p>The range 0x00000000-0x0000ffff is reserved for Global Graphics. The range 0xXXXX0000-0xXXXXffff is reserved for customer number XXXX. The range 0xffff0000-0xffffffff is for private use in closed environments.</p>
<p>These ranges are sub-allocated here and elsewhere. </p>

</div>
</div>
<a class="anchor" id="ga5186a283db61b9276a111d9f37e61b3e"></a><!-- doxytag: member="timelineapi.h::sw_tl_unit" ref="ga5186a283db61b9276a111d9f37e61b3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a> <a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timeline units. </p>
<p>Each Timeline has an associated unit in which extent and progress is measured, if meaningful for that Timeline Type.</p>
<p>Timeline units follow the numbering conventions for DEVICETYPE numbers.</p>
<p>The range 0x00000000-0x0000ffff is reserved for Global Graphics. The range 0xXXXX0000-0xXXXXffff is reserved for customer number XXXX. The range 0xffff0000-0xfffffffe is for private use in closed environments.</p>
<p>These ranges are sub-allocated here and elsewhere. Other clients may use the values of the Global Graphics units defined contiguously from zero. These units will not change in future releases. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad63240694c6dc2a28c24bfc2db90ad7a"></a><!-- doxytag: member="timelineapi.h::@74" ref="gad63240694c6dc2a28c24bfc2db90ad7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Timeline states. </p>
<p>The existing state numbers will not change between releases. </p>

</div>
</div>
<a class="anchor" id="ga79e9f285d34216706a748fd7ba8941b7"></a><!-- doxytag: member="timelineapi.h::@76" ref="ga79e9f285d34216706a748fd7ba8941b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumeration of Timeline types reflecting the partition of type definitions for RIP components. </p>

</div>
</div>
<a class="anchor" id="ga70ad55be767ca0a42c9150d24618e4ca"></a><!-- doxytag: member="timelineapi.h::@79" ref="ga70ad55be767ca0a42c9150d24618e4ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caaac5b7024bd891d6d946d518f924701be"></a><!-- doxytag: member="SW_TL_SUCCESS" ref="gga70ad55be767ca0a42c9150d24618e4caaac5b7024bd891d6d946d518f924701be" args="" -->SW_TL_SUCCESS</em>&nbsp;</td><td>
<p>successful call </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caa68ac272ce85040f630f17e63acc639ad"></a><!-- doxytag: member="SW_TL_ERROR" ref="gga70ad55be767ca0a42c9150d24618e4caa68ac272ce85040f630f17e63acc639ad" args="" -->SW_TL_ERROR</em>&nbsp;</td><td>
<p>Some unknown failure occurred </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caa0540e34d9584cc14c4c12ebdd3b306c6"></a><!-- doxytag: member="SW_TL_ERROR_UNKNOWN" ref="gga70ad55be767ca0a42c9150d24618e4caa0540e34d9584cc14c4c12ebdd3b306c6" args="" -->SW_TL_ERROR_UNKNOWN</em>&nbsp;</td><td>
<p>Timeline ref is unknown (or has closed) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caa39e95e34891f283dc90fd642c9c93ec2"></a><!-- doxytag: member="SW_TL_ERROR_SYNTAX" ref="gga70ad55be767ca0a42c9150d24618e4caa39e95e34891f283dc90fd642c9c93ec2" args="" -->SW_TL_ERROR_SYNTAX</em>&nbsp;</td><td>
<p>Programming error - illegal parameters </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caa03246395df1d51db6b4ad2d2082e6fb5"></a><!-- doxytag: member="SW_TL_ERROR_IN_USE" ref="gga70ad55be767ca0a42c9150d24618e4caa03246395df1d51db6b4ad2d2082e6fb5" args="" -->SW_TL_ERROR_IN_USE</em>&nbsp;</td><td>
<p>Timeline has not yet ended as requested </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga70ad55be767ca0a42c9150d24618e4caabb9ba01baeb7b2547906b44b1b16585c"></a><!-- doxytag: member="SW_TL_ERROR_MEMORY" ref="gga70ad55be767ca0a42c9150d24618e4caabb9ba01baeb7b2547906b44b1b16585c" args="" -->SW_TL_ERROR_MEMORY</em>&nbsp;</td><td>
<p>Memory allocation failed </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa1445a6682ed8e66a601959951d5cb2d"></a><!-- doxytag: member="timelineapi.h::SwTimelineAbort" ref="gaa1445a6682ed8e66a601959951d5cb2d" args="(sw_tl_ref ref, int reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineAbort </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Potentially abort a Timeline. Whether the Timeline Abort Event is issued immediately depends on whether there are ongoing descendant Timelines of the same or higher priority. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference to abort</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A reason code for the abort, defined per Timeline type</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS if the Timeline has ended, SW_TL_ERROR_UNKNOWN if the Timeline is not known, or SW_TL_ERROR_IN_USE if the Timeline is being kept alive by a child or Handler</dd></dl>
<p>If the Timeline is prolonged by a descenant, it stays at pending-abort, and will attempt to abort again when that child ends. If prolonged by a Handler, it also stays at pending abort. This would be an unusual thing for a Handler to do.</p>
<p>If the Timeline does abort, it will also try to abort its parent if its parent's priority is lower than the priority of the aborting Timeline.</p>
<p>Note that if SW_TL_ERROR_IN_USE is returned, the Timeline is being prolonged. This means that the attached primary context must also continue to exist. For such contexts that must be discarded, it may be best to discard them in a default priority EVENT_TIMELINE_ABORTED Handler for that Timeline reference. </p>

</div>
</div>
<a class="anchor" id="gaee75ed447a1a7b8f95ebcf3f72d1614d"></a><!-- doxytag: member="timelineapi.h::SwTimelineEnd" ref="gaee75ed447a1a7b8f95ebcf3f72d1614d" args="(sw_tl_ref ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineEnd </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Potentially end a Timeline. Whether the Timeline End Event is issued immediately depends on whether there are ongoing descendant Timelines of the same or higher priority. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference to end</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS if the Timeline has ended, SW_TL_ERROR_UNKNOWN if the Timeline is not known, or SW_TL_ERROR_IN_USE if the Timeline is being kept alive by a child or Handler</dd></dl>
<p>The priority can be used to achieve automatic Timeline ending when subordinate Timelines end. The priority of the Timeline being ended is compared with all descendant Timelines, and if any are the same or higher, the Timeline will be prolonged.</p>
<p>If not, an EVENT_TIMELINE_ENDING event is issued. If no Handler objects by returning SW_EVENT_HANDLED, then the Timeline ends. If the Timeline's parent is waiting, it may end or abort also, depending on the priorities of other descendants. If a Handler does object then responsibility for ending the Timeline passes to the Handler.</p>
<p>Note that if SW_TL_ERROR_IN_USE is returned, the Timeline is being prolonged. This means that the attached primary context must also continue to exist. For such contexts that must be discarded, it may be best to discard them in a default priority EVENT_TIMELINE_ENDED Handler for that Timeline reference. </p>

</div>
</div>
<a class="anchor" id="ga7c7e5aa68988f7764068a39a4d02bda1"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetAncestor" ref="ga7c7e5aa68988f7764068a39a4d02bda1" args="(sw_tl_ref ref, sw_tl_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_tl_ref SwTimelineGetAncestor </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the NEAREST ancestor of the Timeline of the specified type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of ancestor to find, or SW_TL_TYPE_ANY to find immediate parent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Timeline reference of the parent, or SW_TL_REF_INVALID</dd></dl>
<p>This can be used to find the immediate parent of a Timeline, if it has one, or to find a Timeline's ancestor of a particular known type.</p>
<p>This allows something that cares about Job Timelines, for example, to find out whether a particular message Event belongs to its job. Note however that it may in principle be possible for there to be multiple nested Job Timelines, so the first Job parent found may itself be a child of the Job Timeline in question.</p>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="ga169b6dbc3d797fe153b2f55787b450de"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetContext" ref="ga169b6dbc3d797fe153b2f55787b450de" args="(sw_tl_ref ref, sw_tl_context id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SwTimelineGetContext </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a>&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a context from the Timeline. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>Unique identifier for context. Zero for Timeline creator's primary context</td></tr>
  </table>
  </dd>
</dl>
<p>returns The pointer registered with that identifier, or null</p>
<p>The Timeline system places no interpretation on these contexts, they are for client use. Note that NULL is returned if the Timeline reference or context id is not known.</p>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="ga987a088199569961ed49a771fabe7cb6"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetPriority" ref="ga987a088199569961ed49a771fabe7cb6" args="(sw_tl_ref ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a> SwTimelineGetPriority </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Timeline priority if known. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The priority of the Timeline if known, or SW_TL_PRIORITY_UNKNOWN</dd></dl>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="gaed87b66c01741b285e2848b660db43bf"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetProgress" ref="gaed87b66c01741b285e2848b660db43bf" args="(sw_tl_ref ref, sw_tl_extent *start, sw_tl_extent *end, sw_tl_extent *progress, sw_tl_unit *unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineGetProgress </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a> *&nbsp;</td>
          <td class="paramname"> <em>unit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the extent, unit and progress through a Timeline. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>If not null, this is filled in with the extent start</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>end</em>&nbsp;</td><td>If not null, this is filled in with the extent end</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>progress</em>&nbsp;</td><td>If not null, this is filled in with the progress</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>unit</em>&nbsp;</td><td>If not null, this is filled in with the unit</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS normally, SW_TL_ERROR_UNKNOWN if the Timeline is not known</dd></dl>
<p>An extent end of SW_TL_EXTENT_INDETERMINATE means the Timeline is not of a known length. The progress and unit may still be informational.</p>
<p>This call does not issue an Event </p>

</div>
</div>
<a class="anchor" id="gafcb31d3652b8079c24bbb785c6c7eb7f"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetTitle" ref="gafcb31d3652b8079c24bbb785c6c7eb7f" args="(sw_tl_ref ref, uint8 *buffer, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SwTimelineGetTitle </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Timeline's title and length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>If not null, this is filled in with the title, space permitting</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the supplied buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual length of the title</dd></dl>
<p>This call allows the Timeline's title to be retrieved. It can be called with a null buffer pointer to find the length of the title so a suitable buffer can be allocated before calling this function again, but be prepared for the title to be changed by another thread between the calls.</p>
<p>If the returned title length is greater than the buffer size passed in, the title returned will have been truncated.</p>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="gacd4fa34dd20137cd5b963489e7991614"></a><!-- doxytag: member="timelineapi.h::SwTimelineGetType" ref="gacd4fa34dd20137cd5b963489e7991614" args="(sw_tl_ref ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a> SwTimelineGetType </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Timeline type if known. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The type of the Timeline if known, or SW_TL_TYPE_NONE</dd></dl>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="ga9aba6c2972cfaca924cee63bc527f66b"></a><!-- doxytag: member="timelineapi.h::SwTimelineOfType" ref="ga9aba6c2972cfaca924cee63bc527f66b" args="(sw_tl_ref ref, sw_tl_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_tl_ref SwTimelineOfType </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure the Timeline or an ancestor is of the given type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of Timeline to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Timeline reference of that type, or SW_TL_REF_INVALID</dd></dl>
<p>This is similar to SwTimelineGetAncestor, but can return the Timeline passed in and does not accept SW_TL_TYPE_ANY as a parameter.</p>
<p>If the Timeline passed in and all of its ancestors are not of the required type, SW_TL_REF_INVALID is returned.</p>
<p>It is equivalent to: </p>
<div class="fragment"><pre class="fragment">   type = <a class="code" href="group__timeline.html#gacd4fa34dd20137cd5b963489e7991614" title="Return the Timeline type if known.">SwTimelineGetType</a>(ref) ;
   <span class="keywordflow">if</span> (type == SW_TL_TYPE_NONE)
     ref = SW_TL_REF_INVALID ;
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type != requiredType)
     ref = <a class="code" href="group__timeline.html#ga7c7e5aa68988f7764068a39a4d02bda1" title="Return the NEAREST ancestor of the Timeline of the specified type.">SwTimelineGetAncestor</a>(ref, requiredType) ;
</pre></div><p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="ga3ff8c8ff573a862e77f1215f52c0cd62"></a><!-- doxytag: member="timelineapi.h::SwTimelineSetContext" ref="ga3ff8c8ff573a862e77f1215f52c0cd62" args="(sw_tl_ref ref, sw_tl_context id, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineSetContext </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#gaaf625e19c8ca5dc9fb654e8590d79ffe">sw_tl_context</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach a secondary context to a Timeline. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>Unique identifier for context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The context pointer to attach to the Timeline, or null</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_TL_SUCCESS</em>&nbsp;</td><td>The context was attached to the timeline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_TL_ERROR_UNKNOWN</em>&nbsp;</td><td>If the Timeline is not known </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_TL_ERROR_SYNTAX</em>&nbsp;</td><td>If an attempt was made to change the owner context (identifier zero).</td></tr>
  </table>
  </dd>
</dl>
<p>The Timeline system places no interpretation on these contexts, they are for client use. Context management is not performed by the Timeline system, and these contexts can only be retrieved using this call while the Timeline continues to exist.</p>
<p>Note: Entities that wish to associate a context with a Timeline that will outlive the Timeline itself should register the context with RDR using a Class of RDR_CLASS_TIMELINE, the Timeline reference as the RDR Type, and their context identifier as the RDR ID. Such an RDR will have to be manually deregistered when the Timeline ends (though not necessarily immediately).</p>
<p>This call does not issue an Event. </p>

</div>
</div>
<a class="anchor" id="ga57b698c88d63fc097c2b00217f5e5747"></a><!-- doxytag: member="timelineapi.h::SwTimelineSetExtent" ref="ga57b698c88d63fc097c2b00217f5e5747" args="(sw_tl_ref ref, sw_tl_extent start, sw_tl_extent end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineSetExtent </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a>&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extend the length of the Timeline. Issues an Event for a nonzero change. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>New start of the Timeline extent</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>New end of the Timeline extent, or SW_TL_EXTENT_INDETERMINATE</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS normally, SW_TL_ERROR_UNKNOWN if the Timeline is not known</dd></dl>
<p>A Timeline created with an end of SW_TL_EXTENT_INDETERMINATE will not be represented by a GUI as having a known length.</p>
<p>An EVENT_TIMELINE_EXTEND event will be issued. The Timeline system ignores the return code from this event. </p>

</div>
</div>
<a class="anchor" id="gaa6e0795673ed0e3451c6a849d8f09f9a"></a><!-- doxytag: member="timelineapi.h::SwTimelineSetProgress" ref="gaa6e0795673ed0e3451c6a849d8f09f9a" args="(sw_tl_ref ref, sw_tl_extent progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineSetProgress </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the progress of the Timeline, in the units given when the Timeline was started. Issues an Event if the current value changes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Current progress value, automatically extending the Timeline extent if it is outside that range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS normally, SW_TL_ERROR_UNKNOWN if the Timeline is not known</dd></dl>
<p>Progressing beyond the current Timeline extent automatically extends the extent, unless the end is at SW_TL_EXTENT_INDETERMINATE.</p>
<p>A Handler may choose to reflect the progress of a child Timeline in the parent Timeline, eg by reducing the parent's extent start by some amount, and then updating the parent's progress accordingly.</p>
<p>An EVENT_TIMELINE_PROGRESS event is issued. The Timeline system ignores the return code from this event. </p>

</div>
</div>
<a class="anchor" id="gaa6505f8140b1c12f562eb93d21d05694"></a><!-- doxytag: member="timelineapi.h::SwTimelineSetTitle" ref="gaa6505f8140b1c12f562eb93d21d05694" args="(sw_tl_ref ref, uint8 *title, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__timeline.html#ga91d0370ec5a7091e1717d91e51c62bf0">sw_tl_result</a> SwTimelineSetTitle </td>
          <td>(</td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the title of a Timeline. Issues an Event before changing the title. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>Timeline reference to rename</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>title</em>&nbsp;</td><td>Pointer to a string, or null to remove the name</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the unterminated string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_TL_SUCCESS normally, SW_TL_ERROR_UNKNOWN if the Timeline is not known</dd></dl>
<p>The title will be copied so does not need to be maintained.</p>
<p>An EVENT_TIMELINE_TITLE event is issued. A Handler may choose to modify the title or suppress it by changing the pointer and length in the Event Message. If a Handler returns SW_EVENT_HANDLED, no title change occurs at all. </p>

</div>
</div>
<a class="anchor" id="gaef4163e657c0cd4f510e5686e2669061"></a><!-- doxytag: member="timelineapi.h::SwTimelineStart" ref="gaef4163e657c0cd4f510e5686e2669061" args="(sw_tl_type type, sw_tl_ref parent, sw_tl_extent start, sw_tl_extent end, sw_tl_unit unit, sw_tl_priority priority, void *context, uint8 *title, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_tl_ref SwTimelineStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga61ccfbc6ffd1a12aa48a37a73414a3e7">sw_tl_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw_tl_ref&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga298435e7f3b67a0a845bdd0c6c7cb7c0">sw_tl_extent</a>&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#ga5186a283db61b9276a111d9f37e61b3e">sw_tl_unit</a>&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timeline.html#gadcdf9f678aff874e7d8e6bb139fb7817">sw_tl_priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Timeline, issuing a Start Event immediately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Timeline type, such as Job, Document, Interpret, Render</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>ID of parent Timeline, or SW_TL_REF_INVALID for an autonomous Timeline</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start of the Timeline extent in some units, eg total bytes, number of pages. Often zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>End of the Timeline extent, or SW_TL_EXTENT_INDETERMINATE</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td>Unit of the above extent, eg Bytes, Pages, Lines</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>Used to resolve Ending a Timeline with ongoing child Timelines</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The primary context supplied by the Timeline owner</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>title</em>&nbsp;</td><td>A title for the Timeline. Could be leafname, page title or job phase</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the title</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new Timeline reference or SW_TL_REF_INVALID if it fails.</dd></dl>
<p>A Timeline that has no concept of length, for which progress has no real meaning, should have an extent end of SW_TL_EXTENT_INDETERMINATE. A GUI may represent this as an indeterminate progress bar instead of a standard progress bar.</p>
<p>A EVENT_TIMELINE_START event is issued immediately after creating the Timeline. If a Handler returns SW_EVENT_HANDLED the Timeline is immediately ended and SW_TL_REF_INVALID will be returned to the creator.</p>
<p>See <a class="el" href="group__timeline.html#gaee75ed447a1a7b8f95ebcf3f72d1614d" title="Potentially end a Timeline. Whether the Timeline End Event is issued immediately...">SwTimelineEnd()</a> for usage of the priority parameter.</p>
<p>The title is copied so need not be maintained.</p>
<p>The supplied context is delivered in Timeline Events and is identified by context id zero. It can be retrieved with <a class="el" href="group__timeline.html#ga169b6dbc3d797fe153b2f55787b450de" title="Return a context from the Timeline.">SwTimelineGetContext()</a> but cannot be changed - Timeline events can occur at any time and in other threads, so changing this primary context would invalidate events currently in flow. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
