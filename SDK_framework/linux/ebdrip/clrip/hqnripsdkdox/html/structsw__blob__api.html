<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sw_blob_api Struct Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sw_blob_api Struct Reference<br/>
<small>
[<a class="el" href="group__swblobapi.html">Binary large object callback API</a>]</small>
</h1><!-- doxytag: class="sw_blob_api" -->
<p>A structure containing callback functions for BLOB (Binary Large Object) access.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;swblobapi.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__api__info.html">sw_api_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version number, name, display name, instance size.  <a href="#ab716503b26170e15c9990c190bd2e175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a3ad94883ca354473db4597658933cf3d">open</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, int mode, <a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **reference)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a retainable reference to a blob data source.  <a href="#a3ad94883ca354473db4597658933cf3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a03deea78bc7a39ea5d0d2307c150f7fe">close</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **blob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a blob reference, releasing its resources.  <a href="#a03deea78bc7a39ea5d0d2307c150f7fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a96d7bfdc0a55c74eaa5b95045e7ca072">length</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the length of a blob.  <a href="#a96d7bfdc0a55c74eaa5b95045e7ca072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#ad07cd3150ef3706da1efe98bb005a6c1">read</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, void *buffer, size_t byteswanted, size_t *bytesread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a buffer of data from the current position in a blob.  <a href="#ad07cd3150ef3706da1efe98bb005a6c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#ad694af86ff3f4d81279022431bf60fc5">write</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, void *buffer, size_t bytestowrite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a buffer of data at the current position in a blob.  <a href="#ad694af86ff3f4d81279022431bf60fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a0f2d45197630949f5f2a457b9b598779">seek</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="structHq32x2.html">Hq32x2</a> where, int offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the blob's current position.  <a href="#a0f2d45197630949f5f2a457b9b598779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#ae40dd2ac5f4ff14850ac16e24582778e">tell</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="structHq32x2.html">Hq32x2</a> *where)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the current position in the blob.  <a href="#ae40dd2ac5f4ff14850ac16e24582778e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#abf8d565d7d39c42b7a414060183e4642">protection</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="group__swblobapi.html#gad33ca021c494e5b1e491a73e9fac203b">sw_blob_protection</a> *<a class="el" href="structsw__blob__api.html#abf8d565d7d39c42b7a414060183e4642">protection</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the type of protection used for the blob data.  <a href="#abf8d565d7d39c42b7a414060183e4642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a787970bb6b5eda149027dd054392bdcf">map_open</a> )(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="structsw__blob__map.html">sw_blob_map</a> **map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a memory mapping context for a blob.  <a href="#a787970bb6b5eda149027dd054392bdcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#aa48bb7fe64eddee5ff8eb1c5669a2f50">map_region</a> )(<a class="el" href="structsw__blob__map.html">sw_blob_map</a> *map, <a class="el" href="structHq32x2.html">Hq32x2</a> start, size_t <a class="el" href="structsw__blob__api.html#a96d7bfdc0a55c74eaa5b95045e7ca072">length</a>, size_t alignment, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **mapping)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map a section of a blob into a contiguous block of memory.  <a href="#aa48bb7fe64eddee5ff8eb1c5669a2f50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__blob__api.html#a776617d1e01c6c910744684617279f7a">map_close</a> )(<a class="el" href="structsw__blob__map.html">sw_blob_map</a> **map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a memory mapping context for a blob.  <a href="#a776617d1e01c6c910744684617279f7a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A structure containing callback functions for BLOB (Binary Large Object) access. </p>
<p>The rip provides the module with an API that can be used to access data sources through either a memory mapping interface or a file-like API. Where possible, the module should use the memory mapping interface to directly read data, because the RIP may be able to use zero-copy techniques to provide data. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a03deea78bc7a39ea5d0d2307c150f7fe"></a><!-- doxytag: member="sw_blob_api::close" ref="a03deea78bc7a39ea5d0d2307c150f7fe" args=")(sw_blob_instance **blob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__blob__api.html#a03deea78bc7a39ea5d0d2307c150f7fe">close</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **blob)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a blob reference, releasing its resources. </p>
<p>Note that it is permissible to close a blob before its memory mapping contexts are closed, however any resources used by the blob will not actually be released until the last mapping context is closed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>A pointer to the blob reference to be closed. The blob reference is invalidated by this call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab716503b26170e15c9990c190bd2e175"></a><!-- doxytag: member="sw_blob_api::info" ref="ab716503b26170e15c9990c190bd2e175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__api__info.html">sw_api_info</a> <a class="el" href="structsw__blob__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Version number, name, display name, instance size. </p>
<p>This is REQUIRED to be the first field. </p>

</div>
</div>
<a class="anchor" id="a96d7bfdc0a55c74eaa5b95045e7ca072"></a><!-- doxytag: member="sw_blob_api::length" ref="a96d7bfdc0a55c74eaa5b95045e7ca072" args=")(sw_blob_instance *blob, Hq32x2 *bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#a96d7bfdc0a55c74eaa5b95045e7ca072">length</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,<a class="el" href="structHq32x2.html">Hq32x2</a> *bytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the length of a blob. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob whose length is to be found.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>On exit, the length of the blob. The total length of a blob may not be available if the underlying data source is streamed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the length was available, in which case the <em>bytes</em> parameter contains the length of the data source.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the length of the blob was not available, in which case the <em>bytes</em> parameter is not modified.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source has expired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a776617d1e01c6c910744684617279f7a"></a><!-- doxytag: member="sw_blob_api::map_close" ref="a776617d1e01c6c910744684617279f7a" args=")(sw_blob_map **map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__blob__api.html#a776617d1e01c6c910744684617279f7a">map_close</a>)(<a class="el" href="structsw__blob__map.html">sw_blob_map</a> **map)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a memory mapping context for a blob. </p>
<p>If <code><a class="el" href="structsw__blob__api.html#a787970bb6b5eda149027dd054392bdcf" title="Open a memory mapping context for a blob.">map_open()</a></code> succeeded, this method MUST be called to delete the memory mapping context. Calling this method allows the RIP to reclaim allocated buffers in the memory mapping context.</p>
<p>Note that it is permissible to close a blob before its memory mapping contexts are closed, however any resources required by the blob will not actually be released until the last mapping context is closed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>map</em>&nbsp;</td><td>The memory mapping context to be closed. The mapping context is invalidated by this call.</td></tr>
  </table>
  </dd>
</dl>
<p>After this call, any pointers returned by the <code><a class="el" href="structsw__blob__api.html#aa48bb7fe64eddee5ff8eb1c5669a2f50" title="Map a section of a blob into a contiguous block of memory.">map_region()</a></code> method in this context must not be dereferenced. </p>

</div>
</div>
<a class="anchor" id="a787970bb6b5eda149027dd054392bdcf"></a><!-- doxytag: member="sw_blob_api::map_open" ref="a787970bb6b5eda149027dd054392bdcf" args=")(sw_blob_instance *blob, sw_blob_map **map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#a787970bb6b5eda149027dd054392bdcf">map_open</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,<a class="el" href="structsw__blob__map.html">sw_blob_map</a> **map)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a memory mapping context for a blob. </p>
<p>The blob memory mapping interface allows clients to request access to regions of data which can be accessed directly through memory pointers. If possible, the RIP will provide these pointers without copying data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob which to which the subsequent memory mapping operations apply.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>map</em>&nbsp;</td><td>On a successful exit, an open memory mapping context will be stored here.</td></tr>
  </table>
  </dd>
</dl>
<p>Multiple memory map contexts may be opened on the same blob simultaneously. All mappings created in a context will remain valid until the corresponding <code><a class="el" href="structsw__blob__api.html#a776617d1e01c6c910744684617279f7a" title="Close a memory mapping context for a blob.">map_close()</a></code> call, after which they will cease to be be valid and pointers to the mapped memory must not be dereferenced. The RIP will allocate and deallocate memory as necessary to map requested sections of a blob. Modules must not modify RIP memory returned by the memory mapping API.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the mapping context was created successfully.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_MEMORY</em>&nbsp;</td><td>Returned if the RIP cannot allocate a blob mapping context.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the underlying data source cannot be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is out of scope.</td></tr>
  </table>
  </dd>
</dl>
<p>If the <code><a class="el" href="structsw__blob__api.html#a787970bb6b5eda149027dd054392bdcf" title="Open a memory mapping context for a blob.">map_open()</a></code> call succeeds, a corresponding <code><a class="el" href="structsw__blob__api.html#a776617d1e01c6c910744684617279f7a" title="Close a memory mapping context for a blob.">map_close()</a></code> call MUST be made when the access to the mapped sections is complete, to allow the RIP to recover the resources associated with the mapping context.</p>
<p>It is permissable to close a blob reference which has open memory mapping contexts, and continue to use the memory mapping contexts. In this case, resources used by the blob will not be released until the last memory mapping context is closed. </p>

</div>
</div>
<a class="anchor" id="aa48bb7fe64eddee5ff8eb1c5669a2f50"></a><!-- doxytag: member="sw_blob_api::map_region" ref="aa48bb7fe64eddee5ff8eb1c5669a2f50" args=")(sw_blob_map *map, Hq32x2 start, size_t length, size_t alignment, uint8 **mapping)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#aa48bb7fe64eddee5ff8eb1c5669a2f50">map_region</a>)(<a class="el" href="structsw__blob__map.html">sw_blob_map</a> *map, <a class="el" href="structHq32x2.html">Hq32x2</a> start, size_t <a class="el" href="structsw__blob__api.html#a96d7bfdc0a55c74eaa5b95045e7ca072">length</a>, size_t alignment,<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **mapping)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map a section of a blob into a contiguous block of memory. </p>
<p>This call ensures that a section of the blob starting at the specified start address and with the specified length is mapped into memory, and returns a pointer to the memory in which the blob is mapped. The data mapping will not copy data if possible, but if different alignments are requested, natural boundaries in the underlying data source are crossed, or overlapping regions are mapped, the data may be copied into temporary buffers managed by the RIP. All mapping pointers are invalid as soon as the memory mapping context is closed, and must not be dereferenced.</p>
<p>Memory mapping a region does not modify the current blob position.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>map</em>&nbsp;</td><td>The memory mapping context in which the mapping is to be made.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>start</em>&nbsp;</td><td>The start location of the data to be mapped in the blob.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data region to be mapped.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alignment</em>&nbsp;</td><td>This parameter determines how the returned data pointer should be aligned. A value of SW_BLOB_ALIGNMENT_NONE indicates that any alignment is acceptable. The value SW_BLOB_ALIGNMENT_16BIT is used for 16-bit alignment, SW_BLOB_ALIGNMENT_32BIT for 32-bit alignment, and SW_BLOB_ALIGNMENT_64BIT for 64-bit alignment. For types of these sizes, the alignment enumeration values are the same as <code>sizeof(type)</code>.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>mapping</em>&nbsp;</td><td>After a successful exit, a pointer to a contiguous block of memory containing the data requested, aligned as requested, is stored in this location. The pointer remains valid until the mapping context is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the mapping is made successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_MEMORY</em>&nbsp;</td><td>Returned if the RIP cannot allocate a mapping buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EOF</em>&nbsp;</td><td>Returned if the mapping extends beyond the end of the underlying data source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the mapping context, mapping location pointer, or the alignment parameter are invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is out of scope. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ad94883ca354473db4597658933cf3d"></a><!-- doxytag: member="sw_blob_api::open" ref="a3ad94883ca354473db4597658933cf3d" args=")(sw_blob_instance *blob, int mode, sw_blob_instance **reference)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#a3ad94883ca354473db4597658933cf3d">open</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, int mode,<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **reference)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a retainable reference to a blob data source. </p>
<p>This method should be used whenever a module wishes to retain a reference to a blob after the end of the call that supplied it. Data sources supplied by the RIP are automatically invalidated at the end of the method that passed them to a module.</p>
<p>If the data source backing the blob becomes invalid before the blob is closed, then all of the API calls referring to the blob or to memory maps opened from it will return error codes (SW_BLOB_ERROR_EXPIRED usually).</p>
<p>A module should release all references to a blob as soon as possible to ensure best performance.</p>
<p>This method can also be used to request a different set of access permissions for a blob.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>An existing blob data source.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>An access mode composed of one of SW_RDWR, SW_WRONLY, or SW_RDONLY, possibly combined with the flags SW_EXCL and SW_FONT defined in <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>reference</em>&nbsp;</td><td>A pointer in which the new blob reference will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the blob was opened, in which case the <em>reference</em> parameter is updated with a reference to the blob. The <code><a class="el" href="structsw__blob__api.html#a03deea78bc7a39ea5d0d2307c150f7fe" title="Close a blob reference, releasing its resources.">close()</a></code> call must be called when the module no longer needs the blob to allow the RIP to deallocate the resources used by the blob.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_MEMORY</em>&nbsp;</td><td>Returned if the RIP cannot allocate a blob reference.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the access mode does not match the capability of the underlying data source. Some blob implementations may check access lazily, and may allow creation of blob references which cannot be accessed for read and/or write. Such an implementation may return SW_BLOB_OK to this method call, but fail with SW_BLOB_ERROR_ACCESS later.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the <em>blob</em> parameter is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the <em>blob</em> parameter has passed out of scope. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf8d565d7d39c42b7a414060183e4642"></a><!-- doxytag: member="sw_blob_api::protection" ref="abf8d565d7d39c42b7a414060183e4642" args=")(sw_blob_instance *blob, sw_blob_protection *protection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#abf8d565d7d39c42b7a414060183e4642">protection</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,<a class="el" href="group__swblobapi.html#gad33ca021c494e5b1e491a73e9fac203b">sw_blob_protection</a> *<a class="el" href="structsw__blob__api.html#abf8d565d7d39c42b7a414060183e4642">protection</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the type of protection used for the blob data. </p>
<p>The protection type is an integer, representing the type of encryption or protection of the original blob source. The value of 0 indicates no protection. Values in the range 1-255 are reserved for use by Global Graphics.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob whose protection type is to be found.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>protection</em>&nbsp;</td><td>One of the sw_blob_protection enumeration values.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the blob was valid, in which case the type of protection is stored in the <em>protection</em> parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is out of scope. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad07cd3150ef3706da1efe98bb005a6c1"></a><!-- doxytag: member="sw_blob_api::read" ref="ad07cd3150ef3706da1efe98bb005a6c1" args=")(sw_blob_instance *blob, void *buffer, size_t byteswanted, size_t *bytesread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#ad07cd3150ef3706da1efe98bb005a6c1">read</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,void *buffer, size_t byteswanted,size_t *bytesread)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a buffer of data from the current position in a blob. </p>
<p>This call fills a buffer with bytes read from the current position of the blob, updating the current position to point after the bytes read. It will return less than the requested number of bytes only if the end of the data source was encountered, or an error occurred.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob from which to read data.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer into which the data will be read.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byteswanted</em>&nbsp;</td><td>The number of bytes to read. The caller is responsible for making sure the buffer is at least this size.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bytesread</em>&nbsp;</td><td>On a successful exit, the number of bytes actually read from the blob is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if bytes were read from the blob without an error occurring. The <em>bytesread</em> parameter will be updated with the amount of data actually stored in the buffer. The <code><a class="el" href="structsw__blob__api.html#ad07cd3150ef3706da1efe98bb005a6c1" title="Read a buffer of data from the current position in a blob.">read()</a></code> function will try to fully satisfy the read request; the only time fewer than the requested number of bytes will be returned is when the request spans the end of the data stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EOF</em>&nbsp;</td><td>If there is no data left to read, this will be returned, and a value of zero will be stored in the <em>bytesread</em> field.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is no longer valid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the blob does not support read access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f2d45197630949f5f2a457b9b598779"></a><!-- doxytag: member="sw_blob_api::seek" ref="a0f2d45197630949f5f2a457b9b598779" args=")(sw_blob_instance *blob, Hq32x2 where, int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#a0f2d45197630949f5f2a457b9b598779">seek</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob, <a class="el" href="structHq32x2.html">Hq32x2</a> where, int offset)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adjust the blob's current position. </p>
<p>Some blob implementations may lazily update the position in the underlying data source, and so may return success for this method, but fail on a subsequent read or a write.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob whose current position is to be set.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>where</em>&nbsp;</td><td>The new current position of the blob, relative to the <em>offset</em>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>One of the constants SW_SET, SW_INCR, or SW_XTND, defined in <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>. The <em>offset</em> indicates whether the position set is relative to the start, current position, or end of the underlying data source respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the position was successfully updated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is out of scope.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EOF</em>&nbsp;</td><td>Returned if the position is set beyond the end of the data source, and the blob is not writable (if it is, the data source will be extended as necessary).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the underlying data source is not seekable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae40dd2ac5f4ff14850ac16e24582778e"></a><!-- doxytag: member="sw_blob_api::tell" ref="ae40dd2ac5f4ff14850ac16e24582778e" args=")(sw_blob_instance *blob, Hq32x2 *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#ae40dd2ac5f4ff14850ac16e24582778e">tell</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,<a class="el" href="structHq32x2.html">Hq32x2</a> *where)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the current position in the blob. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob whose current position is to be found.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>where</em>&nbsp;</td><td>On a successful exit, the current position in the blob is stored here.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the blob was valid, in which case the location is stored in the <em>where</em> parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is out of scope. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad694af86ff3f4d81279022431bf60fc5"></a><!-- doxytag: member="sw_blob_api::write" ref="ad694af86ff3f4d81279022431bf60fc5" args=")(sw_blob_instance *blob, void *buffer, size_t bytestowrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swblobapi.html#ga6242c2eb25bdb5835a67f73c6ff9ccd5">sw_blob_result</a>( * <a class="el" href="structsw__blob__api.html#ad694af86ff3f4d81279022431bf60fc5">write</a>)(<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> *blob,void *buffer, size_t bytestowrite)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a buffer of data at the current position in a blob. </p>
<p>This call stores a buffer of bytes at the current position in the blob, updating the current position to point after the bytes written. It will only write less than the requested number of bytes if an error occurred.</p>
<p>Note that blobs cannot be written to if any memory mapping contexts of any blob instances are mapped onto the underlying data source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>The blob to which data is written.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer from which the data will be written.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytestowrite</em>&nbsp;</td><td>The number of bytes to write. The caller is responsible for making sure the buffer is at least this size.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_OK</em>&nbsp;</td><td>Returned if the write request was fully completed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_INVALID</em>&nbsp;</td><td>Returned if the blob instance is invalid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_EXPIRED</em>&nbsp;</td><td>Returned if the underlying data source is no longer valid.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_BLOB_ERROR_ACCESS</em>&nbsp;</td><td>Returned if the blob does not support write access, or if any memory mapping contexts are currently open on the blob. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="swblobapi_8h.html">swblobapi.h</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
