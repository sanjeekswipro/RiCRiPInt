<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: file.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_30ea0f072a45d4235daf97fe839164a5.html">export</a>
  </div>
</div>
<div class="contents">
<h1>file.h File Reference</h1>
<p>Platform file abstraction. Each platform can have its own implementation of these functions.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="pfile_8h.html">pfile.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a8ace592c26cb31670dfaa91035108123">LONGESTFILENAME</a>&nbsp;&nbsp;&nbsp;2048</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41af9a6b04a9decd18c6fed8dead4d60"></a><!-- doxytag: member="file.h::FileDesc" ref="a41af9a6b04a9decd18c6fed8dead4d60" args="" -->
typedef struct <a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque file descriptor structure which hides platform-specific content. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78">PKError</a> { <br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78ae5ba56d9a6fda4ea383f3bf3119888e0">PKErrorNone</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a99ae2abfae83950bdbf9a96fe9d4b317">PKErrorUnknown</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a4852d3ad3e571f6d96ba56994191dca3">PKErrorParameter</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78aa9863aaef3010dac34f9ed8fbfb48a1e">PKErrorPointerNull</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a992e9620b8f8482b491a44fff9772e3b">PKErrorNumericRange</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a5e1f6cde9d35bf479e146ed039eaed8c">PKErrorNumericValue</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a3ac5a7b4458a0203f2298c8362a17121">PKErrorStringEmpty</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a13d66df4134b34a99c369676c4509c5e">PKErrorStringLength</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a11158d94eefa2b43fe842ad94ebfed2a">PKErrorStringSyntax</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a0124eca1d373dc197cd8e2ff00701161">PKErrorStringValue</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a6591d7fbe87cfe8df1511dde8a39a3cb">PKErrorOperationDenied</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78ae2208d3b246984d9485dcb8ce1329d6f">PKErrorNonExistent</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a2e5e20f2923e466f43829f6939ec20d8">PKErrorAlreadyExists</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a72bcf9e31267d187c99c5d946a26f505">PKErrorAccessDenied</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a2930022e241a72f5b968550cbbe894ca">PKErrorInUse</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78ac66007a1068c3a1156d875cadba57d3d">PKErrorOperationFailed</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a7afcfdd7322cda9635558853c4049b7f">PKErrorAbort</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78afb869909835d97c749fec4cec30019cc">PKErrorNoMemory</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a1243451790a5d77d7461f7cf73f4ab3b">PKErrorDiskFull</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78af2ef98de21f0ee48fd0eb24d2e003826">PKErrorSoftwareLimit</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a93a4c2d53a2e869268a21c5cbc122341">PKErrorHardware</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a08f0fef06fbdb6a0e63d686e006a24ac">PKErrorUnimplemented</a>, 
<a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78a9144a626e73b31b167cbfde8a7fe4063">PKErrorFatal</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This set of error returns should cover most cases -- at least enough for the RIP to extract the information it needs from this platform abstraction layer. </p>
 <a href="file_8h.html#a40e0b71584507e90147bebd129162e78">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a01a056c0cc20034d8f6faa7b78e4ade0">PKAppDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pAppDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy, into the buffer provided, the directory in which the application executable lives. This directory will be terminated with a directory separator.  <a href="#a01a056c0cc20034d8f6faa7b78e4ade0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#ae0715327bf4e9a71279090ecc5b558c7">PKCurrDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pCurrDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy into the buffer provided the directory in which the application is running. This directory will be terminated with a directory separator. On the Classic Mac, which has no concept of current dir, this is the same as <a class="el" href="file_8h.html#a01a056c0cc20034d8f6faa7b78e4ade0" title="Copy, into the buffer provided, the directory in which the application executable...">PKAppDir()</a>.  <a href="#ae0715327bf4e9a71279090ecc5b558c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a1320044f195253b505d017b1fa765320">PKSWDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pSWDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy into the buffer provided the SW directory name. This directory will be terminated with a directory separator.  <a href="#a1320044f195253b505d017b1fa765320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#ae23f216f3ebedbae08f16cef9afb6f5f">KSetSWDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pSWDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record an explicit path to the SW folder, overriding any default search rules.  <a href="#ae23f216f3ebedbae08f16cef9afb6f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a9a4c2134484bd40d72f62f7fc12b8704">KGetSWDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pSWDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an explicit path to the SW folder, taking into account any path set using <a class="el" href="filedev_8c.html#ae23f216f3ebedbae08f16cef9afb6f5f" title="Record an explicit path to the SW folder, overriding any default search rules.">KSetSWDir()</a>.  <a href="#a9a4c2134484bd40d72f62f7fc12b8704"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a3dc720adcdcfb7fb1b643966de313abc">PKParseRoot</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pOutput, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ppInput)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the root part of an absolute filename <code>*ppInput</code>.  <a href="#a3dc720adcdcfb7fb1b643966de313abc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#abbb33270cb4584b82287016cc13420e7">PKBuildRoot</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pOutput, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pInput)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs the inverse of <a class="el" href="file_8h.html#a3dc720adcdcfb7fb1b643966de313abc" title="Parse the root part of an absolute filename *ppInput.">PKParseRoot()</a>, and builds a complete root part of a platform dependent filename from the variable part as previously output by <a class="el" href="file_8h.html#a3dc720adcdcfb7fb1b643966de313abc" title="Parse the root part of an absolute filename *ppInput.">PKParseRoot()</a>.  <a href="#abbb33270cb4584b82287016cc13420e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35765feb28091ed0b82920d6e045a922"></a><!-- doxytag: member="file.h::PKMakePSFilename" ref="a35765feb28091ed0b82920d6e045a922" args="(uint8 *filename, uint8 *psFilename)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a35765feb28091ed0b82920d6e045a922">PKMakePSFilename</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *psFilename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an absolute or relative filename to an absolute PostScript filename. Relative filenames are made absolute by prefixing the current working directory as returned by <a class="el" href="file_8h.html#ae0715327bf4e9a71279090ecc5b558c7" title="Copy into the buffer provided the directory in which the application is running....">PKCurrDir()</a> above. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5">PKOpenFile</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a file, with the given flags. (Flags are from <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>.).  <a href="#aa6e1475115f69ad6c43daf505a608aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#aff248b6001f2f90d3a27d46d40ebeaf8">PKReadFile</a> (<a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *pDescriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a specified number of bytes from a file into a buffer.  <a href="#aff248b6001f2f90d3a27d46d40ebeaf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#ad54fd9715b0bb4c2549cc4eacb6d2ac9">PKWriteFile</a> (<a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *pDescriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a specified number of bytes from a buffer into a file.  <a href="#ad54fd9715b0bb4c2549cc4eacb6d2ac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a2108b20a6b8963d549f9b3efcbdcd834">PKCloseFile</a> (<a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *pDescriptor, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close an open file.  <a href="#a2108b20a6b8963d549f9b3efcbdcd834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a951662ac63b45aa08d3082a2ce03c3e7">PKSeekFile</a> (<a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *pDescriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek to a byte position within a file, with the given flags.  <a href="#a951662ac63b45aa08d3082a2ce03c3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#aec32208f5d5fcbf8d65b1921039d4171">PKBytesFile</a> (<a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *pDescriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of bytes in a file in the <code>bytes</code> parameter.  <a href="#aec32208f5d5fcbf8d65b1921039d4171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a411c60c0f7cd9da21ca837f8de475118">PKStatusFile</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Populate a structure with information about a file.  <a href="#a411c60c0f7cd9da21ca837f8de475118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a3aaed6d70eccc0ec69f38860124414ae">PKDeleteFile</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a file.  <a href="#a3aaed6d70eccc0ec69f38860124414ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a8d549ba3f7c100d47fa8b6b887f42f72">PKFindFirstFile</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszPattern, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszEntryName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first file matching a pattern.  <a href="#a8d549ba3f7c100d47fa8b6b887f42f72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a6a94b66de902f4c6becd301d60c19c2a">PKFindNextFile</a> (void *handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszEntryName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerate file entries matching a pattern. It returns, in <code>pszEntryName</code>, the path of an entry in the directory. Calls on the same handle will enumerate the matched entries until all entries have been enumerated.  <a href="#a6a94b66de902f4c6becd301d60c19c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a24e738453c05d294c27cda5b6e2361b7">PKCloseFindFile</a> (void *handle, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the file matching specified by the handle.  <a href="#a24e738453c05d294c27cda5b6e2361b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#aa5481d7c6c9f0a1a9bb96d3a2893457e">PKDirOpen</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszDirName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a directory.  <a href="#aa5481d7c6c9f0a1a9bb96d3a2893457e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a995a567e4fa6509813cfcd6bfb86158c">PKDirNext</a> (void *handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszEntryName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *fIsFolder, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerate entries in a directory. It returns, in <code>pszEntryName</code>, the leaf name of an entry in the directory. Calls on the same handle will enumerate the entries in the directory until all entries have been enumerated.  <a href="#a995a567e4fa6509813cfcd6bfb86158c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#af01e3e61b2292c6008b3c38f26ca6ce5">PKDirClose</a> (void *handle, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the directory specified by the handle.  <a href="#af01e3e61b2292c6008b3c38f26ca6ce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html#a1cea5183cbe18d21e864339381eb1bb7">PKOSFontDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszFontDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an explicit path to the OS font folder. (E.g. C/WINDOWS/fonts/).  <a href="#a1cea5183cbe18d21e864339381eb1bb7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Platform file abstraction. Each platform can have its own implementation of these functions. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a8ace592c26cb31670dfaa91035108123"></a><!-- doxytag: member="file.h::LONGESTFILENAME" ref="a8ace592c26cb31670dfaa91035108123" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LONGESTFILENAME&nbsp;&nbsp;&nbsp;2048</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The longest file name </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a40e0b71584507e90147bebd129162e78"></a><!-- doxytag: member="file.h::PKError" ref="a40e0b71584507e90147bebd129162e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="file_8h.html#a40e0b71584507e90147bebd129162e78">PKError</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This set of error returns should cover most cases -- at least enough for the RIP to extract the information it needs from this platform abstraction layer. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78ae5ba56d9a6fda4ea383f3bf3119888e0"></a><!-- doxytag: member="PKErrorNone" ref="a40e0b71584507e90147bebd129162e78ae5ba56d9a6fda4ea383f3bf3119888e0" args="" -->PKErrorNone</em>&nbsp;</td><td>
<p>No error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a99ae2abfae83950bdbf9a96fe9d4b317"></a><!-- doxytag: member="PKErrorUnknown" ref="a40e0b71584507e90147bebd129162e78a99ae2abfae83950bdbf9a96fe9d4b317" args="" -->PKErrorUnknown</em>&nbsp;</td><td>
<p>Generic error failure </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a4852d3ad3e571f6d96ba56994191dca3"></a><!-- doxytag: member="PKErrorParameter" ref="a40e0b71584507e90147bebd129162e78a4852d3ad3e571f6d96ba56994191dca3" args="" -->PKErrorParameter</em>&nbsp;</td><td>
<p>Generic problem with a supplied parameter </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78aa9863aaef3010dac34f9ed8fbfb48a1e"></a><!-- doxytag: member="PKErrorPointerNull" ref="a40e0b71584507e90147bebd129162e78aa9863aaef3010dac34f9ed8fbfb48a1e" args="" -->PKErrorPointerNull</em>&nbsp;</td><td>
<p>A pointer was null when it should not have been </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a992e9620b8f8482b491a44fff9772e3b"></a><!-- doxytag: member="PKErrorNumericRange" ref="a40e0b71584507e90147bebd129162e78a992e9620b8f8482b491a44fff9772e3b" args="" -->PKErrorNumericRange</em>&nbsp;</td><td>
<p>A value was out of range </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a5e1f6cde9d35bf479e146ed039eaed8c"></a><!-- doxytag: member="PKErrorNumericValue" ref="a40e0b71584507e90147bebd129162e78a5e1f6cde9d35bf479e146ed039eaed8c" args="" -->PKErrorNumericValue</em>&nbsp;</td><td>
<p>A value was illegal </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a3ac5a7b4458a0203f2298c8362a17121"></a><!-- doxytag: member="PKErrorStringEmpty" ref="a40e0b71584507e90147bebd129162e78a3ac5a7b4458a0203f2298c8362a17121" args="" -->PKErrorStringEmpty</em>&nbsp;</td><td>
<p>A string was empty when it should not have been </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a13d66df4134b34a99c369676c4509c5e"></a><!-- doxytag: member="PKErrorStringLength" ref="a40e0b71584507e90147bebd129162e78a13d66df4134b34a99c369676c4509c5e" args="" -->PKErrorStringLength</em>&nbsp;</td><td>
<p>The length of a string was illegal (usually: the string was too long) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a11158d94eefa2b43fe842ad94ebfed2a"></a><!-- doxytag: member="PKErrorStringSyntax" ref="a40e0b71584507e90147bebd129162e78a11158d94eefa2b43fe842ad94ebfed2a" args="" -->PKErrorStringSyntax</em>&nbsp;</td><td>
<p>A string was syntactically incorrect </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a0124eca1d373dc197cd8e2ff00701161"></a><!-- doxytag: member="PKErrorStringValue" ref="a40e0b71584507e90147bebd129162e78a0124eca1d373dc197cd8e2ff00701161" args="" -->PKErrorStringValue</em>&nbsp;</td><td>
<p>A string had an incorrect value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a6591d7fbe87cfe8df1511dde8a39a3cb"></a><!-- doxytag: member="PKErrorOperationDenied" ref="a40e0b71584507e90147bebd129162e78a6591d7fbe87cfe8df1511dde8a39a3cb" args="" -->PKErrorOperationDenied</em>&nbsp;</td><td>
<p>Generic denial of operation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78ae2208d3b246984d9485dcb8ce1329d6f"></a><!-- doxytag: member="PKErrorNonExistent" ref="a40e0b71584507e90147bebd129162e78ae2208d3b246984d9485dcb8ce1329d6f" args="" -->PKErrorNonExistent</em>&nbsp;</td><td>
<p>A file mentioned in an operation did not exist </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a2e5e20f2923e466f43829f6939ec20d8"></a><!-- doxytag: member="PKErrorAlreadyExists" ref="a40e0b71584507e90147bebd129162e78a2e5e20f2923e466f43829f6939ec20d8" args="" -->PKErrorAlreadyExists</em>&nbsp;</td><td>
<p>A file already existed when attempting to create it </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a72bcf9e31267d187c99c5d946a26f505"></a><!-- doxytag: member="PKErrorAccessDenied" ref="a40e0b71584507e90147bebd129162e78a72bcf9e31267d187c99c5d946a26f505" args="" -->PKErrorAccessDenied</em>&nbsp;</td><td>
<p>Access to a file system resource was denied </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a2930022e241a72f5b968550cbbe894ca"></a><!-- doxytag: member="PKErrorInUse" ref="a40e0b71584507e90147bebd129162e78a2930022e241a72f5b968550cbbe894ca" args="" -->PKErrorInUse</em>&nbsp;</td><td>
<p>A filesystem resource is already is use </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78ac66007a1068c3a1156d875cadba57d3d"></a><!-- doxytag: member="PKErrorOperationFailed" ref="a40e0b71584507e90147bebd129162e78ac66007a1068c3a1156d875cadba57d3d" args="" -->PKErrorOperationFailed</em>&nbsp;</td><td>
<p>Generic failure </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a7afcfdd7322cda9635558853c4049b7f"></a><!-- doxytag: member="PKErrorAbort" ref="a40e0b71584507e90147bebd129162e78a7afcfdd7322cda9635558853c4049b7f" args="" -->PKErrorAbort</em>&nbsp;</td><td>
<p>Operation was externally aborted </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78afb869909835d97c749fec4cec30019cc"></a><!-- doxytag: member="PKErrorNoMemory" ref="a40e0b71584507e90147bebd129162e78afb869909835d97c749fec4cec30019cc" args="" -->PKErrorNoMemory</em>&nbsp;</td><td>
<p>Operation failed due to lack of memory </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a1243451790a5d77d7461f7cf73f4ab3b"></a><!-- doxytag: member="PKErrorDiskFull" ref="a40e0b71584507e90147bebd129162e78a1243451790a5d77d7461f7cf73f4ab3b" args="" -->PKErrorDiskFull</em>&nbsp;</td><td>
<p>Operation failed due to disk being full or a disk quota being exceed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78af2ef98de21f0ee48fd0eb24d2e003826"></a><!-- doxytag: member="PKErrorSoftwareLimit" ref="a40e0b71584507e90147bebd129162e78af2ef98de21f0ee48fd0eb24d2e003826" args="" -->PKErrorSoftwareLimit</em>&nbsp;</td><td>
<p>Operation failed due to a software limitation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a93a4c2d53a2e869268a21c5cbc122341"></a><!-- doxytag: member="PKErrorHardware" ref="a40e0b71584507e90147bebd129162e78a93a4c2d53a2e869268a21c5cbc122341" args="" -->PKErrorHardware</em>&nbsp;</td><td>
<p>Operation failed due to hardware error, e.g., an I/O error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a08f0fef06fbdb6a0e63d686e006a24ac"></a><!-- doxytag: member="PKErrorUnimplemented" ref="a40e0b71584507e90147bebd129162e78a08f0fef06fbdb6a0e63d686e006a24ac" args="" -->PKErrorUnimplemented</em>&nbsp;</td><td>
<p>Operation failed because it is unimplemented </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a40e0b71584507e90147bebd129162e78a9144a626e73b31b167cbfde8a7fe4063"></a><!-- doxytag: member="PKErrorFatal" ref="a40e0b71584507e90147bebd129162e78a9144a626e73b31b167cbfde8a7fe4063" args="" -->PKErrorFatal</em>&nbsp;</td><td>
<p>Operation failed, fatally </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9a4c2134484bd40d72f62f7fc12b8704"></a><!-- doxytag: member="file.h::KGetSWDir" ref="a9a4c2134484bd40d72f62f7fc12b8704" args="(uint8 *pSWDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KGetSWDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pSWDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an explicit path to the SW folder, taking into account any path set using <a class="el" href="filedev_8c.html#ae23f216f3ebedbae08f16cef9afb6f5f" title="Record an explicit path to the SW folder, overriding any default search rules.">KSetSWDir()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to memory at least <code>LONGESTFILENAME</code> bytes in length, which on output contains the SW folder path (terminated with a directory separator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to memory at least LONGESTFILENAME bytes in length, which on output contains the SW folder path (terminated with a directory separator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae23f216f3ebedbae08f16cef9afb6f5f"></a><!-- doxytag: member="file.h::KSetSWDir" ref="ae23f216f3ebedbae08f16cef9afb6f5f" args="(uint8 *pSWDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KSetSWDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pSWDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Record an explicit path to the SW folder, overriding any default search rules. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to a null-terminated path, which may not exceed <code>LONGESTFILENAME</code> in length (inclusive of the terminator), and which must end with a directory separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to a null-terminated path, which may not exceed LONGESTFILENAME in length (inclusive of the terminator), and which must end with a directory separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is not thread-safe, and so should be called prior to the creation of any file device instances. </dd></dl>

</div>
</div>
<a class="anchor" id="a01a056c0cc20034d8f6faa7b78e4ade0"></a><!-- doxytag: member="file.h::PKAppDir" ref="a01a056c0cc20034d8f6faa7b78e4ade0" args="(uint8 *pAppDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKAppDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pAppDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy, into the buffer provided, the directory in which the application executable lives. This directory will be terminated with a directory separator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pAppDir</em>&nbsp;</td><td>Buffer to hold application directory name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abbb33270cb4584b82287016cc13420e7"></a><!-- doxytag: member="file.h::PKBuildRoot" ref="abbb33270cb4584b82287016cc13420e7" args="(uint8 *pOutput, uint8 *pInput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKBuildRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pInput</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the inverse of <a class="el" href="file_8h.html#a3dc720adcdcfb7fb1b643966de313abc" title="Parse the root part of an absolute filename *ppInput.">PKParseRoot()</a>, and builds a complete root part of a platform dependent filename from the variable part as previously output by <a class="el" href="file_8h.html#a3dc720adcdcfb7fb1b643966de313abc" title="Parse the root part of an absolute filename *ppInput.">PKParseRoot()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>FALSE</code> if the input is badly formed, and no output is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="aec32208f5d5fcbf8d65b1921039d4171"></a><!-- doxytag: member="file.h::PKBytesFile" ref="aec32208f5d5fcbf8d65b1921039d4171" args="(FileDesc *pDescriptor, Hq32x2 *bytes, int32 reason, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKBytesFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of bytes in a file in the <code>bytes</code> parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDescriptor</em>&nbsp;</td><td>The file descriptor, as returned from <a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5" title="Open a file, with the given flags. (Flags are from swdevice.h.).">PKOpenFile()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes</em>&nbsp;</td><td>The number of bytes is written into this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>One of <code>SW_BYTES_AVAIL_REL</code> or <code>SW_BYTES_TOTAL_ABS</code> from <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2108b20a6b8963d549f9b3efcbdcd834"></a><!-- doxytag: member="file.h::PKCloseFile" ref="a2108b20a6b8963d549f9b3efcbdcd834" args="(FileDesc *pDescriptor, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKCloseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close an open file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDescriptor</em>&nbsp;</td><td>The file descriptor, as returned from <a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5" title="Open a file, with the given flags. (Flags are from swdevice.h.).">PKOpenFile()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24e738453c05d294c27cda5b6e2361b7"></a><!-- doxytag: member="file.h::PKCloseFindFile" ref="a24e738453c05d294c27cda5b6e2361b7" args="(void *handle, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKCloseFindFile </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the file matching specified by the handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A FindFile handle, as returned from <a class="el" href="file_8h.html#a8d549ba3f7c100d47fa8b6b887f42f72" title="Find the first file matching a pattern.">PKFindFirstFile()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0715327bf4e9a71279090ecc5b558c7"></a><!-- doxytag: member="file.h::PKCurrDir" ref="ae0715327bf4e9a71279090ecc5b558c7" args="(uint8 *pCurrDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKCurrDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pCurrDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy into the buffer provided the directory in which the application is running. This directory will be terminated with a directory separator. On the Classic Mac, which has no concept of current dir, this is the same as <a class="el" href="file_8h.html#a01a056c0cc20034d8f6faa7b78e4ade0" title="Copy, into the buffer provided, the directory in which the application executable...">PKAppDir()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pCurrDir</em>&nbsp;</td><td>Buffer to hold current directory name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3aaed6d70eccc0ec69f38860124414ae"></a><!-- doxytag: member="file.h::PKDeleteFile" ref="a3aaed6d70eccc0ec69f38860124414ae" args="(uint8 *filename, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKDeleteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Full path to the file to be deleted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, non-zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af01e3e61b2292c6008b3c38f26ca6ce5"></a><!-- doxytag: member="file.h::PKDirClose" ref="af01e3e61b2292c6008b3c38f26ca6ce5" args="(void *handle, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKDirClose </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the directory specified by the handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A directory handle, as returned from <a class="el" href="file_8h.html#aa5481d7c6c9f0a1a9bb96d3a2893457e" title="Open a directory.">PKDirOpen()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a995a567e4fa6509813cfcd6bfb86158c"></a><!-- doxytag: member="file.h::PKDirNext" ref="a995a567e4fa6509813cfcd6bfb86158c" args="(void *handle, uint8 *pszEntryName, int32 *fIsFolder, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKDirNext </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszEntryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>fIsFolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerate entries in a directory. It returns, in <code>pszEntryName</code>, the leaf name of an entry in the directory. Calls on the same handle will enumerate the entries in the directory until all entries have been enumerated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A directory handle, as returned from <a class="el" href="file_8h.html#aa5481d7c6c9f0a1a9bb96d3a2893457e" title="Open a directory.">PKDirOpen()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszEntryName</em>&nbsp;</td><td>[out] Set to the leaf name of the entry enumerated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fIsFolder</em>&nbsp;</td><td>[out] Set to <code>TRUE</code> if the entry enumerated is a directory, and <code>FALSE</code> if it is a file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5481d7c6c9f0a1a9bb96d3a2893457e"></a><!-- doxytag: member="file.h::PKDirOpen" ref="aa5481d7c6c9f0a1a9bb96d3a2893457e" args="(uint8 *pszDirName, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PKDirOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszDirName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDirName</em>&nbsp;</td><td>Full path to the directory to be opened. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the PKError values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A directory handle (<code><a class="el" href="structFindFileState.html" title="FindFileState.">FindFileState</a></code> pointer) cast to <code>void*</code>, or <code>NULL</code> if the operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d549ba3f7c100d47fa8b6b887f42f72"></a><!-- doxytag: member="file.h::PKFindFirstFile" ref="a8d549ba3f7c100d47fa8b6b887f42f72" args="(uint8 *pszPattern, uint8 *pszEntryName, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PKFindFirstFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszEntryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the first file matching a pattern. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszPattern</em>&nbsp;</td><td>platform file name pattern to be matched</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszEntryName</em>&nbsp;</td><td>returns the first matched path Caller must ensure that its size is at least <code>LONGESTFILENAME</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the PKError values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A FindFile handle (<code><a class="el" href="structFindFileState.html" title="FindFileState.">FindFileState</a></code> pointer) cast to <code>void*</code>, or <code>NULL</code> if the operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a94b66de902f4c6becd301d60c19c2a"></a><!-- doxytag: member="file.h::PKFindNextFile" ref="a6a94b66de902f4c6becd301d60c19c2a" args="(void *handle, uint8 *pszEntryName, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKFindNextFile </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszEntryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerate file entries matching a pattern. It returns, in <code>pszEntryName</code>, the path of an entry in the directory. Calls on the same handle will enumerate the matched entries until all entries have been enumerated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A FindFile handle, as returned from <a class="el" href="file_8h.html#a8d549ba3f7c100d47fa8b6b887f42f72" title="Find the first file matching a pattern.">PKFindFirstFile()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszEntryName</em>&nbsp;</td><td>[out] Set to the path name of the entry enumerated. Caller must ensure that its size is at least <code>LONGESTFILENAME</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6e1475115f69ad6c43daf505a608aa5"></a><!-- doxytag: member="file.h::PKOpenFile" ref="aa6e1475115f69ad6c43daf505a608aa5" args="(uint8 *filename, int32 openflags, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a>* PKOpenFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>openflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a file, with the given flags. (Flags are from <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>Full path of the file to be opened </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>openflags</em>&nbsp;</td><td>Flags to control the way in which the file is opened. See <a class="el" href="group__PLUGIN__swdevice.html#ga85bb263ac9a1de667c57df529d9b09be" title="Call to open a file on device.">DEVICELIST_OPEN()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The file descriptor if open was successful; <code>NULL</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cea5183cbe18d21e864339381eb1bb7"></a><!-- doxytag: member="file.h::PKOSFontDir" ref="a1cea5183cbe18d21e864339381eb1bb7" args="(uint8 *pszFontDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKOSFontDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszFontDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an explicit path to the OS font folder. (E.g. C/WINDOWS/fonts/). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFontDir</em>&nbsp;</td><td>Pointer to memory at least <code>LONGESTFILENAME</code> bytes in length, which on output contains the OS font folder path (terminated with a directory separator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dc720adcdcfb7fb1b643966de313abc"></a><!-- doxytag: member="file.h::PKParseRoot" ref="a3dc720adcdcfb7fb1b643966de313abc" args="(uint8 *pOutput, uint8 **ppInput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKParseRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **&nbsp;</td>
          <td class="paramname"> <em>ppInput</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse the root part of an absolute filename <code>*ppInput</code>. </p>
<p>If pOutput is non-NULL the variable part of the root, excluding any platform specific root prefixes and suffices is sent to it. <code>*ppInput</code> is updated to point to first unconsumed character of input.</p>
<p>For example: </p>
<pre>
      Input                   Output                  Remaining input
 PC   "C:\..."                "C"                     "..."
      "\\machine\drive\..."   "machine\drive"         "..."</pre><pre> Mac  "volume:..."            "volume"                "..."</pre><pre> Unix "/..."                  ""                      "..."
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutput</em>&nbsp;</td><td>The root fragment (if non-NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppInput</em>&nbsp;</td><td>An absolute filename</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>FALSE</code> if the filename is relative; <code>TRUE</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aff248b6001f2f90d3a27d46d40ebeaf8"></a><!-- doxytag: member="file.h::PKReadFile" ref="aff248b6001f2f90d3a27d46d40ebeaf8" args="(FileDesc *pDescriptor, uint8 *buff, int32 len, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a specified number of bytes from a file into a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDescriptor</em>&nbsp;</td><td>The file descriptor, as returned from <a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5" title="Open a file, with the given flags. (Flags are from swdevice.h.).">PKOpenFile()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>Buffer into which the data read is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read, if successful; -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a951662ac63b45aa08d3082a2ce03c3e7"></a><!-- doxytag: member="file.h::PKSeekFile" ref="a951662ac63b45aa08d3082a2ce03c3e7" args="(FileDesc *pDescriptor, Hq32x2 *destination, int32 flags, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKSeekFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek to a byte position within a file, with the given flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDescriptor</em>&nbsp;</td><td>The file descriptor, as returned from <a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5" title="Open a file, with the given flags. (Flags are from swdevice.h.).">PKOpenFile()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The location to seek to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One of SW_SET, SW_INCR, SW_XTND. See <a class="el" href="group__PLUGIN__swdevice.html#ga2db8731fa4ca396fe986dff5ae7a935f" title="Call to seek file on device.">DEVICELIST_SEEK()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a411c60c0f7cd9da21ca837f8de475118"></a><!-- doxytag: member="file.h::PKStatusFile" ref="a411c60c0f7cd9da21ca837f8de475118" args="(uint8 *filename, STAT *statbuff, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKStatusFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSTAT.html">STAT</a> *&nbsp;</td>
          <td class="paramname"> <em>statbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populate a structure with information about a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The file to check status. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>statbuff</em>&nbsp;</td><td>Pointer to a structure in which to put the file status. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1320044f195253b505d017b1fa765320"></a><!-- doxytag: member="file.h::PKSWDir" ref="a1320044f195253b505d017b1fa765320" args="(uint8 *pSWDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKSWDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pSWDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy into the buffer provided the SW directory name. This directory will be terminated with a directory separator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Buffer to hold SW directory name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success; <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad54fd9715b0bb4c2549cc4eacb6d2ac9"></a><!-- doxytag: member="file.h::PKWriteFile" ref="ad54fd9715b0bb4c2549cc4eacb6d2ac9" args="(FileDesc *pDescriptor, uint8 *buff, int32 len, int32 *pError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> PKWriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="file_8h.html#a41af9a6b04a9decd18c6fed8dead4d60">FileDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>pDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pError</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a specified number of bytes from a buffer into a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDescriptor</em>&nbsp;</td><td>The file descriptor, as returned from <a class="el" href="file_8h.html#aa6e1475115f69ad6c43daf505a608aa5" title="Open a file, with the given flags. (Flags are from swdevice.h.).">PKOpenFile()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>Buffer into which the data read is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The maximum number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pError</em>&nbsp;</td><td>A value which the function can set to one of the <code>PKError</code> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written, if successful; -1 otherwise. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
