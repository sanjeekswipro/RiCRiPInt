<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: skinkit.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>skinkit.c File Reference</h1>
<p>This file implements the interface between the "push" model of the <code>SwLe</code> example skin functions, and the natural "pull" model of the core Harlequin RIP interface. It does this by synchronizing the thread on which the RIP is running with the calling application thread.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="skinkit_8h.html">skinkit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="kit_8h.html">kit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync_8h.html">sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqstr_8h.html">hqstr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="devparam_8h.html">devparam.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="threadapi_8h.html">threadapi.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swevents_8h.html">swevents.h</a>&quot;</code><br/>
<code>#include &quot;progevts.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="probelog_8h.html">probelog.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swtrace_8h.html">swtrace.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swtimelines_8h.html">swtimelines.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="timer_8h.html">timer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skindevs_8h.html">skindevs.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swcopyf_8h.html">swcopyf.h</a>&quot;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structControlData.html">ControlData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gathers together various data involved in controlling the RIP and recording its current state.  <a href="structControlData.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173aea6c70eb1b93c7dc80e76123622329bb">NOTHING_CALLED</a> =  1, 
<a class="el" href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173a325ac2ddcce661370051b3564c8faecf">RIPSTART_CALLED</a>, 
<a class="el" href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173a6987b8aebda775810af3171fd2b57006">JOBSTART_CALLED</a>, 
<a class="el" href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173afa096f3c860d296c673f87b434649b11">PS_CALLED</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173ab2b920db767c3549ce21fad0e970e065">JOBEND_CALLED</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Used to implement a simple state machine representing the host application's calls to the high-level <code>SwLe</code> RIP controller functions, <a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a>, <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a>, <a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a> and <a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a>. This state machine is used to assert that the application is calling into the <code>SwLe</code> interface in the correct order. </p>
 <a href="skinkit_8c.html#a56a0f36da7f9eaaf54bd05cc2bf49173">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aa4022200d2915eb79c8172d590082a448">UNSTARTED</a> =  1, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aa621443bb5a4810d48eb10483adb864ab">INITIALISING</a>, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aa46c7cadbbca08a97816831affc2956b1">WAITING_FOR_JOB_START</a>, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aa34b993ff97642389c74e66a1b154d6f6">PROCESSING_JOB_START</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aad480ec36ad8de4e3e58aad334e892dd2">PROCESSING_PS</a>, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aabf22b76023fb67798e3db52b05b49505">PROCESSING_JOB_ERROR</a>, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aa7b6d3c9cfb6ae6bda595cdf19b674a5c">PROCESSING_JOB_END</a>, 
<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aacfb2a43c3a1dfa5961655a52e11c5d73">EXITING</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012aab9f9543350f6bd6191e52158daa88884">EXITED</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Used to implement a simple state machine representing the lifecycle of the RIP. </p>
 <a href="skinkit_8c.html#aa156d1cebb38c8a65846c4d9c006012a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a3b4116b0ace0a6569b1f63e0326c0998">KSwLeStop</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called as part of the RIP's exit procedure.  <a href="#a3b4116b0ace0a6569b1f63e0326c0998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e80f04b14badd9f35623c230f8daa7"></a><!-- doxytag: member="skinkit.c::PYieldToRIP" ref="ac4e80f04b14badd9f35623c230f8daa7" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#ac4e80f04b14badd9f35623c230f8daa7">PYieldToRIP</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should only be called by the main application thread when it wants to yield to the RIP thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ce7424d04b953c461122f6b354d90a"></a><!-- doxytag: member="skinkit.c::PYieldToApp" ref="a17ce7424d04b953c461122f6b354d90a" args="(void)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a17ce7424d04b953c461122f6b354d90a">PYieldToApp</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should only be called by the RIP thread when it wants to yield to the main application thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a3e37ba1a46ca5a64748ceeae6bb5eb80">SwStartupCommon</a> (<a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> *pfnMonitor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs early startup actions.  <a href="#a3e37ba1a46ca5a64748ceeae6bb5eb80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga4e0b5658bf9c11a06579cfe17be185dd">SwLeInitRuntime</a> (void *pContext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes skinkit variables prior to starting the RIP.  <a href="group__skinkit.html#ga4e0b5658bf9c11a06579cfe17be185dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24">SwLeSDKStart</a> (size_t *RIP_maxAddressSpaceInBytes, size_t *RIP_workingSizeInBytes, void *pMemory, <a class="el" href="structSysMemFns.html">SysMemFns</a> *pSysMemFns, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **reasonText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise SDK support libraries for the RIP.  <a href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68">SwLeSDKEnd</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> exitCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the SDK support libraries.  <a href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca">SwLeMemInit</a> (size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pre-initializes the RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.  <a href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992">SwLeStart</a> (size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory, <a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> *pfnMonitor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the Harlequin RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.  <a href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816">SwLeStop</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the RIP to stop.  <a href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaa381b394f5ddf59465e09cfcd02076e7">SwLeWaitForRIPThreadToExit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for the RIP thread started via <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> to exit.  <a href="group__skinkit.html#gaa381b394f5ddf59465e09cfcd02076e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaca48331cf0f6d8166e24bbb922f32ced">SwLeShutdown</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs shutdown operations when the application exits.  <a href="group__skinkit.html#gaca48331cf0f6d8166e24bbb922f32ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga0a34398673384fea0f8529de48d7be6f">SwLeSetTickleTimerFunctions</a> (SwStartTickleTimerFn *pfnSwStartTickleTimer, SwStopTickleTimerFn *pfnSwStopTickleTimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply timers for triggering the tickle callbacks.  <a href="group__skinkit.html#ga0a34398673384fea0f8529de48d7be6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga60850c161b2dded4bfbb68ee305af6d5">SwLeSetRipExitFunction</a> (<a class="el" href="group__skinkit.html#gae5a51b455377de612343ce995ad66452">SwLeRIPEXITCALLBACK</a> *pfnRipExit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply callback function to be called when the RIP exits.  <a href="group__skinkit.html#ga60850c161b2dded4bfbb68ee305af6d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54">SwLeSetRipRebootFunction</a> (<a class="el" href="group__skinkit.html#ga10bb022d5fa4155c2fc1960e7a910775">SwLeRIPREBOOTCALLBACK</a> *pfnRipReboot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply callback function to be called when the RIP reboots.  <a href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b">SwLeJobStart</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, void *pJobContext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares the Harlequin RIP to receive a PostScript language job.  <a href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaefd65dd3f56915ca62ea0a6a798e765d">SwLeSetRasterCallbacks</a> (<a class="el" href="group__skinkit.html#gaab295af926f7b69bfb091188c5206692">SwLeRASTERSTRIDE</a> *pfnRasterStride, <a class="el" href="group__skinkit.html#ga36e8277083d8600ee7926550c164e7a9">SwLeRASTERREQUIREMENTS</a> *pfnRasterRequirements, <a class="el" href="group__skinkit.html#ga8f41acc9f374e58cae02d5c184e3812d">SwLeRASTERDESTINATION</a> *pfnRasterDestination, <a class="el" href="group__skinkit.html#ga49784289c974157865016f5987db7783">SwLeRASTERCALLBACK</a> *pfnRaster)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the callback functions that the RIP will call back to present raster data to the skin.  <a href="group__skinkit.html#gaefd65dd3f56915ca62ea0a6a798e765d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab">SwLePs</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Passes a chunk of PostScript language data to the Harlequin RIP.  <a href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05">SwLeJobEnd</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminates the current job.  <a href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gabfa1ebf349f5d4048a26a653c7d8071b">SwLeGetDeviceHandle</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszDevice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a skin handle to a mounted RIP device, which can then be used to get more information about the device.  <a href="group__skinkit.html#gabfa1ebf349f5d4048a26a653c7d8071b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174">SwLeGetIntDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pInt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of an integer device parameter.  <a href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab49f1c3e18713b2fbc9a136353bc613a">SwLeGetBoolDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *pBool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a boolean device parameter.  <a href="group__skinkit.html#gab49f1c3e18713b2fbc9a136353bc613a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga834f23f9f6d90a32aeddb2e594881ff0">SwLeGetFloatDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, float *pFloat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a floating-point (real) device parameter.  <a href="group__skinkit.html#ga834f23f9f6d90a32aeddb2e594881ff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga30e18988f685bf9207fe03cbbd740cc4">SwLeGetStringDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ppStr, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pStrLen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a string device parameter.  <a href="group__skinkit.html#ga30e18988f685bf9207fe03cbbd740cc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaec1d8c37545ba11df97bdf6dd7652257">SwLeProcessingError</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether an error occurred in the most recent chunk of job data that was processed by the RIP.  <a href="group__skinkit.html#gaec1d8c37545ba11df97bdf6dd7652257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaee2af83f974f79696a8cfbd62077ab36">SwLeProcessingPs</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the skin that the RIP is now processing the job.  <a href="group__skinkit.html#gaee2af83f974f79696a8cfbd62077ab36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf831cd6870d9bbd693e49638228f08ff">SwLeProcessingJobEnd</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the skin that the RIP has finished processing the job.  <a href="group__skinkit.html#gaf831cd6870d9bbd693e49638228f08ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga55e714025403a8245ced9d59a9737fe2">SkinExit</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> n, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tidy up and exit.  <a href="group__skinkit.html#ga55e714025403a8245ced9d59a9737fe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga10f01be68c40a1737bcd5074f287e39f">SkinReboot</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when RIP reboots.  <a href="group__skinkit.html#ga10f01be68c40a1737bcd5074f287e39f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga12c30a50c599d2a1bf0a5373d998dabc">SwLeExitCode</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the exit status of the RIP.  <a href="group__skinkit.html#ga12c30a50c599d2a1bf0a5373d998dabc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf154f5d17c7794c1c0dec7d9ce405845">SkinMonitorl</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbData, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszMonitorData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a message through the monitor callback, if provided.  <a href="group__skinkit.html#gaf154f5d17c7794c1c0dec7d9ce405845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e">SkinMonitorf</a> (const char *pszFormat,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a formatted message through the monitor callback, if provided.  <a href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaadd3e110359f338c2c7bd17cbfb69c13">SkinVMonitorf</a> (const char *pszFormat, va_list vlist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identical to <code><a class="el" href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e" title="Display a formatted message through the monitor callback, if provided.">SkinMonitorf()</a></code>, where the vararg list is explicit.  <a href="group__skinkit.html#gaadd3e110359f338c2c7bd17cbfb69c13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a318fd5d2196ea9f2669e077f6a474b13">KGetConfigAvailable</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called from the RIP thread by the config device to determine how much config data, if any is available. This data would then be obtained by the RIP via <a class="el" href="kit_8h.html#a966a16a7ec47b0f958ce38266c940bb0" title="This method is called from the RIP thread by the config device when it is ready for...">KGetConfigData()</a>.  <a href="#a318fd5d2196ea9f2669e077f6a474b13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#aaf8cb0ace72c39c5d3a0a9b0cbee38ec">KGetConfigData</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbMax, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ppData, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pcbData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called from the RIP thread by the config device when it is ready for the config data for next job. Config data is provided by the app via <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a>.  <a href="#aaf8cb0ace72c39c5d3a0a9b0cbee38ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a33b074a67312bb81a5c9461f91c0c213">KGetJobData</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbMax, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ppData, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *pcbData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called from the RIP thread by the monitor device when it is ready for data from the current job. This data is provided by the app via <a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a>.  <a href="#a33b074a67312bb81a5c9461f91c0c213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a08740394a1606846bdd5fddf633e8f4e">KCallRasterCallback</a> (<a class="el" href="structrasterDescription.html">RasterDescription</a> *pRasterDescription, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function hands a band of raster data generated from the current job page to the raster callback implementation, if any, that the application has registered.  <a href="#a08740394a1606846bdd5fddf633e8f4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#ab72ead115c61f0ff23d04990369a819d">KCallRasterStride</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *puStride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which allows the skin to increase the raster stride (byte offset between the start address of successive raster lines).  <a href="#ab72ead115c61f0ff23d04990369a819d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a282c44356a5305491f49927b2c885717">KCallParamCallback</a> (<a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *skin_hook, const void *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function informs the skin whenever a monitored parameter changes. If no callback has been registered, nothing happens.  <a href="#a282c44356a5305491f49927b2c885717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a7a67819f564fcfa58665a563f18d4325">KParamSetCallback</a> (<a class="el" href="structPARAM.html">PARAM</a> params[], size_t n_params, const char *paramname, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> paramtype, <a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *pfnParamCallback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility function to set skin callbacks.  <a href="#a7a67819f564fcfa58665a563f18d4325"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a0235c6dc6f45ac68a904ab873ddcacb9">KCallRasterRequirements</a> (<a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *pRasterRequirements, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fRenderingStarting)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which gives the skin the details of the raster it's about to be handed, and allocate memory to contain it.  <a href="#a0235c6dc6f45ac68a904ab873ddcacb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#acd15d84afec1368803ec476f6892afac">KCallRasterDestination</a> (<a class="el" href="struct__raster__destination.html">RASTER_DESTINATION</a> *pRasterDestination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nFrameNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which asks the skin to provide a memory address range into which to render.  <a href="#acd15d84afec1368803ec476f6892afac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html#a6bc199bb8de3ed5a00773aec8960b90d">KCallMonitorCallback</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbData, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszMonitorData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function hands a monitor information string generated by the RIP to the monitor callback implementation, if any, that the application has registered.  <a href="#a6bc199bb8de3ed5a00773aec8960b90d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gac2263800ddca2b939f4a0ad7068c9fde">KSetSystemErrorLevel</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> errlevel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set system error record level.  <a href="group__skinkit.html#gac2263800ddca2b939f4a0ad7068c9fde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5f6ba6390beba576b1ee0a982942c38"></a><!-- doxytag: member="skinkit.c::KGetSystemErrorLevel" ref="gad5f6ba6390beba576b1ee0a982942c38" args="(void)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gad5f6ba6390beba576b1ee0a982942c38">KGetSystemErrorLevel</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get system error record level. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file implements the interface between the "push" model of the <code>SwLe</code> example skin functions, and the natural "pull" model of the core Harlequin RIP interface. It does this by synchronizing the thread on which the RIP is running with the calling application thread. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173"></a><!-- doxytag: member="skinkit.c::@59" ref="a56a0f36da7f9eaaf54bd05cc2bf49173" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to implement a simple state machine representing the host application's calls to the high-level <code>SwLe</code> RIP controller functions, <a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a>, <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a>, <a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a> and <a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a>. This state machine is used to assert that the application is calling into the <code>SwLe</code> interface in the correct order. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173aea6c70eb1b93c7dc80e76123622329bb"></a><!-- doxytag: member="NOTHING_CALLED" ref="a56a0f36da7f9eaaf54bd05cc2bf49173aea6c70eb1b93c7dc80e76123622329bb" args="" -->NOTHING_CALLED</em>&nbsp;</td><td>
<p>No <code>SwLe</code> functions called yet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173a325ac2ddcce661370051b3564c8faecf"></a><!-- doxytag: member="RIPSTART_CALLED" ref="a56a0f36da7f9eaaf54bd05cc2bf49173a325ac2ddcce661370051b3564c8faecf" args="" -->RIPSTART_CALLED</em>&nbsp;</td><td>
<p><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a> has been legally called. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173a6987b8aebda775810af3171fd2b57006"></a><!-- doxytag: member="JOBSTART_CALLED" ref="a56a0f36da7f9eaaf54bd05cc2bf49173a6987b8aebda775810af3171fd2b57006" args="" -->JOBSTART_CALLED</em>&nbsp;</td><td>
<p><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a> has been legally called. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173afa096f3c860d296c673f87b434649b11"></a><!-- doxytag: member="PS_CALLED" ref="a56a0f36da7f9eaaf54bd05cc2bf49173afa096f3c860d296c673f87b434649b11" args="" -->PS_CALLED</em>&nbsp;</td><td>
<p><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a> has been legally called. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a56a0f36da7f9eaaf54bd05cc2bf49173ab2b920db767c3549ce21fad0e970e065"></a><!-- doxytag: member="JOBEND_CALLED" ref="a56a0f36da7f9eaaf54bd05cc2bf49173ab2b920db767c3549ce21fad0e970e065" args="" -->JOBEND_CALLED</em>&nbsp;</td><td>
<p><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a> has been legally called. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012a"></a><!-- doxytag: member="skinkit.c::@60" ref="aa156d1cebb38c8a65846c4d9c006012a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to implement a simple state machine representing the lifecycle of the RIP. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aa4022200d2915eb79c8172d590082a448"></a><!-- doxytag: member="UNSTARTED" ref="aa156d1cebb38c8a65846c4d9c006012aa4022200d2915eb79c8172d590082a448" args="" -->UNSTARTED</em>&nbsp;</td><td>
<p>No attempt has been made to boot the RIP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aa621443bb5a4810d48eb10483adb864ab"></a><!-- doxytag: member="INITIALISING" ref="aa156d1cebb38c8a65846c4d9c006012aa621443bb5a4810d48eb10483adb864ab" args="" -->INITIALISING</em>&nbsp;</td><td>
<p>The RIP thread is preparing to boot the RIP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aa46c7cadbbca08a97816831affc2956b1"></a><!-- doxytag: member="WAITING_FOR_JOB_START" ref="aa156d1cebb38c8a65846c4d9c006012aa46c7cadbbca08a97816831affc2956b1" args="" -->WAITING_FOR_JOB_START</em>&nbsp;</td><td>
<p>The RIP has been booted, and is now waiting for the application thread to submit a job. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aa34b993ff97642389c74e66a1b154d6f6"></a><!-- doxytag: member="PROCESSING_JOB_START" ref="aa156d1cebb38c8a65846c4d9c006012aa34b993ff97642389c74e66a1b154d6f6" args="" -->PROCESSING_JOB_START</em>&nbsp;</td><td>
<p>The RIP is processing initial job configuration. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aad480ec36ad8de4e3e58aad334e892dd2"></a><!-- doxytag: member="PROCESSING_PS" ref="aa156d1cebb38c8a65846c4d9c006012aad480ec36ad8de4e3e58aad334e892dd2" args="" -->PROCESSING_PS</em>&nbsp;</td><td>
<p>The RIP is processing a PostScript job. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aabf22b76023fb67798e3db52b05b49505"></a><!-- doxytag: member="PROCESSING_JOB_ERROR" ref="aa156d1cebb38c8a65846c4d9c006012aabf22b76023fb67798e3db52b05b49505" args="" -->PROCESSING_JOB_ERROR</em>&nbsp;</td><td>
<p>The current job has errored. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aa7b6d3c9cfb6ae6bda595cdf19b674a5c"></a><!-- doxytag: member="PROCESSING_JOB_END" ref="aa156d1cebb38c8a65846c4d9c006012aa7b6d3c9cfb6ae6bda595cdf19b674a5c" args="" -->PROCESSING_JOB_END</em>&nbsp;</td><td>
<p>The current job is finished. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aacfb2a43c3a1dfa5961655a52e11c5d73"></a><!-- doxytag: member="EXITING" ref="aa156d1cebb38c8a65846c4d9c006012aacfb2a43c3a1dfa5961655a52e11c5d73" args="" -->EXITING</em>&nbsp;</td><td>
<p>The RIP is in the process of exiting. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa156d1cebb38c8a65846c4d9c006012aab9f9543350f6bd6191e52158daa88884"></a><!-- doxytag: member="EXITED" ref="aa156d1cebb38c8a65846c4d9c006012aab9f9543350f6bd6191e52158daa88884" args="" -->EXITED</em>&nbsp;</td><td>
<p>The RIP has exited. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6bc199bb8de3ed5a00773aec8960b90d"></a><!-- doxytag: member="skinkit.c::KCallMonitorCallback" ref="a6bc199bb8de3ed5a00773aec8960b90d" args="(int32 cbData, uint8 *pszMonitorData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KCallMonitorCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszMonitorData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function hands a monitor information string generated by the RIP to the monitor callback implementation, if any, that the application has registered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbData</em>&nbsp;</td><td>The length, in bytes, of a NUL-terminated monitor information string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszMonitorData</em>&nbsp;</td><td>The NUL-terminated monitor information string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a282c44356a5305491f49927b2c885717"></a><!-- doxytag: member="skinkit.c::KCallParamCallback" ref="a282c44356a5305491f49927b2c885717" args="(SwLeParamCallback *skin_hook, const void *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KCallParamCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnParamCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function informs the skin whenever a monitored parameter changes. If no callback has been registered, nothing happens. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnParamCallback</em>&nbsp;</td><td>The callback function registered for the parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>The parameter address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the Param* enumeration values from <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a08740394a1606846bdd5fddf633e8f4e"></a><!-- doxytag: member="skinkit.c::KCallRasterCallback" ref="a08740394a1606846bdd5fddf633e8f4e" args="(RasterDescription *pRasterDescription, uint8 *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KCallRasterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrasterDescription.html">RasterDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>rasterDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function hands a band of raster data generated from the current job page to the raster callback implementation, if any, that the application has registered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structrasterDescription.html" title="The main structure describing the raster produced by the RIP.">rasterDescription</a></em>&nbsp;</td><td>Description of the raster data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>The raster data itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of handing the raster data off to the registered callback function; <code>TRUE</code> if both no raster callback was registered and this function was called correctly in sequence; and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acd15d84afec1368803ec476f6892afac"></a><!-- doxytag: member="skinkit.c::KCallRasterDestination" ref="acd15d84afec1368803ec476f6892afac" args="(RASTER_DESTINATION *pRasterDestination, int32 nFrameNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KCallRasterDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__raster__destination.html">RASTER_DESTINATION</a> *&nbsp;</td>
          <td class="paramname"> <em>pRasterDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>nFrameNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which asks the skin to provide a memory address range into which to render. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRasterDestination</em>&nbsp;</td><td>Structure providing the band number the RIP is about to render, and pointers to the memory range that the RIP should use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFrameNumber</em>&nbsp;</td><td>The frame (separation) number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0235c6dc6f45ac68a904ab873ddcacb9"></a><!-- doxytag: member="skinkit.c::KCallRasterRequirements" ref="a0235c6dc6f45ac68a904ab873ddcacb9" args="(RASTER_REQUIREMENTS *pRasterRequirements, int32 fRenderingStarting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KCallRasterRequirements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *&nbsp;</td>
          <td class="paramname"> <em>pRasterRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fRenderingStarting</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which gives the skin the details of the raster it's about to be handed, and allocate memory to contain it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pRasterRequirements</em>&nbsp;</td><td>Structure providing details of the raster which the RIP will be providing, and some parameters for the skin to indicate to the RIP how it will proceed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fRenderingStarting</em>&nbsp;</td><td>A flag which is FALSE when this function is being called as a result of a change to the page device which means a difference in the raster structure, or TRUE when no further such changes are possible and rendering is beginning very soon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab72ead115c61f0ff23d04990369a819d"></a><!-- doxytag: member="skinkit.c::KCallRasterStride" ref="ab72ead115c61f0ff23d04990369a819d" args="(uint32 *puStride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KCallRasterStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>puStride</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which allows the skin to increase the raster stride (byte offset between the start address of successive raster lines). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>puStride</em>&nbsp;</td><td>Pointer to an unsigned integer which is set on entry to the raster line length in bytes which the RIP is set to use. The skin may increase this value to better suit its requirements, for example to force line start addresses to coincide with cache lines or DMA ranges. Of course, any increase will necessarily mean a larger memory requirement to hold the raster.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will almost always return 0, meaning success, but a skin implementation might return -1 signifying an error if the stride value is outside of an acceptable range. </p>

</div>
</div>
<a class="anchor" id="a318fd5d2196ea9f2669e077f6a474b13"></a><!-- doxytag: member="skinkit.c::KGetConfigAvailable" ref="a318fd5d2196ea9f2669e077f6a474b13" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KGetConfigAvailable </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called from the RIP thread by the config device to determine how much config data, if any is available. This data would then be obtained by the RIP via <a class="el" href="kit_8h.html#a966a16a7ec47b0f958ce38266c940bb0" title="This method is called from the RIP thread by the config device when it is ready for...">KGetConfigData()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>the</code> number of bytes of config data available. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf8cb0ace72c39c5d3a0a9b0cbee38ec"></a><!-- doxytag: member="skinkit.c::KGetConfigData" ref="aaf8cb0ace72c39c5d3a0a9b0cbee38ec" args="(int32 cbMax, uint8 **ppData, uint32 *pcbData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KGetConfigData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **&nbsp;</td>
          <td class="paramname"> <em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pcbData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called from the RIP thread by the config device when it is ready for the config data for next job. Config data is provided by the app via <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbMax</em>&nbsp;</td><td>The maximum amount of data which should be provided </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppData</em>&nbsp;</td><td>Where to copy the data to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcbData</em>&nbsp;</td><td>The actual amount of data copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if some data was provided, and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a33b074a67312bb81a5c9461f91c0c213"></a><!-- doxytag: member="skinkit.c::KGetJobData" ref="a33b074a67312bb81a5c9461f91c0c213" args="(int32 cbMax, uint8 **ppData, uint32 *pcbData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KGetJobData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **&nbsp;</td>
          <td class="paramname"> <em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pcbData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called from the RIP thread by the monitor device when it is ready for data from the current job. This data is provided by the app via <a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbMax</em>&nbsp;</td><td>The maximum amount of data which should be provided </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppData</em>&nbsp;</td><td>Where to copy the data to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcbData</em>&nbsp;</td><td>The actual amount of data copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if some data was provided, and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a67819f564fcfa58665a563f18d4325"></a><!-- doxytag: member="skinkit.c::KParamSetCallback" ref="a7a67819f564fcfa58665a563f18d4325" args="(PARAM params[], size_t n_params, const char *paramname, int32 paramtype, SwLeParamCallback *pfnParamCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KParamSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPARAM.html">PARAM</a>&nbsp;</td>
          <td class="paramname"> <em>params</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>paramtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnParamCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Utility function to set skin callbacks. </p>
<p>This function should be called through a trampoline function that passes in the parameter array and size. To remove a callback hook, call this function with a <code>NULL</code> function pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Array of <code><a class="el" href="structPARAM.html" title="Encapsulates the meta-data for a single device parameter.">PARAM</a></code> structures in which to add a hook.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_params</em>&nbsp;</td><td>The number of parameters in <em>params</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paramname</em>&nbsp;</td><td>The parameter name to monitor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paramtype</em>&nbsp;</td><td>The type of the parameter name to monitor. The callback functions use a generic pointer to pass the changed parameter value. Passing the expected type in with the hook function lets the skinkit check that the hook function will be passed the type it expects.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnParamCallback</em>&nbsp;</td><td>Pointer to a function though which the RIP informs the skin of parameter changes.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>If the callback could not be set (either the name of the parameter was not found, or the type of the parameter is incorrect).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>If the callback was set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b4116b0ace0a6569b1f63e0326c0998"></a><!-- doxytag: member="skinkit.c::KSwLeStop" ref="a3b4116b0ace0a6569b1f63e0326c0998" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KSwLeStop </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called as part of the RIP's exit procedure. </p>
<p>This function releases any remaining resources allocated during RIP initialization. </p>

</div>
</div>
<a class="anchor" id="a3e37ba1a46ca5a64748ceeae6bb5eb80"></a><!-- doxytag: member="skinkit.c::SwStartupCommon" ref="a3e37ba1a46ca5a64748ceeae6bb5eb80" args="(SwLeMONITORCALLBACK *pfnMonitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwStartupCommon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnMonitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs early startup actions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnMonitor</em>&nbsp;</td><td>The callback for monitor messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> upon success, <code>FALSE</code> upon failure. If this function fails, the caller should not proceed with trying to boot the RIP. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
