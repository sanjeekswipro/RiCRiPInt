<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: Skinkit: Example RIP skin devices and other features</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Skinkit: Example RIP skin devices and other features</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="caldev_8c.html">caldev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of the calendar device type. See Postscript Language Reference Supplement for Version 2 (Pages 150-151). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_8c.html">config.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of the config (configuration) device type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="devparam_8h.html">devparam.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Contains definitions shared between the PageBuffer (pgbdev) and Screening (scrndev) example device implememtations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fdecrypt_8c.html">fdecrypt.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Example implementation of the font decoder filter. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8c.html">file.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Platform independent implementation of the skinkit file I/O interfaces. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html">filedev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of the file system device type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fndcrypt_8c.html">fndcrypt.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Example implementation of the font decoder and encoder filter. If you wish to just test font decoding, define TEST_DECRYPTFONT instead. There are two encryption algorithms supported, to show how to implement multiple strategies. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybridev_8c.html">hybridev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of hybrid device intended for a read-only SW folder. on disk. In this case, the SW folder can be shared by more than one RIP. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="kit_8h.html">kit.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Exports to other skinkit files from <a class="el" href="skinkit_8c.html" title="This file implements the interface between the &quot;push&quot; model of the SwLe...">skinkit.c</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html">mem.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Memory-related utility functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8c.html">memfs.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of an input/output device tied to in-memory data. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="monitor_8c.html">monitor.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The monitor device type. This implements standard input and output for the rip. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pgbdev_8c.html">pgbdev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>An example implementation of the PageBuffer device type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="progdev_8c.html">progdev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of an example progress device. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="psock_8h.html">psock.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Socket related utility functions with per-platform implementations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ramdev_8c.html">ramdev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of an input/output device tied to in-memory data. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8c.html">ripthread.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Example implementation of corerip integration: Starting the RIP. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ripthread_8h.html">ripthread.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>RIP lifecycle code. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinkit_8c.html">skinkit.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file implements the interface between the "push" model of the <code>SwLe</code> example skin functions, and the natural "pull" model of the core Harlequin RIP interface. It does this by synchronizing the thread on which the RIP is running with the calling application thread. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streamdev_8c.html">streamdev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of an input/output device tied to a stream reader. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="strutils_8c.html">strutils.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>String-related utility functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="swzipreaddev_8c.html">swzipreaddev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of the SW ZIP read device type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html">sync.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Synchronization between the application calling thread and the thread that is running the RIP. Having this synchronization simplifies the application code because it doesn't need to worry about callbacks on the monitor or raster functions happening asynchronously - they will only happen when the application has called into one of the SwLe functions and is blocked waiting for the result. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8h.html">sync.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Cross platform synchronization primitives. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8c.html">xpsbuild.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implements an API for building XPS package parts using the in-memory virtual filesystem (MFS). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsdev_8c.html">xpsdev.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation of an input device for obtaining XPS page parts from an external source. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="zlibutil_8h.html">zlibutil.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>zlib utilities </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="file_8h.html">file.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Platform file abstraction. Each platform can have its own implementation of these functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqnstrutils_8h.html">hqnstrutils.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>String-related utility functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8h.html">mem.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Memory-related utility functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="memfs_8h.html">memfs.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Simple API for managing an in-memory, virtual file system. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="skinras_8h.html">skinras.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provides raster description to the Harlequin RIP SDK API. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html">streams.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A simple streaming abstraction to handle RIP I/O when using the Reference API. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsbuild_8h.html">xpsbuild.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Provides an API for building XPS package parts using the in-memory virtual filesystem (MFS). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xpsdev_8h.html">xpsdev.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Functions for interfacing the skinkit XPS input device with the client stream implementations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pfile_8c.html">pfile.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>File related utility functions for Unix. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmem_8c.html">pmem.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Memory related utility functions for UNIX. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab4245913154ea422b9914d6514389af2">SKINKIT_TRACENAMES</a>(macro_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended trace names for skinkit.  <a href="#gab4245913154ea422b9914d6514389af2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga12d440f8e76480185e3452a3230a90db">SKINKIT_TRACETYPES</a>(macro_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended trace types for skinkit.  <a href="#ga12d440f8e76480185e3452a3230a90db"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga49784289c974157865016f5987db7783">SwLeRASTERCALLBACK</a> )(void *pJobContext, <a class="el" href="structrasterDescription.html">RasterDescription</a> *pRasterDescription, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a callback function which receives bands of raster delivered from the RIP for the current job.  <a href="#ga49784289c974157865016f5987db7783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaab295af926f7b69bfb091188c5206692">SwLeRASTERSTRIDE</a> )(void *pJobContext, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *puStride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which allows the skin to increase the raster stride (byte offset between the start address of successive raster lines).  <a href="#gaab295af926f7b69bfb091188c5206692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga36e8277083d8600ee7926550c164e7a9">SwLeRASTERREQUIREMENTS</a> )(void *pJobContext, <a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *pRasterRequirements, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> fRenderingStarting)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which gives the skin the details of the raster it's about to be handed, and allocate memory to contain it.  <a href="#ga36e8277083d8600ee7926550c164e7a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8f41acc9f374e58cae02d5c184e3812d">SwLeRASTERDESTINATION</a> )(void *pJobContext, <a class="el" href="struct__raster__destination.html">RASTER_DESTINATION</a> *pRasterDestination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nFrameNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function which asks the skin to provide a memory address range into which to render.  <a href="#ga8f41acc9f374e58cae02d5c184e3812d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> )(<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a callback function which receives monitor information from the RIP for the current job.  <a href="#ga834e22669e4bbffef424b8e0a948f462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5a51b455377de612343ce995ad66452"></a><!-- doxytag: member="skinkit::SwLeRIPEXITCALLBACK" ref="gae5a51b455377de612343ce995ad66452" args=")(int32 errorCode, uint8 *pszText)" -->
typedef void(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gae5a51b455377de612343ce995ad66452">SwLeRIPEXITCALLBACK</a> )(<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> errorCode, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a callback function which is called when the RIP exits. Used in <code><a class="el" href="group__skinkit.html#ga60850c161b2dded4bfbb68ee305af6d5" title="Allows the caller to supply callback function to be called when the RIP exits.">SwLeSetRipExitFunction()</a></code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10bb022d5fa4155c2fc1960e7a910775"></a><!-- doxytag: member="skinkit::SwLeRIPREBOOTCALLBACK" ref="ga10bb022d5fa4155c2fc1960e7a910775" args=")(void)" -->
typedef void(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga10bb022d5fa4155c2fc1960e7a910775">SwLeRIPREBOOTCALLBACK</a> )(void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a callback function which is called when the RIP reboots. Used in <code><a class="el" href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54" title="Allows the caller to supply callback function to be called when the RIP reboots.">SwLeSetRipRebootFunction()</a></code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a> )(void *pJobContext, const void *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of callback functions triggered when a parameter is changed.  <a href="#gab3efc2deb5435af7f8523b1c17fadcc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3">SwWriteProbeLogFn</a> )(char *pBuffer, size_t nLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the write log function.  <a href="#ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ , <a class="el" href="group__skinkit.html#ggade9ca5088d171ad20b4c237f1c2d6260a7d610474d026e683990b7f249147bb21">SW_TRACE_PROBE</a>
, <a class="el" href="group__skinkit.html#ggade9ca5088d171ad20b4c237f1c2d6260af6079b114338cbe6a0441288f14ffbc5">SKINKIT_TRACE_N</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of trace names for skinkit. </p>
 <a href="group__skinkit.html#gade9ca5088d171ad20b4c237f1c2d6260">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ , <a class="el" href="group__skinkit.html#gga9e93d8eae633734dfeb29e24a1f3a7c0ac1ce327272b61119a27f04c89a22e13a">SW_TRACETYPE_TITLE</a>
, <a class="el" href="group__skinkit.html#gga9e93d8eae633734dfeb29e24a1f3a7c0a450f13b4bdfef4651eb9a7a687c99c97">SKINKIT_TRACETYPE_N</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of trace types for skinkit. </p>
 <a href="group__skinkit.html#ga9e93d8eae633734dfeb29e24a1f3a7c0">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga4e0b5658bf9c11a06579cfe17be185dd">SwLeInitRuntime</a> (void *pContext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes skinkit variables prior to starting the RIP.  <a href="#ga4e0b5658bf9c11a06579cfe17be185dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24">SwLeSDKStart</a> (size_t *RIP_maxAddressSpaceInBytes, size_t *RIP_workingSizeInBytes, void *pMemory, <a class="el" href="structSysMemFns.html">SysMemFns</a> *pSysMemFns, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **reasonText)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise SDK support libraries for the RIP.  <a href="#ga6f0a7db8aaffd844f27976a4d7eeac24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68">SwLeSDKEnd</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> exitCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the SDK support libraries.  <a href="#ga8d1f7eb90ba7129539c31a029447bd68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca">SwLeMemInit</a> (size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pre-initializes the RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.  <a href="#ga8ac29b66e38c1a2d41f50cca59a982ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga428d64db39435d1daa0fbdcb5d5a553d">SwLeAddCustomDevices</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nCustomDevices, <a class="el" href="structDeviceType.html">DEVICETYPE</a> **ppCustomDevices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <code>DEVICETYPE</code> objects to the array passed to the RIP during startup.  <a href="#ga428d64db39435d1daa0fbdcb5d5a553d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992">SwLeStart</a> (size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory, <a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> *pfnMonitor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the Harlequin RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.  <a href="#gaddcf18e2e9e136c151e5bbbcd5071992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga0a34398673384fea0f8529de48d7be6f">SwLeSetTickleTimerFunctions</a> (SwStartTickleTimerFn *pfnSwStartTickleTimer, SwStopTickleTimerFn *pfnSwStopTickleTimer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply timers for triggering the tickle callbacks.  <a href="#ga0a34398673384fea0f8529de48d7be6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga60850c161b2dded4bfbb68ee305af6d5">SwLeSetRipExitFunction</a> (<a class="el" href="group__skinkit.html#gae5a51b455377de612343ce995ad66452">SwLeRIPEXITCALLBACK</a> *pfnRipExit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply callback function to be called when the RIP exits.  <a href="#ga60850c161b2dded4bfbb68ee305af6d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54">SwLeSetRipRebootFunction</a> (<a class="el" href="group__skinkit.html#ga10bb022d5fa4155c2fc1960e7a910775">SwLeRIPREBOOTCALLBACK</a> *pfnRipReboot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the caller to supply callback function to be called when the RIP reboots.  <a href="#ga62c7802817cfecbdac9d1f751c778a54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga9ad325e19e38b2607563c50964bb9244">SwLeSetRipRendererThreads</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nThreads)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of renderer threads.  <a href="#ga9ad325e19e38b2607563c50964bb9244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816">SwLeStop</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request that the RIP shutdown.  <a href="#ga3d848af165c6fa12b1562f5a05af7816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaa381b394f5ddf59465e09cfcd02076e7">SwLeWaitForRIPThreadToExit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for the RIP thread started via <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> to exit.  <a href="#gaa381b394f5ddf59465e09cfcd02076e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga12c30a50c599d2a1bf0a5373d998dabc">SwLeExitCode</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the exit status of the RIP.  <a href="#ga12c30a50c599d2a1bf0a5373d998dabc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaca48331cf0f6d8166e24bbb922f32ced">SwLeShutdown</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs shutdown operations when the application exits.  <a href="#gaca48331cf0f6d8166e24bbb922f32ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b">SwLeJobStart</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, void *pJobContext)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares the Harlequin RIP to receive a PostScript language job.  <a href="#ga33c0049001c3e74b46fb4f40f83eb63b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaefd65dd3f56915ca62ea0a6a798e765d">SwLeSetRasterCallbacks</a> (<a class="el" href="group__skinkit.html#gaab295af926f7b69bfb091188c5206692">SwLeRASTERSTRIDE</a> *pfnRasterStride, <a class="el" href="group__skinkit.html#ga36e8277083d8600ee7926550c164e7a9">SwLeRASTERREQUIREMENTS</a> *pfnRasterRequirements, <a class="el" href="group__skinkit.html#ga8f41acc9f374e58cae02d5c184e3812d">SwLeRASTERDESTINATION</a> *pfnRasterDestination, <a class="el" href="group__skinkit.html#ga49784289c974157865016f5987db7783">SwLeRASTERCALLBACK</a> *pfnRaster)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the callback functions that the RIP will call back to present raster data to the skin.  <a href="#gaefd65dd3f56915ca62ea0a6a798e765d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab">SwLePs</a> (<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Passes a chunk of PostScript language data to the Harlequin RIP.  <a href="#gaf1f95a0fb78a44481db22364d64725ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05">SwLeJobEnd</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminates the current job.  <a href="#ga9a0e86c002e81c05816b9f0ab6c03b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaec1d8c37545ba11df97bdf6dd7652257">SwLeProcessingError</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether an error occurred in the most recent chunk of job data that was processed by the RIP.  <a href="#gaec1d8c37545ba11df97bdf6dd7652257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaee2af83f974f79696a8cfbd62077ab36">SwLeProcessingPs</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the skin that the RIP is now processing the job.  <a href="#gaee2af83f974f79696a8cfbd62077ab36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf831cd6870d9bbd693e49638228f08ff">SwLeProcessingJobEnd</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the skin that the RIP has finished processing the job.  <a href="#gaf831cd6870d9bbd693e49638228f08ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gabfa1ebf349f5d4048a26a653c7d8071b">SwLeGetDeviceHandle</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszDevice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a skin handle to a mounted RIP device, which can then be used to get more information about the device.  <a href="#gabfa1ebf349f5d4048a26a653c7d8071b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174">SwLeGetIntDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pInt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of an integer device parameter.  <a href="#ga91feee405edc8d9ba865a0254f809174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab49f1c3e18713b2fbc9a136353bc613a">SwLeGetBoolDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *pBool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a boolean device parameter.  <a href="#gab49f1c3e18713b2fbc9a136353bc613a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga834f23f9f6d90a32aeddb2e594881ff0">SwLeGetFloatDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, float *pFloat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a floating-point (real) device parameter.  <a href="#ga834f23f9f6d90a32aeddb2e594881ff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga30e18988f685bf9207fe03cbbd740cc4">SwLeGetStringDevParam</a> (void *pDeviceHandle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszParamName, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **ppStr, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pStrLen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to get the current value of a string device parameter.  <a href="#ga30e18988f685bf9207fe03cbbd740cc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga55e714025403a8245ced9d59a9737fe2">SkinExit</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> n, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tidy up and exit.  <a href="#ga55e714025403a8245ced9d59a9737fe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga10f01be68c40a1737bcd5074f287e39f">SkinReboot</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when RIP reboots.  <a href="#ga10f01be68c40a1737bcd5074f287e39f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf154f5d17c7794c1c0dec7d9ce405845">SkinMonitorl</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbData, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszMonitorData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a message through the monitor callback, if provided.  <a href="#gaf154f5d17c7794c1c0dec7d9ce405845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e">SkinMonitorf</a> (const char *pszFormat,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display a formatted message through the monitor callback, if provided.  <a href="#gae89604ecf1f975b5372a72800a612e0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaadd3e110359f338c2c7bd17cbfb69c13">SkinVMonitorf</a> (const char *pszFormat, va_list vlist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identical to <code><a class="el" href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e" title="Display a formatted message through the monitor callback, if provided.">SkinMonitorf()</a></code>, where the vararg list is explicit.  <a href="#gaadd3e110359f338c2c7bd17cbfb69c13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gac2263800ddca2b939f4a0ad7068c9fde">KSetSystemErrorLevel</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> errlevel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set system error record level.  <a href="#gac2263800ddca2b939f4a0ad7068c9fde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5f6ba6390beba576b1ee0a982942c38"></a><!-- doxytag: member="skinkit::KGetSystemErrorLevel" ref="gad5f6ba6390beba576b1ee0a982942c38" args="(void)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gad5f6ba6390beba576b1ee0a982942c38">KGetSystemErrorLevel</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get system error record level. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga5f5fc59598bf1fe8cca6f803303941da">PKRecordSystemError</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> errcode, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> errline, const char *pErrfile, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fSysErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record through the monitor callback system errors according to the error level set by <code><a class="el" href="group__skinkit.html#gac2263800ddca2b939f4a0ad7068c9fde" title="Set system error record level.">KSetSystemErrorLevel()</a></code>.  <a href="#ga5f5fc59598bf1fe8cca6f803303941da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gad0d851d49d15c8c398c8e3452647c4ac">SwLeProbeLogInit</a> (const char **ppTraceNames, int nTraceNames, int *pabTraceEnabled, const char **ppTraceTypeNames, int nTraceTypeNames, const <a class="el" href="structsw__tracegroup__t.html">sw_tracegroup_t</a> *pGroupDetails, int nGroupDetails, char *pszArg, char *pszLog, <a class="el" href="group__skinkit.html#ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3">SwWriteProbeLogFn</a> *pfnWriteLog)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise probe logging.  <a href="#gad0d851d49d15c8c398c8e3452647c4ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaf318a6ae0eec378f030c411eebefc9ad">SwLeProbeLogFlush</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush probe log.  <a href="#gaf318a6ae0eec378f030c411eebefc9ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga51fade6543854892e0fa0e9dcde245cb">SwLeProbeLogFinish</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish probe logging.  <a href="#ga51fade6543854892e0fa0e9dcde245cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gaed01e9366908c8c379b615bd8519a8e7">SwLeProbeOption</a> (<a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *handler, const char *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the probe handler function for the specified arg.  <a href="#gaed01e9366908c8c379b615bd8519a8e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga258f7b9c321e1d524959dc6404cd590b">SwLeProfileOption</a> (<a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *handler, const char *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the profile handler function for the specified arg.  <a href="#ga258f7b9c321e1d524959dc6404cd590b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga712af6ee16e4d4971da77026a2c1d762"></a><!-- doxytag: member="skinkit::SwLeProbeOptionUsage" ref="ga712af6ee16e4d4971da77026a2c1d762" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga712af6ee16e4d4971da77026a2c1d762">SwLeProbeOptionUsage</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display the default probe usage information. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gab4ec127a624caf97820ae6a1ad24dd19">SwLeSetTraceHandler</a> (<a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *handler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a probe callback function to capture fine-grained tracing information.  <a href="#gab4ec127a624caf97820ae6a1ad24dd19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#gabd9b960c1dabca86da6695cbf5691c7b">SwLeTraceEnable</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> trace, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a probe to capture fine-grained tracing information.  <a href="#gabd9b960c1dabca86da6695cbf5691c7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__skinkit.html#ga8f04bbe0cdae9a4b9c10214f90cf8001">SwLeProbe</a> (int id, int type, intptr_t designator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call the skinkit trace handler, if installed.  <a href="#ga8f04bbe0cdae9a4b9c10214f90cf8001"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gab4245913154ea422b9914d6514389af2"></a><!-- doxytag: member="skinkit.h::SKINKIT_TRACENAMES" ref="gab4245913154ea422b9914d6514389af2" args="(macro_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SKINKIT_TRACENAMES</td>
          <td>(</td>
          <td class="paramtype">macro_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="comment">/* Skinkit extensions to core trace names. */</span> \
  macro_(PROBE) <span class="comment">/* Self monitoring for log trace handler */</span> \
  macro_(KCALLRASTERCALLBACK) <span class="comment">/* In KCallRasterCallback callback */</span> \
  macro_(KCALLRASTERREQUIREMENTSCALLBACK) <span class="comment">/* In KCallRasterRequirements callback */</span> \
  macro_(KCALLRASTERDESTINATIONCALLBACK) <span class="comment">/* In KCallRasterDestination callback */</span> \
  macro_(KCALLPARAMCALLBACK) <span class="comment">/* In KCallParamCallback callback */</span> \
  macro_(STOREBANDINCACHE)   <span class="comment">/* In storeBandInCache function */</span> \
  macro_(TIMELINE)           <span class="comment">/* Unspecified timeline operations. */</span> \
  <span class="comment">/* We only distinguish timelines which may are not covered adequately by \</span>
<span class="comment">     other probes, timelines which may be extended by children, and/or have \</span>
<span class="comment">     progress that is useful to capture. */</span>   \
  macro_(FILE_PROGRESS) <span class="comment">/* Core job file progress timeline */</span> \
  macro_(JOB_STREAM_TL) <span class="comment">/* Core job stream timeline */</span> \
  macro_(JOB_TL)        <span class="comment">/* Core job running timeline */</span> \
  macro_(INTERPRET_PAGE_TL) <span class="comment">/* Core interpreting page timeline */</span> \
  macro_(RENDER_PAGE_TL) <span class="comment">/* Core rendering page timeline */</span> \
  macro_(RR_SCANNING_TL) <span class="comment">/* Core retained raster scan timeline */</span> \
  macro_(TRAP_PREPARATION_TL) <span class="comment">/* Core trapping preparation timeline */</span> \
  macro_(TRAP_GENERATION_TL) <span class="comment">/* Core trapping generation timeline */</span> \
  macro_(PGB_TL)
</pre></div>
<p>Extended trace names for skinkit. </p>
<p>These are defined using a macro expansion, so the names can be re-used for other purposes (stringification, usage strings) without having maintainers having to modify every skin which uses the trace facility. </p>

</div>
</div>
<a class="anchor" id="ga12d440f8e76480185e3452a3230a90db"></a><!-- doxytag: member="skinkit.h::SKINKIT_TRACETYPES" ref="ga12d440f8e76480185e3452a3230a90db" args="(macro_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SKINKIT_TRACETYPES</td>
          <td>(</td>
          <td class="paramtype">macro_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">macro_(TITLE)         <span class="comment">/* Timeline re-title. */</span> \
  macro_(PROGRESS)      <span class="comment">/* Timeline progress. */</span> \
  macro_(EXTEND)        <span class="comment">/* Timeline extend. */</span> \
  macro_(ENDING)        <span class="comment">/* Timeline notified of end. */</span> \
  macro_(ABORTING)
</pre></div>
<p>Extended trace types for skinkit. </p>
<p>These are defined using a macro expansion, so the names can be re-used for other purposes (stringification, usage strings) without having maintainers having to modify every skin which uses the trace facility. The timeline types have special treatment in the skin so that the timeline reference can be used as the designator. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga834e22669e4bbffef424b8e0a948f462"></a><!-- doxytag: member="skinkit.h::SwLeMONITORCALLBACK" ref="ga834e22669e4bbffef424b8e0a948f462" args=")(uint32 cbBuffer, uint8 *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( <a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a>)(<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> cbBuffer, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines a callback function which receives monitor information from the RIP for the current job. </p>
<p>Text is streamed, so error messages and so on may span more than one call. Used in <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gab3efc2deb5435af7f8523b1c17fadcc4"></a><!-- doxytag: member="skinkit.h::SwLeParamCallback" ref="gab3efc2deb5435af7f8523b1c17fadcc4" args=")(void *pJobContext, const void *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( <a class="el" href="group__skinkit.html#gab3efc2deb5435af7f8523b1c17fadcc4">SwLeParamCallback</a>)(void *pJobContext, const void *param)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of callback functions triggered when a parameter is changed. </p>
<p>Callback functions may be registered against some parameter sets, to monitor changes to their values. This is often used to select the backend behavior when the PageBufferType pagebuffer parameter is changed. The skin should respond by calling <code>SwLeSetRasterCallbacks</code> with appropriate callback functions for the selected backend.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An opaque pointer to caller-managed data, as originally provided by <code>SwLeJobStart</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>A generic pointer, either pointing to an integer, a float, a boolean (integer), or a NUL-terminated string containing the new value of the pagebuffer parameter. The value pointed to should not be changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the Param* enumeration values from <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback deliberately does not expose the name or type of the parameter. Individual callbacks should be registered for each parameter of interest, and the function used to register the callback should verify the type of callback via a separate parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga49784289c974157865016f5987db7783"></a><!-- doxytag: member="skinkit.h::SwLeRASTERCALLBACK" ref="ga49784289c974157865016f5987db7783" args=")(void *pJobContext, RasterDescription *pRasterDescription, uint8 *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( <a class="el" href="group__skinkit.html#ga49784289c974157865016f5987db7783">SwLeRASTERCALLBACK</a>)(void *pJobContext, <a class="el" href="structrasterDescription.html">RasterDescription</a> *pRasterDescription, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines a callback function which receives bands of raster delivered from the RIP for the current job. </p>
<p>When raster data becomes available from the RIP, it is supplied one band at a time to the host application by the RIP calling an implementation of this callback, as supplied to <a class="el" href="group__skinkit.html#gaefd65dd3f56915ca62ea0a6a798e765d" title="Sets the callback functions that the RIP will call back to present raster data to...">SwLeSetRasterCallbacks()</a>.</p>
<p>The raster data is received in <code>pBuffer</code>, and is described by <code>pRasterDescription</code>, which among other things gives the number of color channels, their order, the image size and band size.</p>
<p>The application needs to keep track of where the raster data is in the overall page image, since it needs to know when the raster is complete.</p>
<p>The last band of data could be smaller than previous bands. Once again, the application needs to work this out for itself.</p>
<p>The data pointed to by the <code>pRasterDescription</code> will remain constant during the repeated calls to the raster callback function. After the last band of raster is passed to the application, the RIP frees up this <code>pRasterDescription</code>, and so the application must take care not to reference it after this point.</p>
<p>At the end of a job, after a full set of raster callback invocations has completed for the final page, an additional call is made to the raster callback with NULL as the <code>pBuffer</code> argument. The <code>pRasterDescription</code> argument is not valid for this call. This last call signals the end of the job, and can be used in cases where the raster handling work is not self-contained on a per-page basis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An opaque pointer to caller-managed data, as originally provided by <code>SwLeJobStart</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRasterDescription</em>&nbsp;</td><td>A pointer to a <code>RasterDescription</code> structure describing the format of the data in <em>pBuffer</em>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>The rendered data for a band, or NULL for the end of job callback.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The buffer has been successfully handled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>If the raster callback function returns <code>FALSE</code>, the RIP will abort page rendering with an I/O error, and no more calls to the raster callback will be made for that page (or even job, depending on how the PostScript error handling has been managed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f41acc9f374e58cae02d5c184e3812d"></a><!-- doxytag: member="skinkit.h::SwLeRASTERDESTINATION" ref="ga8f41acc9f374e58cae02d5c184e3812d" args=")(void *pJobContext, RASTER_DESTINATION *pRasterDestination, int32 nFrameNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( <a class="el" href="group__skinkit.html#ga8f41acc9f374e58cae02d5c184e3812d">SwLeRASTERDESTINATION</a>)(void *pJobContext, <a class="el" href="struct__raster__destination.html">RASTER_DESTINATION</a> *pRasterDestination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nFrameNumber)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which asks the skin to provide a memory address range into which to render. </p>
<p>The use of this callback is optional, and it is set via a call to <code>SwLeSetRasterCallbacks</code>. Together with <code>SwLeRASTERREQUIREMENTS</code>, it gives a mechanism for the skin to provide all of the memory into which the RIP should render, which in turn eliminates memory copying operations and so improves performance.</p>
<p>For the given frame and band number, the skin should calculate the correct destination range and return it in <code>memory_base</code> and <code>memory_ceiling</code>. This range is exclusive, i.e. <code>memory_ceiling</code> is the address of the first byte that the RIP is not allowed to write into.</p>
<p><code>handled</code> is a flag which the callee sets when it has decisively dealt with the call. Not setting the flag before returning indicates to the RIP that the callee would like to be called again with the same parameters. This is used when the skin needs to delay to allow some output or other work to progress before the RIP continues, or to split the rendering of a single RIP band into multiple passes in order to better suit the rest of the workflow.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An opaque pointer to caller-managed data, as originally provided by <code>SwLeJobStart</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRasterDestination</em>&nbsp;</td><td>The RASTER_DESTINATION structure shared by RIP and skin.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nFrameNumber</em>&nbsp;</td><td>The index of the current frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function should return 0 for success, -1 for an error (if the stride value is outside of an acceptable range), or +1 to indicate that the RIP should call the skin again. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36e8277083d8600ee7926550c164e7a9"></a><!-- doxytag: member="skinkit.h::SwLeRASTERREQUIREMENTS" ref="ga36e8277083d8600ee7926550c164e7a9" args=")(void *pJobContext, RASTER_REQUIREMENTS *pRasterRequirements, HqBool fRenderingStarting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( <a class="el" href="group__skinkit.html#ga36e8277083d8600ee7926550c164e7a9">SwLeRASTERREQUIREMENTS</a>)(void *pJobContext, <a class="el" href="struct__raster__requirements.html">RASTER_REQUIREMENTS</a> *pRasterRequirements, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> fRenderingStarting)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which gives the skin the details of the raster it's about to be handed, and allocate memory to contain it. </p>
<p>The use of this callback is optional, and it is set via a call to <code>SwLeSetRasterCallbacks</code>. Together with <code>SwLeRASTERDESTINATION</code>, it gives a mechanism for the skin to provide all of the memory into which the RIP should render, which in turn eliminates memory copying operations and so improves performance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An opaque pointer to caller-managed data, as originally provided by <code>SwLeJobStart</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRasterRequirements</em>&nbsp;</td><td>A pointer to the <code>RASTER_REQUIREMENTS</code> structure shared by RIP and skin.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fRenderingStarting</em>&nbsp;</td><td>There are two points in the sequence of processing a job at which the RIP will call this type of function. The first is when the page device has just changed, and the second is when rendering is starting imminently. If the latter is true, the <em>fRenderingStarting</em> flag will be TRUE and no further changes to the page device are possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function should return 0 for success, -1 for an error, or +1 to indicate that the RIP should call the skin again.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It may be that the best approach is for the skin to allocate raster memory during the earlier calls to this type of function, i.e. with <code>fRenderingStarting</code> is FALSE, to ensure that the raster memory is always available. Depending on configuration, it's possible that if raster memory allocation happens later that the RIP uses all available memory and there's not enough left for raster memory when needed. However, if the skin is in a position to guarantee that a later allocation when <code>fRenderingStarting</code> is TRUE will succeed, that approach is preferable - not least because the page device changes quite often - perhaps a dozen or more times per job. When Harlequin Parallel Pages is enabled, calls to this function may be made from both interpreter (<code>fRenderingStarting</code> FALSE) and renderer threads (<code>fRenderingStarting</code> TRUE) simultaneously. The skin must <em>not</em> assume that a renderer call is related to the most recent interpreter call. The <code>eraseno</code> field in the <code>RASTER_REQUIREMENTS</code> structure can be used to correlate calls from the interpreter with subsequent renderer calls. Not every interpreter call will have an associated call from a renderer. The <code>eraseno</code> field increases monotonically for each raster description, so when a renderer call is received, all buffers allocated for raster descriptions with lower values of <code>eraseno</code> can be discarded.</dd></dl>
<p>The RIP will set all fields in the <code>RASTER_REQUIREMENTS</code> argument, all of them except two are used by the RIP to pass information to the skin:</p>
<p><code>have_framebuffer</code> is a flag which the callee can set to indicate that it has will allocate the memory for all of the band buffers (a framebuffer). This can lead to extra efficiencies, by avoiding data copying. For any particular value of the <code>eraseno</code> field in <code>RASTER_REQUIREMENTS</code> argument, the skin must <em>not</em> change its mind about the setting of <code>have_framebuffer</code> between the interpreter and renderer calls to this function.</p>
<p><code>handled</code> is a flag which the callee sets when it has decisively dealt with the call. Not setting the flag before returning indicates to the RIP that the callee would like to be called again with the same parameters. This is used when the skin needs to delay to allow some output or other work to progress before the RIP continues. Note that the maximum such delay should be around 100 milliseconds. </p>

</div>
</div>
<a class="anchor" id="gaab295af926f7b69bfb091188c5206692"></a><!-- doxytag: member="skinkit.h::SwLeRASTERSTRIDE" ref="gaab295af926f7b69bfb091188c5206692" args=")(void *pJobContext, uint32 *puStride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( <a class="el" href="group__skinkit.html#gaab295af926f7b69bfb091188c5206692">SwLeRASTERSTRIDE</a>)(void *pJobContext, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *puStride)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function which allows the skin to increase the raster stride (byte offset between the start address of successive raster lines). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An opaque pointer to caller-managed data, as originally provided by <code>SwLeJobStart</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>puStride</em>&nbsp;</td><td>Pointer to an unsigned integer which is set on entry to the raster line length in bytes which the RIP is set to use. The skin may increase this value to better suit its requirements, for example to force line start addresses to coincide with cache lines or DMA ranges. Of course, any increase will necessarily mean a larger memory requirement to hold the raster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function should return 0 for success, -1 for an error (if the stride value is outside of an acceptable range), or +1 to indicate that the RIP should call the skin again. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3"></a><!-- doxytag: member="skinkit.h::SwWriteProbeLogFn" ref="ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3" args=")(char *pBuffer, size_t nLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( <a class="el" href="group__skinkit.html#ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3">SwWriteProbeLogFn</a>)(char *pBuffer, size_t nLength)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef for the write log function. </p>
<p>A callback function can be provided to output the log data rather than using the default file output functions. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gade9ca5088d171ad20b4c237f1c2d6260"></a><!-- doxytag: member="skinkit.h::@66" ref="gade9ca5088d171ad20b4c237f1c2d6260" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of trace names for skinkit. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggade9ca5088d171ad20b4c237f1c2d6260a7d610474d026e683990b7f249147bb21"></a><!-- doxytag: member="SW_TRACE_PROBE" ref="ggade9ca5088d171ad20b4c237f1c2d6260a7d610474d026e683990b7f249147bb21" args="" -->SW_TRACE_PROBE</em>&nbsp;</td><td>
<p>Base value for skin trace names. This MUST be the first enum value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggade9ca5088d171ad20b4c237f1c2d6260af6079b114338cbe6a0441288f14ffbc5"></a><!-- doxytag: member="SKINKIT_TRACE_N" ref="ggade9ca5088d171ad20b4c237f1c2d6260af6079b114338cbe6a0441288f14ffbc5" args="" -->SKINKIT_TRACE_N</em>&nbsp;</td><td>
<p>Starting point for skintest/OIL trace identifiers. This MUST be the last enum value. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e93d8eae633734dfeb29e24a1f3a7c0"></a><!-- doxytag: member="skinkit.h::@67" ref="ga9e93d8eae633734dfeb29e24a1f3a7c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of trace types for skinkit. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9e93d8eae633734dfeb29e24a1f3a7c0ac1ce327272b61119a27f04c89a22e13a"></a><!-- doxytag: member="SW_TRACETYPE_TITLE" ref="gga9e93d8eae633734dfeb29e24a1f3a7c0ac1ce327272b61119a27f04c89a22e13a" args="" -->SW_TRACETYPE_TITLE</em>&nbsp;</td><td>
<p>Base value for skinkit trace types. This MUST be the first enum value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9e93d8eae633734dfeb29e24a1f3a7c0a450f13b4bdfef4651eb9a7a687c99c97"></a><!-- doxytag: member="SKINKIT_TRACETYPE_N" ref="gga9e93d8eae633734dfeb29e24a1f3a7c0a450f13b4bdfef4651eb9a7a687c99c97" args="" -->SKINKIT_TRACETYPE_N</em>&nbsp;</td><td>
<p>Starting point for skintest/OIL trace type identifiers. This MUST be the last enum value. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac2263800ddca2b939f4a0ad7068c9fde"></a><!-- doxytag: member="skinkit.h::KSetSystemErrorLevel" ref="gac2263800ddca2b939f4a0ad7068c9fde" args="(int32 errlevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> KSetSystemErrorLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>errlevel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set system error record level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errlevel</em>&nbsp;</td><td>Request level: 0 - no record; 1 - record errors except file/path not found. 2 - record all errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if fLevel is valid; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f5fc59598bf1fe8cca6f803303941da"></a><!-- doxytag: member="skinkit.h::PKRecordSystemError" ref="ga5f5fc59598bf1fe8cca6f803303941da" args="(int32 errcode, int32 errline, const char *pErrfile, int32 fSysErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKRecordSystemError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>errcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>errline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pErrfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fSysErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Record through the monitor callback system errors according to the error level set by <code><a class="el" href="group__skinkit.html#gac2263800ddca2b939f4a0ad7068c9fde" title="Set system error record level.">KSetSystemErrorLevel()</a></code>. </p>
<p>Note that the error will not be recorded if no monitor callback has been supplied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errcode</em>&nbsp;</td><td>Error code from the failed operation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errline</em>&nbsp;</td><td>Line number where error occurred. Use the <code>__LINE__</code> macro, as per an assertion failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pErrfile</em>&nbsp;</td><td>Source file where the error occurred. Use the <code>__FILE__</code> macro, as per an assertion failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fSysErr</em>&nbsp;</td><td>Indicates whether the error code corresponds to an error specified by the operating system. If this is <code>TRUE</code>, the implementation will use platform-specific code to transform <code>errcode</code> into a human-readable string. (This can be done with <code>FormatMessage()</code> on Windows, and <code>strerror()</code> on Unix-based platforms, for example). If this argument is <code>FALSE</code>, only the numeric error code will be reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55e714025403a8245ced9d59a9737fe2"></a><!-- doxytag: member="skinkit.h::SkinExit" ref="ga55e714025403a8245ced9d59a9737fe2" args="(int32 n, uint8 *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkinExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tidy up and exit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Reason for exit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The exit code</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called by the RIP when it exits. It is responsible for calling calling the function registered by <code><a class="el" href="group__skinkit.html#ga60850c161b2dded4bfbb68ee305af6d5" title="Allows the caller to supply callback function to be called when the RIP exits.">SwLeSetRipExitFunction()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gae89604ecf1f975b5372a72800a612e0e"></a><!-- doxytag: member="skinkit.h::SkinMonitorf" ref="gae89604ecf1f975b5372a72800a612e0e" args="(const char *pszFormat,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkinMonitorf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display a formatted message through the monitor callback, if provided. </p>
<p>The semantics are roughly along the lines of <code>printf()</code> or <code>fprintf()</code>, but with output going to the supplied monitor callback, so as to isolate the skin from the notion of standard C streams. This function should be used in place of C stdio functions whenever possible.</p>
<p>Messages are formatted into a fixed-size buffer. The message will be truncated if it does not fit into the buffer. If this happens, an additional message will be sent to the monitor callback, warning about the truncation.</p>
<p>If no monitor callback has been supplied, this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFormat</em>&nbsp;</td><td>Format string, as per C library formatting functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf154f5d17c7794c1c0dec7d9ce405845"></a><!-- doxytag: member="skinkit.h::SkinMonitorl" ref="gaf154f5d17c7794c1c0dec7d9ce405845" args="(int32 cbData, uint8 *pszMonitorData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkinMonitorl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>cbData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszMonitorData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display a message through the monitor callback, if provided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbData</em>&nbsp;</td><td>The length, in bytes, of a NUL-terminated monitor information string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszMonitorData</em>&nbsp;</td><td>The NUL-terminated monitor information string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10f01be68c40a1737bcd5074f287e39f"></a><!-- doxytag: member="skinkit.h::SkinReboot" ref="ga10f01be68c40a1737bcd5074f287e39f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkinReboot </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when RIP reboots. </p>
<p>This function is called by the RIP when it exits. It is responsible for calling calling the function registered by <code><a class="el" href="group__skinkit.html#ga62c7802817cfecbdac9d1f751c778a54" title="Allows the caller to supply callback function to be called when the RIP reboots.">SwLeSetRipRebootFunction()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gaadd3e110359f338c2c7bd17cbfb69c13"></a><!-- doxytag: member="skinkit.h::SkinVMonitorf" ref="gaadd3e110359f338c2c7bd17cbfb69c13" args="(const char *pszFormat, va_list vlist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkinVMonitorf </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>vlist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identical to <code><a class="el" href="group__skinkit.html#gae89604ecf1f975b5372a72800a612e0e" title="Display a formatted message through the monitor callback, if provided.">SkinMonitorf()</a></code>, where the vararg list is explicit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszFormat</em>&nbsp;</td><td>Format string, as per C library formatting functions.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vlist</em>&nbsp;</td><td>Arguments for substitution into the format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga428d64db39435d1daa0fbdcb5d5a553d"></a><!-- doxytag: member="skinkit.h::SwLeAddCustomDevices" ref="ga428d64db39435d1daa0fbdcb5d5a553d" args="(int32 nCustomDevices, DEVICETYPE **ppCustomDevices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeAddCustomDevices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>nCustomDevices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDeviceType.html">DEVICETYPE</a> **&nbsp;</td>
          <td class="paramname"> <em>ppCustomDevices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <code>DEVICETYPE</code> objects to the array passed to the RIP during startup. </p>
<p>This call is optional. It may be called once before <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> to include additional DEVICETYPEs in the array passed to the the RIP.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nCustomDevices</em>&nbsp;</td><td>The number of DEVICETYPEs to add.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppCustomDevices</em>&nbsp;</td><td>Pointer to array of DEVICETYPEs to be add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12c30a50c599d2a1bf0a5373d998dabc"></a><!-- doxytag: member="skinkit.h::SwLeExitCode" ref="ga12c30a50c599d2a1bf0a5373d998dabc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> SwLeExitCode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the exit status of the RIP. </p>
<p>The exit status is only valid after the RIP thread terminates (i.e., after return from the <code><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816" title="Request the RIP to stop.">SwLeStop()</a></code> function). It is zero if the RIP terminated cleanly, non-zero otherwise. </p>

</div>
</div>
<a class="anchor" id="gab49f1c3e18713b2fbc9a136353bc613a"></a><!-- doxytag: member="skinkit.h::SwLeGetBoolDevParam" ref="gab49f1c3e18713b2fbc9a136353bc613a" args="(void *pDeviceHandle, uint8 *pszParamName, HqBool *pBool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeGetBoolDevParam </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pDeviceHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszParamName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *&nbsp;</td>
          <td class="paramname"> <em>pBool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience function to get the current value of a boolean device parameter. </p>
<p>For full documentation, see <code><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174" title="A convenience function to get the current value of an integer device parameter.">SwLeGetIntDevParam()</a></code>. The contract of this function is the same, except that it specializes for booleans instead of integers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDeviceHandle</em>&nbsp;</td><td>A valid skin device handle.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszParamName</em>&nbsp;</td><td>NUL-terminated name of the required parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBool</em>&nbsp;</td><td>If the function succeeds, this receives the current value of the specified device parameter. If the function fails, the contents are left undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gabfa1ebf349f5d4048a26a653c7d8071b"></a><!-- doxytag: member="skinkit.h::SwLeGetDeviceHandle" ref="gabfa1ebf349f5d4048a26a653c7d8071b" args="(uint8 *pszDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SwLeGetDeviceHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszDevice</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a skin handle to a mounted RIP device, which can then be used to get more information about the device. </p>
<p>The skin handle should be passed back into functions that deal with the device, such as <code><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174" title="A convenience function to get the current value of an integer device parameter.">SwLeGetIntDevParam()</a></code>. This function is essentially the skin equivalent of <code><a class="el" href="group__PLUGIN__swdevice.html#ga80a2ccf547abf59b80860bcc1efcfd57" title="SwFindDevice looks up a device by name, returns NULL on failure.">SwFindDevice()</a></code>. However, it is somewhat less powerful, because a skin device handle cannot be used to access the full range of the core RIP device interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pszDevice</em>&nbsp;</td><td>NUL-terminated name of the device. If no device with the given name is mounted, <code>NULL</code> will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A skin handle to the device, which can subsequently be passed into functions such as <code><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174" title="A convenience function to get the current value of an integer device parameter.">SwLeGetIntDevParam()</a></code>. Once obtained, a skin handle remains valid for as long as the underlying device is mounted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga834f23f9f6d90a32aeddb2e594881ff0"></a><!-- doxytag: member="skinkit.h::SwLeGetFloatDevParam" ref="ga834f23f9f6d90a32aeddb2e594881ff0" args="(void *pDeviceHandle, uint8 *pszParamName, float *pFloat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeGetFloatDevParam </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pDeviceHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszParamName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pFloat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience function to get the current value of a floating-point (real) device parameter. </p>
<p>For full documentation, see <code><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174" title="A convenience function to get the current value of an integer device parameter.">SwLeGetIntDevParam()</a></code>. The contract of this function is the same, except that it specializes for floats instead of integers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDeviceHandle</em>&nbsp;</td><td>A valid skin device handle.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszParamName</em>&nbsp;</td><td>NUL-terminated name of the required parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFloat</em>&nbsp;</td><td>If the function succeeds, this receives the current value of the specified device parameter. If the function fails, the contents are left undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91feee405edc8d9ba865a0254f809174"></a><!-- doxytag: member="skinkit.h::SwLeGetIntDevParam" ref="ga91feee405edc8d9ba865a0254f809174" args="(void *pDeviceHandle, uint8 *pszParamName, int32 *pInt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeGetIntDevParam </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pDeviceHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszParamName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pInt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience function to get the current value of an integer device parameter. </p>
<p>The caller must first obtain a valid skin device handle, which is then passed into this function. For example, to get the <code>PageNumber</code> parameter of the <code>pagebuffer</code> device, use the following code:-</p>
<div class="fragment"><pre class="fragment">

   void *pgbdev = SwLeGetDeviceHandle( (uint8*) "pagebuffer" );
   if ( pgbdev != NULL )
   {
     int32 pageno;
     int32 result = SwLeGetIntDevParam( pgbdev, (uint8*) "PageNumber", &amp;pageno );
   }

   </pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDeviceHandle</em>&nbsp;</td><td>A valid skin device handle, as obtained from a prior call to <code><a class="el" href="group__skinkit.html#gabfa1ebf349f5d4048a26a653c7d8071b" title="Get a skin handle to a mounted RIP device, which can then be used to get more information...">SwLeGetDeviceHandle()</a></code>. It is safe to pass <code>NULL</code>, but the function will fail and return <code>FALSE</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszParamName</em>&nbsp;</td><td>NUL-terminated name of the required parameter. This should not use PostScript syntax - there should be no leading slash. For example, <code>"PageNumber"</code> is correct, while <code>"/PageNumber"</code> is not.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pInt</em>&nbsp;</td><td>If the function succeeds, this receives the current value of the specified device parameter. If the function fails, the contents are left undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds; <code>FALSE</code> if the function fails. Reasons why the function may fail include the following:-</dd></dl>
<ul>
<li><code>NULL</code> was passed as <code>pDeviceHandle</code>.</li>
<li>The device handle is no longer valid, because the device was dismounted since the handle was obtained.</li>
<li>The name of the parameter is unknown to the device. It might be mis-spelled, for instance, or have a spurious leading slash character.</li>
<li>The parameter is not of integer type.</li>
</ul>
<p>This convenience routine does not distinguish between the reasons for failure. Use the core RIP interface directly for richer diagnostics. </p>

</div>
</div>
<a class="anchor" id="ga30e18988f685bf9207fe03cbbd740cc4"></a><!-- doxytag: member="skinkit.h::SwLeGetStringDevParam" ref="ga30e18988f685bf9207fe03cbbd740cc4" args="(void *pDeviceHandle, uint8 *pszParamName, uint8 **ppStr, int32 *pStrLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeGetStringDevParam </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pDeviceHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pszParamName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **&nbsp;</td>
          <td class="paramname"> <em>ppStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *&nbsp;</td>
          <td class="paramname"> <em>pStrLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience function to get the current value of a string device parameter. </p>
<p>For full documentation, see <code><a class="el" href="group__skinkit.html#ga91feee405edc8d9ba865a0254f809174" title="A convenience function to get the current value of an integer device parameter.">SwLeGetIntDevParam()</a></code>. The contract of this function is the same, except that it specializes for strings instead of integers.</p>
<p>The string memory returned by this function is owned by the underlying device, not by the caller. The caller should not free the string. The caller should make its own copy if the data is needed persistently.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pDeviceHandle</em>&nbsp;</td><td>A valid skin device handle.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszParamName</em>&nbsp;</td><td>NUL-terminated name of the required parameter.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppStr</em>&nbsp;</td><td>If the function succeeds, this receives a pointer to the parameter value. This string data is not necessarily NUL-terminated. The length of the string's valid portion is returned separately. If the function fails, the contents are undefined.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pStrLen</em>&nbsp;</td><td>If the function succeeds, this receives the number of valid character bytes in the string. If the function fails, the contents are undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e0b5658bf9c11a06579cfe17be185dd"></a><!-- doxytag: member="skinkit.h::SwLeInitRuntime" ref="ga4e0b5658bf9c11a06579cfe17be185dd" args="(void *pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeInitRuntime </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pContext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes skinkit variables prior to starting the RIP. </p>
<p>This function must be called before each attempt to start or restart the RIP. It initialises or re-initialises variables which skinkit code expects to have known initial values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pContext</em>&nbsp;</td><td>Currently unused - clients should pass NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently always returns TRUE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This should be the first SDK function called by the skin. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a0e86c002e81c05816b9f0ab6c03b05"></a><!-- doxytag: member="skinkit.h::SwLeJobEnd" ref="ga9a0e86c002e81c05816b9f0ab6c03b05" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeJobEnd </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminates the current job. </p>
<p>It will return <code>FALSE</code> if <a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a> has not been called first.</p>
<p>(Internally, this function closes the <code>%ps%</code> file by returning zero bytes, which has the effect of calling close and terminating the job. Could be done by <a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a> passing a zero length buffer, but it is cleaner this way.)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> on success, and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga33c0049001c3e74b46fb4f40f83eb63b"></a><!-- doxytag: member="skinkit.h::SwLeJobStart" ref="ga33c0049001c3e74b46fb4f40f83eb63b" args="(uint32 cbBuffer, uint8 *pBuffer, void *pJobContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeJobStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>cbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pJobContext</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares the Harlequin RIP to receive a PostScript language job. </p>
<p>This function must be called before feeding any job data to the RIP. It must be called after booting the RIP using <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>. It must not be called while a job is in progress, and returns <code>FALSE</code> if that happens.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbBuffer</em>&nbsp;</td><td>The number of characters in the (not necessarily nul-terminated) string <code>pBuffer</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>A pointer to the "config job": a PostScript language fragment which is run at save level 1 to set the correct environment for the job, or NULL. This argument can be NULL, in which case <code>cbBuffer</code> should be zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pJobContext</em>&nbsp;</td><td>An arbitrary pointer to caller-managed data. This will be passed as the first argument to the raster data callback and other callbacks during execution of the job.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>If the job was started successfully. In this case, <code><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a></code> must be called after the job data has been presented to the RIP, even if a subsequent <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> call returns an error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>If the job was not started successfully. The application may call <code><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a></code> again, with corrected configuration data, or may terminate with an error.</td></tr>
  </table>
  </dd>
</dl>
<p>(Internally, this call causes <code>bytesavailable</code> to be set on the config device, which will then cause a read on the config device. That will return <code>pBuffer</code> contents for <code>setrealdevice</code>, if any, and then supplies <code>%ps%</code> (formerly <code>%console</code>, best renamed, and put in its own source file) as the file to open for reading the job from <code></code>(stdin). Open then gets called on <code>%ps%</code>, which can return a handle straight away, and then the core RIP calls <code>read_file</code> on the <code>%ps%</code> device. Monitor callbacks and abort callbacks may happen in the meantime. At this point <code><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a></code> can return, and read waits on a subsequent host call. An obvious further extension to the example skin here is a function pointer for progress callbacks.)</p>
<p>The configuration job in <code>pBuffer</code> should finish with either two filestreams and true on the PostScript stack, or false on the stack. If the top of the stack is true, the file objects will be used as the standard input and standard output for a PostScript job. The SDK normally uses this setup initiate a job: </p>
<pre>
   (%console%) dup (r) file exch (w) file true
 </pre><p> If the top of the stack is false, the server loop will be repeated. This allows jobs containing nothing but enquiry code or configuration data to be run. </p>

</div>
</div>
<a class="anchor" id="ga8ac29b66e38c1a2d41f50cca59a982ca"></a><!-- doxytag: member="skinkit.h::SwLeMemInit" ref="ga8ac29b66e38c1a2d41f50cca59a982ca" args="(size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeMemInit </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_maxAddressSpaceInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_workingSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_emergencySizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pMemory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pre-initializes the RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>. </p>
<p>This call is optional, the alternative being to call <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> directly. However this function must be called if RIP callbacks or modules must be registered before the RIP is fully booted by <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>. If this call is made, it must be after <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RIP_maxAddressSpaceInBytes</em>&nbsp;</td><td>Size of virtual memory available to RIP, as returned by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RIP_workingSizeInBytes</em>&nbsp;</td><td>Size of the memory buffer that the RIP will work in, as returned by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RIP_emergencySizeInBytes</em>&nbsp;</td><td>Additional memory beyond <code>RIP_workingSizeInBytes</code> to use before resorting to partial paint. Only meaningful if <code>pMemory</code> is <code>NULL</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMemory</em>&nbsp;</td><td>A pointer to an allocated buffer of size <code>RIP_workingSizeInBytes</code>, or <code>NULL</code>. If it is <code>NULL</code>, the skin allocates <code>RIP_workingSizeInBytes</code> bytes of memory itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f04bbe0cdae9a4b9c10214f90cf8001"></a><!-- doxytag: member="skinkit.h::SwLeProbe" ref="ga8f04bbe0cdae9a4b9c10214f90cf8001" args="(int id, int type, intptr_t designator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProbe </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>designator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call the skinkit trace handler, if installed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>A trace ID. This may be a core, skinkit or skin ID. It will be silently ignored if it is not a valid trace ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A trace type. This may be a core, skinkit or skin type. It will be silently ignored if it is not a valid trace type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>designator</em>&nbsp;</td><td>A data value. The interpretation of the data value is dependent on the trace id. It is usually used for correlating objects, or supplying a value for an event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51fade6543854892e0fa0e9dcde245cb"></a><!-- doxytag: member="skinkit.h::SwLeProbeLogFinish" ref="ga51fade6543854892e0fa0e9dcde245cb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProbeLogFinish </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish probe logging. </p>
<p>Finish probe logging.</p>
<p>This should come just before shutting the application down. It should be after the calls to start up and shutdown the RIP. </p>

</div>
</div>
<a class="anchor" id="gaf318a6ae0eec378f030c411eebefc9ad"></a><!-- doxytag: member="skinkit.h::SwLeProbeLogFlush" ref="gaf318a6ae0eec378f030c411eebefc9ad" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProbeLogFlush </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush probe log. </p>

</div>
</div>
<a class="anchor" id="gad0d851d49d15c8c398c8e3452647c4ac"></a><!-- doxytag: member="skinkit.h::SwLeProbeLogInit" ref="gad0d851d49d15c8c398c8e3452647c4ac" args="(const char **ppTraceNames, int nTraceNames, int *pabTraceEnabled, const char **ppTraceTypeNames, int nTraceTypeNames, const sw_tracegroup_t *pGroupDetails, int nGroupDetails, char *pszArg, char *pszLog, SwWriteProbeLogFn *pfnWriteLog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProbeLogInit </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>ppTraceNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nTraceNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pabTraceEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>ppTraceTypeNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nTraceTypeNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw__tracegroup__t.html">sw_tracegroup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pGroupDetails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nGroupDetails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pszLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga6bd2a7dc6b2e61cc2c872e26ae2b8dc3">SwWriteProbeLogFn</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnWriteLog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise probe logging. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ppTraceNames</em>&nbsp;</td><td>Override default probe names list. NULL to use default list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nTraceNames</em>&nbsp;</td><td>Items in list specified above. Ignored if list is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pabTraceEnabled</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppTraceTypeNames</em>&nbsp;</td><td>Override default probe names list. NULL to use default list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nTraceTypeNames</em>&nbsp;</td><td>Items in list specified above. Ignored if list is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pGroupDetails</em>&nbsp;</td><td>Override default group names list. NULL to use default list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nGroupDetails</em>&nbsp;</td><td>Items in list specified above. Ignored if list is NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszArg</em>&nbsp;</td><td>Command line argument for usage display only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszLog</em>&nbsp;</td><td>Filename of output log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnWriteLog</em>&nbsp;</td><td>This should come just after starting up the application. It should be before the calls to start up and shutdown the RIP.</td></tr>
  </table>
  </dd>
</dl>
<p>If ppTraceNames is NULL then skinkit's default list will be used.</p>
<p>If ppTraceTypeNames is NULL then skinkit's default list will be used. </p>

</div>
</div>
<a class="anchor" id="gaed01e9366908c8c379b615bd8519a8e7"></a><!-- doxytag: member="skinkit.h::SwLeProbeOption" ref="gaed01e9366908c8c379b615bd8519a8e7" args="(SwTraceHandlerFn *handler, const char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeProbeOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the probe handler function for the specified arg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Function pointer to probe handler function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Group name or probe name.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The group or probe name was enabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The group or probe name does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec1d8c37545ba11df97bdf6dd7652257"></a><!-- doxytag: member="skinkit.h::SwLeProcessingError" ref="gaec1d8c37545ba11df97bdf6dd7652257" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeProcessingError </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether an error occurred in the most recent chunk of job data that was processed by the RIP. </p>
<p>However the return values from <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> and <code><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a></code> are probably a more convenient means of error detection.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if an error was signalled by the RIP, otherwise <code>FALSE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf831cd6870d9bbd693e49638228f08ff"></a><!-- doxytag: member="skinkit.h::SwLeProcessingJobEnd" ref="gaf831cd6870d9bbd693e49638228f08ff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProcessingJobEnd </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates to the skin that the RIP has finished processing the job. </p>
<p>When job data is not being provided via the console device (i.e., via <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code>), this function should be called when the RIP stops asking for job data, e.g., by closing the stream providing the data. </p>

</div>
</div>
<a class="anchor" id="gaee2af83f974f79696a8cfbd62077ab36"></a><!-- doxytag: member="skinkit.h::SwLeProcessingPs" ref="gaee2af83f974f79696a8cfbd62077ab36" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeProcessingPs </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates to the skin that the RIP is now processing the job. </p>
<p>When job data is not being provided via the console device (i.e., via <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code>), this function should be called when the RIP asks for job data. </p>

</div>
</div>
<a class="anchor" id="ga258f7b9c321e1d524959dc6404cd590b"></a><!-- doxytag: member="skinkit.h::SwLeProfileOption" ref="ga258f7b9c321e1d524959dc6404cd590b" args="(SwTraceHandlerFn *handler, const char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeProfileOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the profile handler function for the specified arg. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Function pointer to profiler handler function.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Group name or probe name.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The group or probe name was enabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The group or probe name does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1f95a0fb78a44481db22364d64725ab"></a><!-- doxytag: member="skinkit.h::SwLePs" ref="gaf1f95a0fb78a44481db22364d64725ab" args="(uint32 cbBuffer, uint8 *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLePs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>cbBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Passes a chunk of PostScript language data to the Harlequin RIP. </p>
<p>This function can be called repeatedly to pass an entire PostScript job to the RIP in chunks.</p>
<p>This function will fail and return <code>FALSE</code> unless <code><a class="el" href="group__skinkit.html#ga33c0049001c3e74b46fb4f40f83eb63b" title="Prepares the Harlequin RIP to receive a PostScript language job.">SwLeJobStart()</a></code> has been called first.</p>
<p>To make the RIP read directly from a file, use the PostScript fragment shown in the Harlequin RIP Extensions Manual to set <code>stdin</code>. The following is a simple variation on that fragment:</p>
<pre>
 (&lt;filename&gt;) (r) file cvx dup
 (%stdout%) (w) file
 statusdict /setstdio get exec
 exec
 </pre><p>To run a PDF file, use a PostScript language fragment to call the Harlequin RIP extension operator <code>pdfexec</code> on an opened file.</p>
<p>In the event of an unstopped PostScript language error or other abnormal event, the function will return <code>FALSE</code>. The caller should call <code><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a></code> after detecting an error.</p>
<p>(Internally, this returns the buffer contents to the read calls on <code>%ps%</code>, perhaps in chunks if bigger than the read buffer the RIP supplies, and on completion waits for the next read call or close call before returning. Errors are detected by an unexpected call to close on <code>%ps%</code>. While waiting for these events various callbacks may also be requested of the function, such as <code>*pfnRaster</code>.)</p>
<p>When using Harlequin Parallel Pages, <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> will return when the interpreter has accepted all of the input. This return may be before all of the pages in a job have been rendered. It is possible that a page may encounter a render error after <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> returns successfully. A subsequent call to <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> or <code><a class="el" href="group__skinkit.html#ga9a0e86c002e81c05816b9f0ab6c03b05" title="Terminates the current job.">SwLeJobEnd()</a></code> will return this error. If the skin needs to wait until pages are rendered for each buffer of data it should provide its own synchronisation between the render callbacks and the <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> calls.</p>
<p>The preferred method to terminate the RIP is to call <code><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816" title="Request the RIP to stop.">SwLeStop()</a></code> between jobs. However, the RIP may also be terminated by calling this function with </p>
<pre>
   $printerdict /superstop dup put systemdict begin quit
 </pre><p> and then waiting for the RIP to finish using <code><a class="el" href="group__skinkit.html#gaa381b394f5ddf59465e09cfcd02076e7" title="Waits for the RIP thread started via SwLeStart() to exit.">SwLeWaitForRIPThreadToExit()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbBuffer</em>&nbsp;</td><td>The length, in bytes, of the PostScript buffer <code>pBuffer</code> submitted to the RIP.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>The PostScript buffer to submit to the RIP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the PostScript was processed without error, and <code>FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d1f7eb90ba7129539c31a029447bd68"></a><!-- doxytag: member="skinkit.h::SwLeSDKEnd" ref="ga8d1f7eb90ba7129539c31a029447bd68" args="(int32 exitCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSDKEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>exitCode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shutdown the SDK support libraries. </p>
<p>This call is required if <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code> succeeds. It should be called before <code><a class="el" href="group__skinkit.html#gaca48331cf0f6d8166e24bbb922f32ced" title="Performs shutdown operations when the application exits.">SwLeShutdown()</a></code>, before exiting the application. The RIP may be re-started without shutting down the SDK libraries if it can share the same memory configuration. If the memory configuration is to be changed, <code><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68" title="Shutdown the SDK support libraries.">SwLeSDKEnd()</a></code> and <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code> must be called again before restarting the RIP.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exitCode</em>&nbsp;</td><td>Indicates whether the application is shutting down in an error state. The argument should be the return value from <code><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816" title="Request the RIP to stop.">SwLeStop()</a></code>. It will be zero if the RIP shut down successfully, non-zero if the application is to indicate an error state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f0a7db8aaffd844f27976a4d7eeac24"></a><!-- doxytag: member="skinkit.h::SwLeSDKStart" ref="ga6f0a7db8aaffd844f27976a4d7eeac24" args="(size_t *RIP_maxAddressSpaceInBytes, size_t *RIP_workingSizeInBytes, void *pMemory, SysMemFns *pSysMemFns, uint8 **reasonText)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeSDKStart </td>
          <td>(</td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>RIP_maxAddressSpaceInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>RIP_workingSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSysMemFns.html">SysMemFns</a> *&nbsp;</td>
          <td class="paramname"> <em>pSysMemFns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **&nbsp;</td>
          <td class="paramname"> <em>reasonText</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise SDK support libraries for the RIP. </p>
<p>The RIP relies upon several support libraries to operate. The MPS (Memory Pool System) is used for memory management. RDR provides for decoupled discovery, overriding, and priority management of resources. Events provides an observer interface with prioritisation and filtering. Timelines provides lifespan communication, progress and contextualisation. Timers provide timed callbacks.</p>
<p>These support libraries are initialised and finalised separately from the RIP because they provide functions generally useful for the RIP skin, they allow modules to be prepared for use by the RIP, they allow configuration of libraries that the RIP uses before RIP startup. The lifetime of the support libraries may exceed one RIP instantiation.</p>
<p>The core RIP and the demonstration skin share the same memory arena. However, the skin will have its own pool within that arena. This call starts by creating the MPS memory arena and the skin's MPS memory pool. It is possible to apply a constraint to the amount of memory that the core RIP and the skin are permitted to use in combination. Use the <code>RIP_workingSizeInBytes</code> parameter to do this.</p>
<p>It is also possible for the RIP to work within a region of memory that has been pre-allocated by the host application. Use the <code>pMemory</code> argument to do this.</p>
<p>This function <em>must</em> be called after <code><a class="el" href="group__skinkit.html#ga4e0b5658bf9c11a06579cfe17be185dd" title="Initializes skinkit variables prior to starting the RIP.">SwLeInitRuntime()</a></code>, but before booting the RIP (i.e., <code><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca" title="Pre-initializes the RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeMemInit()</a></code> or <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>), and before any use of the other skin memory-management functions defined in file <a class="el" href="mem_8h.html" title="Memory-related utility functions.">mem.h</a> are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>RIP_maxAddressSpaceInBytes</em>&nbsp;</td><td>The size of maximum address space the RIP can use. This value is discovered by the memory library, it is informational.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>RIP_workingSizeInBytes</em>&nbsp;</td><td>A pointer to a value containing the size of working memory permitted for the RIP, measured in bytes. If this is zero on entry, the function will attempt to calculate a suitable default based upon the memory configuration of the host machine. If details of the memory configuration cannot be determined, a hard-coded default will be applied. On exit, the value is set to the actual size of working memory applied for the RIP.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pMemory</em>&nbsp;</td><td>Points to a caller-allocated memory block that the RIP should use. If this is non-NULL, the RIP will work within this memory block, rather than allocating its own memory. The size of the block is defined by <code>RIP_workingSizeInBytes</code>, which must not be zero. If this pointer is NULL, then the RIP will allocate and manage its own memory, suitably constrained by <code>RIP_workingSizeInBytes</code>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pSysMemFns</em>&nbsp;</td><td>Points to a structure providing the suite of system memory handling functions for use by <code>SysAlloc</code>, and <code>SysFree</code>. If this is NULL the default functions are used, which are implemented using the OS <code>malloc</code> and <code>free</code>. These allocation functions are used by the skin's example raster handlers for large allocations that should not be included in the MPS arena or constrained by <code>RIP_workingSizeInBytes</code>.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>reasonText</em>&nbsp;</td><td>An optional pointer to receive failure reasons. If non-NULL, this will be set to the reason that this function failed, or NULL if this function succeeded.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The SDK initialisation succeeded. In this case, <code>RIP_maxAddressSpaceInBytes</code> is set to size of the maximum address space the RIP can use, <code>RIP_workingSizeInBytes</code> is set to the actual size of working memory the RIP will use, and <code>reasonText</code> is set to NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The SDK initialisation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function must be called after <code><a class="el" href="group__skinkit.html#ga4e0b5658bf9c11a06579cfe17be185dd" title="Initializes skinkit variables prior to starting the RIP.">SwLeInitRuntime()</a></code>, and before <code><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca" title="Pre-initializes the RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeMemInit()</a></code> or <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>. If this function succeeds, the caller should call <code><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68" title="Shutdown the SDK support libraries.">SwLeSDKEnd()</a></code> before ending the application. The RIP may be re-started without shutting down the SDK libraries if it can share the same memory configuration. If the memory configuration is to be changed, <code><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68" title="Shutdown the SDK support libraries.">SwLeSDKEnd()</a></code> and <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code> must be called again before restarting the RIP. </dd></dl>

</div>
</div>
<a class="anchor" id="gaefd65dd3f56915ca62ea0a6a798e765d"></a><!-- doxytag: member="skinkit.h::SwLeSetRasterCallbacks" ref="gaefd65dd3f56915ca62ea0a6a798e765d" args="(SwLeRASTERSTRIDE *pfnRasterStride, SwLeRASTERREQUIREMENTS *pfnRasterRequirements, SwLeRASTERDESTINATION *pfnRasterDestination, SwLeRASTERCALLBACK *pfnRaster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetRasterCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#gaab295af926f7b69bfb091188c5206692">SwLeRASTERSTRIDE</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRasterStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga36e8277083d8600ee7926550c164e7a9">SwLeRASTERREQUIREMENTS</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRasterRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga8f41acc9f374e58cae02d5c184e3812d">SwLeRASTERDESTINATION</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRasterDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga49784289c974157865016f5987db7783">SwLeRASTERCALLBACK</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRaster</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the callback functions that the RIP will call back to present raster data to the skin. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnRasterStride</em>&nbsp;</td><td>Routine via which the RIP informs the skin of the offset between successive lines in the output, and gives it the opportunity to modify this if necessary.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnRasterRequirements</em>&nbsp;</td><td>Routine via which the RIP informs the skin of its memory requirements, and the skin can allocate the buffers it requires.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnRasterDestination</em>&nbsp;</td><td>Pointer to a function which returns a memory range into which the RIP should render a given band.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnRaster</em>&nbsp;</td><td>Called to deliver raster data to the client application. (Failure to supply a raster callback means that any RIP output will be lost. For jobs with graphical content, this is seldom desirable. However, it can be useful for purely configurational jobs, such as those used to mount devices.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd><em>pfnRasterRequirements</em> and <em>pfnRasterDestination</em> work in tandem. It makes no sense to define one and not the other: either both should be defined, or neither. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60850c161b2dded4bfbb68ee305af6d5"></a><!-- doxytag: member="skinkit.h::SwLeSetRipExitFunction" ref="ga60850c161b2dded4bfbb68ee305af6d5" args="(SwLeRIPEXITCALLBACK *pfnRipExit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetRipExitFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#gae5a51b455377de612343ce995ad66452">SwLeRIPEXITCALLBACK</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRipExit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the caller to supply callback function to be called when the RIP exits. </p>
<p>It is optional to call this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnRipExit</em>&nbsp;</td><td>Function which is to be called whenever the RIP exits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62c7802817cfecbdac9d1f751c778a54"></a><!-- doxytag: member="skinkit.h::SwLeSetRipRebootFunction" ref="ga62c7802817cfecbdac9d1f751c778a54" args="(SwLeRIPREBOOTCALLBACK *pfnRipReboot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetRipRebootFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga10bb022d5fa4155c2fc1960e7a910775">SwLeRIPREBOOTCALLBACK</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnRipReboot</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the caller to supply callback function to be called when the RIP reboots. </p>
<p>It is optional to call this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnRipReboot</em>&nbsp;</td><td>Function which is to be called whenever the RIP reboots. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ad325e19e38b2607563c50964bb9244"></a><!-- doxytag: member="skinkit.h::SwLeSetRipRendererThreads" ref="ga9ad325e19e38b2607563c50964bb9244" args="(int32 nThreads)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetRipRendererThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>nThreads</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the number of renderer threads. </p>
<p>It is optional to call this function. If called, it must be before the first call to <code><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca" title="Pre-initializes the RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeMemInit()</a></code> or <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> for a RIP instantiation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nThreads</em>&nbsp;</td><td>The number of threads usable by the RIP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a34398673384fea0f8529de48d7be6f"></a><!-- doxytag: member="skinkit.h::SwLeSetTickleTimerFunctions" ref="ga0a34398673384fea0f8529de48d7be6f" args="(SwStartTickleTimerFn *pfnSwStartTickleTimer, SwStopTickleTimerFn *pfnSwStopTickleTimer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetTickleTimerFunctions </td>
          <td>(</td>
          <td class="paramtype">SwStartTickleTimerFn *&nbsp;</td>
          <td class="paramname"> <em>pfnSwStartTickleTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SwStopTickleTimerFn *&nbsp;</td>
          <td class="paramname"> <em>pfnSwStopTickleTimer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the caller to supply timers for triggering the tickle callbacks. </p>
<p>It is optional to call this function, since the RIP skin has built-in tickle timers that function adequately on most platforms.</p>
<p>For more information about tickle timer management, see <code><a class="el" href="swoften_8h.html#a60c0efd291135260c4240b03bb2c15d2" title="Sets the given function as the timer expiry callback.">SetSkinTimerExpiredFn()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pfnSwStartTickleTimer</em>&nbsp;</td><td>Function to start the tickle timer. This will be called whenever the RIP (re-)boots.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnSwStopTickleTimer</em>&nbsp;</td><td>Function to stop the tickle timer. This will be called whenever the RIP shuts down. When the interpreter reboots due to a serious processing error, <code>pfnSwStopTickleTimer</code> will be called, followed immediately by <code>pfnSwStartTickleTimer</code>, effectively allowing the client code to "reboot" any state used to manage the timers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4ec127a624caf97820ae6a1ad24dd19"></a><!-- doxytag: member="skinkit.h::SwLeSetTraceHandler" ref="gab4ec127a624caf97820ae6a1ad24dd19" args="(SwTraceHandlerFn *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeSetTraceHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__swtrace.html#gaa36438d8c692f74a0627fccc52519ecb">SwTraceHandlerFn</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a probe callback function to capture fine-grained tracing information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Trace handler function, called by the RIP when enabled events occur.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will only have an effect on the core RIP if called before <code><a class="el" href="group__skinkit.html#ga8ac29b66e38c1a2d41f50cca59a982ca" title="Pre-initializes the RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeMemInit()</a></code> and <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code>. A pointer to the trace handler is retained by the skinkit for use by the <code><a class="el" href="group__skinkit.html#ga8f04bbe0cdae9a4b9c10214f90cf8001" title="Call the skinkit trace handler, if installed.">SwLeProbe()</a></code> function. </p>

</div>
</div>
<a class="anchor" id="gaca48331cf0f6d8166e24bbb922f32ced"></a><!-- doxytag: member="skinkit.h::SwLeShutdown" ref="gaca48331cf0f6d8166e24bbb922f32ced" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeShutdown </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs shutdown operations when the application exits. </p>
<p>This function must be called after the RIP and the SDK have been shutdown for the last time, before the application exits. </p>

</div>
</div>
<a class="anchor" id="gaddcf18e2e9e136c151e5bbbcd5071992"></a><!-- doxytag: member="skinkit.h::SwLeStart" ref="gaddcf18e2e9e136c151e5bbbcd5071992" args="(size_t RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, size_t RIP_emergencySizeInBytes, void *pMemory, SwLeMONITORCALLBACK *pfnMonitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> SwLeStart </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_maxAddressSpaceInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_workingSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_emergencySizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__skinkit.html#ga834e22669e4bbffef424b8e0a948f462">SwLeMONITORCALLBACK</a> *&nbsp;</td>
          <td class="paramname"> <em>pfnMonitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the Harlequin RIP, giving it the memory arena prepared by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>. </p>
<p>Text strings which the RIP outputs (error messages, information messages, and jobs writing to stdout and stderr) are delivered to the callback function supplied in the parameter <code>pfnMonitor</code> (when not NULL) for the duration of the RIP session.</p>
<p>In response to this call, the skin starts a thread which calls the core RIP interface function <code><a class="el" href="swstart_8h.html#ac5992df3a347df20be810f7113ff2caa" title="Start the RIP. The core RIP provides this function.">SwStart()</a></code>, passing it the memory and the device types defined in the skin. On completion (that is, the first downward call for more data, namely <code>bytesavailable</code> on the <code>%config</code> device) this function returns in its own thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RIP_maxAddressSpaceInBytes</em>&nbsp;</td><td>Size of virtual memory available to RIP, as returned by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RIP_workingSizeInBytes</em>&nbsp;</td><td>Size of the memory buffer that the RIP will work in, as returned by <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RIP_emergencySizeInBytes</em>&nbsp;</td><td>Additional memory beyond <code>RIP_workingSizeInBytes</code> to use before resorting to partial paint. Only meaningful if <code>pMemory</code> is <code>NULL</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMemory</em>&nbsp;</td><td>A pointer to an allocated buffer of size <code>RIP_workingSizeInBytes</code>, or NULL. If it is NULL, the skin allocates <code>RIP_workingSizeInBytes</code> bytes of memory itself.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pfnMonitor</em>&nbsp;</td><td>A pointer to a monitor callback function which the skin must implement if it wishes to receive monitor information from the RIP. This argument can be NULL, in which case no monitor information will be sent to the skin.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>The RIP started successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>The RIP did not start successfully. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d848af165c6fa12b1562f5a05af7816"></a><!-- doxytag: member="skinkit.h::SwLeStop" ref="ga3d848af165c6fa12b1562f5a05af7816" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> SwLeStop </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request that the RIP shutdown. </p>
<p>This function should only be called in between job boundaries. It submits a shutdown PS job to the RIP, then waits for the RIP to exit.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The exit status of the RIP. This will be zero if the RIP shutdown cleanly, non-zero otherwise. The value returned should be passed to <code><a class="el" href="group__skinkit.html#ga8d1f7eb90ba7129539c31a029447bd68" title="Shutdown the SDK support libraries.">SwLeSDKEnd()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd9b960c1dabca86da6695cbf5691c7b"></a><!-- doxytag: member="skinkit.h::SwLeTraceEnable" ref="gabd9b960c1dabca86da6695cbf5691c7b" args="(int32 trace, int32 enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeTraceEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable a probe to capture fine-grained tracing information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trace</em>&nbsp;</td><td>The trace name identifier. Individual traces should come from the SW_TRACE_* identifiers defined in <a class="el" href="swtrace_8h.html" title="This header file provides access to the lightweight tracing API.">swtrace.h</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>If true, enable the probe(s). If false, disable them.</td></tr>
  </table>
  </dd>
</dl>
<p>The trace handler function must have been set using <a class="el" href="group__skinkit.html#gab4ec127a624caf97820ae6a1ad24dd19" title="Set a probe callback function to capture fine-grained tracing information.">SwLeSetTraceHandler()</a> before calling this function. This function is a trampoline to call the trace handler, which manages its own enable/disable state. </p>

</div>
</div>
<a class="anchor" id="gaa381b394f5ddf59465e09cfcd02076e7"></a><!-- doxytag: member="skinkit.h::SwLeWaitForRIPThreadToExit" ref="gaa381b394f5ddf59465e09cfcd02076e7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SwLeWaitForRIPThreadToExit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for the RIP thread started via <code><a class="el" href="group__skinkit.html#gaddcf18e2e9e136c151e5bbbcd5071992" title="Starts the Harlequin RIP, giving it the memory arena prepared by SwLeSDKStart().">SwLeStart()</a></code> to exit. </p>
<p>This function waits for the RIP to quit cleanly.</p>
<p>The preferred method to terminate the RIP is to call <code><a class="el" href="group__skinkit.html#ga3d848af165c6fa12b1562f5a05af7816" title="Request the RIP to stop.">SwLeStop()</a></code> between jobs. However, the RIP may also be terminated by starting a job, and calling <code><a class="el" href="group__skinkit.html#gaf1f95a0fb78a44481db22364d64725ab" title="Passes a chunk of PostScript language data to the Harlequin RIP.">SwLePs()</a></code> with </p>
<pre>
 $printerdict /superstop dup put systemdict begin quit
 </pre><p> and then waiting for the RIP to finish using this function. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
