<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: Events system</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Events system<br/>
<small>
[<a class="el" href="group__interface.html">Harlequin RIP core interface.</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__event.html">sw_event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event structure.  <a href="structsw__event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__event__handler.html">sw_event_handler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event Handler structure.  <a href="structsw__event__handler.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__event__handlers.html">sw_event_handlers</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomic multiple Handler registration.  <a href="structsw__event__handlers.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafbcdb59a3f2434216f6ece275c6ec9c2"></a><!-- doxytag: member="swevents::SW_EVENT_HANDLER_INIT" ref="gafbcdb59a3f2434216f6ece275c6ec9c2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gafbcdb59a3f2434216f6ece275c6ec9c2">SW_EVENT_HANDLER_INIT</a>&nbsp;&nbsp;&nbsp;{ NULL, NULL, 0 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static/auto initialiser for <a class="el" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59f5c7ba468cacc130d10464e8bb7193"></a><!-- doxytag: member="swevents::SW_EVENT_HANDLERS_INIT" ref="ga59f5c7ba468cacc130d10464e8bb7193" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#ga59f5c7ba468cacc130d10464e8bb7193">SW_EVENT_HANDLERS_INIT</a>&nbsp;&nbsp;&nbsp;{ NULL, NULL, 0, EVENT_EVENT, SW_EVENT_NORMAL }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static/auto initialiser for <a class="el" href="structsw__event__handlers.html" title="Atomic multiple Handler registration.">sw_event_handlers</a>. <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__swevents.html#gab7e53d739c2de7b6efbdb69b90a2d8e9">sw_event_context</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gab7e53d739c2de7b6efbdb69b90a2d8e9">sw_event_context</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque event context for internal use only.  <a href="#gab7e53d739c2de7b6efbdb69b90a2d8e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef sw_event_result(HQNCALL *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#ga88a76c5558dec2450458b924a5c294c5">event_handler</a> )(void *context, <a class="el" href="structsw__event.html">sw_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Event Handler prototype.  <a href="#ga88a76c5558dec2450458b924a5c294c5"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Event types. </p>
 <a href="group__swevents.html#gaf715e26dfffd1f8de1c18449e2770cff">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Event Handler Priorities. </p>
 <a href="group__swevents.html#gafb730582952b7ceec73d7dc9bf7bef39">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__swevents.html#ggafccd240f973cf154952fb917c9209719ada52f1e4d5bb9c0db3e0d62f6d83acd9">SW_EVENT_CONTINUE</a> =  -2, 
<a class="el" href="group__swevents.html#ggafccd240f973cf154952fb917c9209719a8d76b1fb87da82018af5e702494c5f25">SW_EVENT_FORCE_UNHANDLED</a> =  -1, 
<a class="el" href="group__swevents.html#ggafccd240f973cf154952fb917c9209719a7ec22da8310245db78d7961d5492412c">SW_EVENT_HANDLED</a> =  0, 
<a class="el" href="group__swevents.html#ggafccd240f973cf154952fb917c9209719a5ec1061f03eab93da4e388503fba41c3">SW_EVENT_ERROR</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Result values from Event Handlers. </p>
 <a href="group__swevents.html#gafccd240f973cf154952fb917c9209719">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#ga32b45b007d447cc455734d9dc8650bef">SwRegisterHandler</a> (sw_event_type type, <a class="el" href="structsw__event__handler.html">sw_event_handler</a> *handler, sw_event_priority priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an Event Handler.  <a href="#ga32b45b007d447cc455734d9dc8650bef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gab7c0cfc3d880805438628953a3740f0e">SwRegisterHandlers</a> (<a class="el" href="structsw__event__handlers.html">sw_event_handlers</a> *handlers, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register multiple Event Handlers atomically.  <a href="#gab7c0cfc3d880805438628953a3740f0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gaacda6ced123b30242a7b1136d7e963d3">SwDeregisterHandler</a> (sw_event_type type, <a class="el" href="structsw__event__handler.html">sw_event_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister an Event Handler registered with SwRegisterHandler.  <a href="#gaacda6ced123b30242a7b1136d7e963d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gac92f58cf7e6cc6d36577a602be178298">SwDeregisterHandlers</a> (<a class="el" href="structsw__event__handlers.html">sw_event_handlers</a> *handlers, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister multiple Event Handlers.  <a href="#gac92f58cf7e6cc6d36577a602be178298"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gac6e12cb49b39f3a5d5d82b6f58fd003c">SwSafeDeregisterHandler</a> (sw_event_type type, <a class="el" href="structsw__event__handler.html">sw_event_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister an Event Handler detecting Handler threading.  <a href="#gac6e12cb49b39f3a5d5d82b6f58fd003c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_event_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#gaf17bfedae61889641ba6fe12ac3f5e0e">SwEvent</a> (sw_event_type type, void *message, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate an event, calling relevant handlers in priority order.  <a href="#gaf17bfedae61889641ba6fe12ac3f5e0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_event_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swevents.html#ga1601b34b45c68a318babc0ecc3978080">SwEventTail</a> (<a class="el" href="structsw__event.html">sw_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call the remaining Handlers for the current Event, returning the value that would have been returned to the Issuer.  <a href="#ga1601b34b45c68a318babc0ecc3978080"></a><br/></td></tr>
</table>


<h3><a class="anchor" id="eventapi">The Event System</a></h3><p>This enables Events or Messages to be sent and received by multiple recipients.</p>
<p>Handlers are defined like this:</p>
<div class="fragment"><pre class="fragment">    sw_event_result my_callback(<span class="keywordtype">void</span> * context, <a class="code" href="structsw__event.html" title="Event structure.">sw_event</a> * event) ;

    <a class="code" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a> handler = {my_callback, my_context} ;
    <a class="code" href="group__swevents.html#ga32b45b007d447cc455734d9dc8650bef" title="Register an Event Handler.">SwRegisterHandler</a>(EVENT_&lt;type&gt;, handler, <a class="code" href="group__swrdr.html#ggaedcf2109f459315e1a7f2af73ec9b603ac5c10ba7ffe2850af28b352b9fd54b4b">SW_RDR_NORMAL</a>) ;
</pre></div><p>Events are issued like this:</p>
<div class="fragment"><pre class="fragment">    my_event_message message = {&lt;fill stuff in here&gt;} ;
    result = <a class="code" href="group__swevents.html#gaf17bfedae61889641ba6fe12ac3f5e0e" title="Generate an event, calling relevant handlers in priority order.">SwEvent</a>(EVENT_&lt;type&gt;, message, <span class="keyword">sizeof</span>(message)) ;
</pre></div><p>Or for purely informational signals:</p>
<div class="fragment"><pre class="fragment">    result = <a class="code" href="group__swevents.html#gaf17bfedae61889641ba6fe12ac3f5e0e" title="Generate an event, calling relevant handlers in priority order.">SwEvent</a>(EVENT_&lt;type&gt;, 0, 0) ;
</pre></div> <hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga88a76c5558dec2450458b924a5c294c5"></a><!-- doxytag: member="eventapi.h::event_handler" ref="ga88a76c5558dec2450458b924a5c294c5" args=")(void *context, sw_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef sw_event_result(HQNCALL * <a class="el" href="group__swevents.html#ga88a76c5558dec2450458b924a5c294c5">event_handler</a>)(void *context, <a class="el" href="structsw__event.html">sw_event</a> *event)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Event Handler prototype. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The Handler's context pointer as specified in the registered <a class="el" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a>. This can be whatever the Handler requires. Note that this is a void* and must be cast to whatever type the Handler expects.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>The Event details in <a class="el" href="structsw__event.html" title="Event structure.">sw_event</a> format. Note that the Issuer-supplied event-&gt;message is a void* and must be cast to whatever type the Event in question is defined to comprise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_EVENT_CONTINUE to pass on to other Handlers. This does not necessarily mean that this Handler has done nothing. Whether to 'normally' return SW_EVENT_CONTINUE or SW_EVENT_HANDLED is defined on a per-Event basis.</dd></dl>
<p>SW_EVENT_HANDLED to return immediately to the Issuer. No further Handlers are called.</p>
<p>&gt;= SW_EVENT_ERROR to return immediately to the Issuer. No further Handlers are called. Error codes may be defined on a per-Event basis.</p>
<p>SW_EVENT_FORCE_UNHANDLED to return immediately to the Issuer. No further Handlers are called, but the value returned to the Issuer is SW_EVENT_CONTINUE (also known as SW_EVENT_UNHANDLED).</p>
<p>If all Handlers return SW_EVENT_CONTINUE, this is the value returned to the Issuer. For code clarity SW_EVENT_UNHANDLED is an alias for this value, which can make Issuer code clearer. Also see SW_EVENT_FORCE_UNHANDLED. </p>

</div>
</div>
<a class="anchor" id="gab7e53d739c2de7b6efbdb69b90a2d8e9"></a><!-- doxytag: member="eventapi.h::sw_event_context" ref="gab7e53d739c2de7b6efbdb69b90a2d8e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__swevents.html#gab7e53d739c2de7b6efbdb69b90a2d8e9">sw_event_context</a> <a class="el" href="group__swevents.html#gab7e53d739c2de7b6efbdb69b90a2d8e9">sw_event_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opaque event context for internal use only. </p>
<p>This is only seen inside the <a class="el" href="structsw__event.html" title="Event structure.">sw_event</a> structure passed to Handlers, and may not be usefully inspected or modified. However, it is necessary for the correct functioning of <a class="el" href="group__swevents.html#ga1601b34b45c68a318babc0ecc3978080" title="Call the remaining Handlers for the current Event, returning the value that would...">SwEventTail()</a>. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaf715e26dfffd1f8de1c18449e2770cff"></a><!-- doxytag: member="eventapi.h::@49" ref="gaf715e26dfffd1f8de1c18449e2770cff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event types. </p>
<p>Event numbering follows the numbering conventions for DEVICETYPE numbers.</p>
<p>The range 0x00000000-0x0000ffff is reserved for Global Graphics. The range 0xXXXX0000-0xXXXXffff is reserved for customer number XXXX. The range 0xffff0000-0xffffffff is for private use in closed environments.</p>
<p>These ranges are sub-allocated here and elsewhere, eg <a class="el" href="swevents_8h.html" title="Defines the core&#39;s external event API.">swevents.h</a>. </p>

</div>
</div>
<a class="anchor" id="gafb730582952b7ceec73d7dc9bf7bef39"></a><!-- doxytag: member="eventapi.h::@50" ref="gafb730582952b7ceec73d7dc9bf7bef39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event Handler Priorities. </p>
<p>The highest priority (or most recently registered) Handler for an Event is called first. If it returns SW_EVENT_CONTINUE the next highest will be called, and so on.</p>
<p>These are typical values, but other than the high to low ordering, Handlers can choose whatever priority is appropriate. Handlers can be reprioritised dynamically, even while being executed. </p>

</div>
</div>
<a class="anchor" id="gafccd240f973cf154952fb917c9209719"></a><!-- doxytag: member="eventapi.h::@51" ref="gafccd240f973cf154952fb917c9209719" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Result values from Event Handlers. </p>
<p>Handlers for an Event are called in decreasing Priority order until one does NOT return SW_EVENT_CONTINUE. The last return code is returned to the Event Issuer. SW_EVENT_UNHANDLED is an alias for SW_EVENT_CONTINUE which may be clearer in some protocols.</p>
<p>Other than the special behaviour of SW_EVENT_FORCE_UNHANDLED and SW_EVENT_CONTINUE, all other values are returned to the Issuer, so their meaning is defined on a per-Event basis. It may be that some Event uses return values &gt;= SW_EVENT_ERROR to indicate various successful outcomes.</p>
<p>These are chosen such that SW_EVENT_HANDLED == SW_RDR_SUCCESS and SW_EVENT_ERROR == SW_RDR_ERROR for simplicity of implementation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggafccd240f973cf154952fb917c9209719ada52f1e4d5bb9c0db3e0d62f6d83acd9"></a><!-- doxytag: member="SW_EVENT_CONTINUE" ref="ggafccd240f973cf154952fb917c9209719ada52f1e4d5bb9c0db3e0d62f6d83acd9" args="" -->SW_EVENT_CONTINUE</em>&nbsp;</td><td>
<p>Pass Event on to next Handler </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafccd240f973cf154952fb917c9209719a8d76b1fb87da82018af5e702494c5f25"></a><!-- doxytag: member="SW_EVENT_FORCE_UNHANDLED" ref="ggafccd240f973cf154952fb917c9209719a8d76b1fb87da82018af5e702494c5f25" args="" -->SW_EVENT_FORCE_UNHANDLED</em>&nbsp;</td><td>
<p>Immediately return SW_EVENT_UNHANDLED to Issuer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafccd240f973cf154952fb917c9209719a7ec22da8310245db78d7961d5492412c"></a><!-- doxytag: member="SW_EVENT_HANDLED" ref="ggafccd240f973cf154952fb917c9209719a7ec22da8310245db78d7961d5492412c" args="" -->SW_EVENT_HANDLED</em>&nbsp;</td><td>
<p>Return immediately to Issuer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafccd240f973cf154952fb917c9209719a5ec1061f03eab93da4e388503fba41c3"></a><!-- doxytag: member="SW_EVENT_ERROR" ref="ggafccd240f973cf154952fb917c9209719a5ec1061f03eab93da4e388503fba41c3" args="" -->SW_EVENT_ERROR</em>&nbsp;</td><td>
<p>Error, don't pass to any more Handlers. Specific errors are enumerated from here for individual Events, all &gt;= SW_EVENT_ERROR </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaacda6ced123b30242a7b1136d7e963d3"></a><!-- doxytag: member="eventapi.h::SwDeregisterHandler" ref="gaacda6ced123b30242a7b1136d7e963d3" args="(sw_event_type type, sw_event_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL SwDeregisterHandler </td>
          <td>(</td>
          <td class="paramtype">sw_event_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsw__event__handler.html">sw_event_handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deregister an Event Handler registered with SwRegisterHandler. </p>
<p>Deregisters a previously registered Handler. This can be called by the Handler itself.</p>
<p>Although this guarantees that the Handler will not be called again, it does NOT guarantee that the Handler is not currently threaded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The Event type, of the form EVENT_&lt;type&gt;.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The <a class="el" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a> structure previously registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, if successfully deregistered. SW_RDR_ERROR_IN_USE, if the Handler was theaded. SW_RDR_ERROR_UNKNOWN, if the Handler was not registered.</dd></dl>
<p>Note that even if SW_RDR_ERROR_IN_USE is returned, the Handler HAS been successfully deregistered, though it may still be threaded. If so, this call can be repeated until it no longer returns SW_RDR_ERROR_IN_USE, or <a class="el" href="group__swevents.html#gac6e12cb49b39f3a5d5d82b6f58fd003c" title="Deregister an Event Handler detecting Handler threading.">SwSafeDeregisterHandler()</a> called instead to wait for the Handler to exit. </p>

</div>
</div>
<a class="anchor" id="gac92f58cf7e6cc6d36577a602be178298"></a><!-- doxytag: member="eventapi.h::SwDeregisterHandlers" ref="gac92f58cf7e6cc6d36577a602be178298" args="(sw_event_handlers *handlers, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL SwDeregisterHandlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__event__handlers.html">sw_event_handlers</a> *&nbsp;</td>
          <td class="paramname"> <em>handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deregister multiple Event Handlers. </p>
<p>This deregisters a number of Handlers in one call, regardless of errors, and guarantess that they are not threaded on exit.</p>
<p>This is more concise than multiple calls to <a class="el" href="group__swevents.html#gac6e12cb49b39f3a5d5d82b6f58fd003c" title="Deregister an Event Handler detecting Handler threading.">SwSafeDeregisterHandler()</a>, but is entirely equivalent. If any Handler is not registered an error is returned after all other Handlers have been deregistered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handlers</em>&nbsp;</td><td>An array of <a class="el" href="structsw__event__handlers.html" title="Atomic multiple Handler registration.">sw_event_handlers</a> as previously passed to <a class="el" href="group__swevents.html#gab7c0cfc3d880805438628953a3740f0e" title="Register multiple Event Handlers atomically.">SwRegisterHandlers()</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The number of entries in this array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, if all successfully deregistered.</dd></dl>
<p>SW_RDR_ERROR_UNKNOWN if any were not registered. Note that ALL Handlers will have been deregistered, this error is purely informational.</p>
<p>Note that this call cannot be used by a Handler to deregister itself. Be careful not to use this call in any code that can be called from a Handler that is to be deregistered. </p>

</div>
</div>
<a class="anchor" id="gaf17bfedae61889641ba6fe12ac3f5e0e"></a><!-- doxytag: member="eventapi.h::SwEvent" ref="gaf17bfedae61889641ba6fe12ac3f5e0e" args="(sw_event_type type, void *message, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_event_result HQNCALL SwEvent </td>
          <td>(</td>
          <td class="paramtype">sw_event_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate an event, calling relevant handlers in priority order. </p>
<p>The meaning, parameters and return values pertinent to a particular Event are defined by the Event owner. Some Events may merely be used as a signal to inform interested parties of a change in state. Some may contain data or a reference to a buffer. Others may require specific return codes for successful completion. This is all up to the Event owner.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The event type of the form EVENT_&lt;type&gt;.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>The message pointer for this event. Note that much like the RDR system which underpins the Event system, no interpretation of this pointer is mandated - it may be a pointer to some information, or to a buffer to fill in, or some other arbitrary address such as a memory limit. It may often be NULL.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length associated with the above message pointer. Once again, no interpretation is placed on the meaning of this value - it may refer to the length of the message or may be an arbitrary number. This is defined by the issuer of the Event in question. It may often be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If there are no handlers, or none respond, the return value will be SW_EVENT_CONTINUE. SW_EVENT_UNHANDLED is an alias of this value that may make code clearer.</dd></dl>
<p>If a handler has acted appropriately, it will return SW_EVENT_HANDLED. Note that either of these cases may be seen as a success or failure by the Event Issuer - this is defined on a per-Event basis.</p>
<p>If a handler reports an error, the return value will be &gt;= SW_EVENT_ERROR. Error return values in that range can be defined on a per-Event basis, and may not actually indicate a fault for that Event definition! </p>

</div>
</div>
<a class="anchor" id="ga1601b34b45c68a318babc0ecc3978080"></a><!-- doxytag: member="eventapi.h::SwEventTail" ref="ga1601b34b45c68a318babc0ecc3978080" args="(sw_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_event_result HQNCALL SwEventTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__event.html">sw_event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call the remaining Handlers for the current Event, returning the value that would have been returned to the Issuer. </p>
<p>This call can only be made by a Handler, passing in the <a class="el" href="structsw__event.html" title="Event structure.">sw_event</a> delivered to it. The remaining Handlers - the "tail" - can be called multiple times if the current Handler wishes. How the return values are combined or what value is ultimately returned is up to the current Handler.</p>
<p>Note that calling <a class="el" href="group__swevents.html#ga1601b34b45c68a318babc0ecc3978080" title="Call the remaining Handlers for the current Event, returning the value that would...">SwEventTail()</a> does not automatically prevent the remaining Handlers from being called once more if the current Handler returns SW_EVENT_CONTINUE - see SW_EVENT_FORCE_UNHANDLED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>The <a class="el" href="structsw__event.html" title="Event structure.">sw_event</a> structure passed to the Handler.</td></tr>
  </table>
  </dd>
</dl>
<p>It is permissible for the Handler to change the message and length fields of the <a class="el" href="structsw__event.html" title="Event structure.">sw_event</a>, but the opaque context field must be preserved for <a class="el" href="group__swevents.html#ga1601b34b45c68a318babc0ecc3978080" title="Call the remaining Handlers for the current Event, returning the value that would...">SwEventTail()</a> to function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>As <a class="el" href="group__swevents.html#gaf17bfedae61889641ba6fe12ac3f5e0e" title="Generate an event, calling relevant handlers in priority order.">SwEvent()</a>, SW_EVENT_CONTINUE (SW_EVENT_UNHANDLED), SW_EVENT_HANDLED, or an error code &gt;= SW_EVENT_ERROR may be returned by the remaining Handlers, if any.</dd></dl>
<p>The current Handler may choose to return some other value if it wishes. </p>

</div>
</div>
<a class="anchor" id="ga32b45b007d447cc455734d9dc8650bef"></a><!-- doxytag: member="eventapi.h::SwRegisterHandler" ref="ga32b45b007d447cc455734d9dc8650bef" args="(sw_event_type type, sw_event_handler *handler, sw_event_priority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL SwRegisterHandler </td>
          <td>(</td>
          <td class="paramtype">sw_event_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsw__event__handler.html">sw_event_handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw_event_priority&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an Event Handler. </p>
<p>This registers a Handler with the Event system, or reregisters a previously registered handler with a different priority. This can be done by the Handler itself while being executed, if it wishes.</p>
<p>Note that SwRegisterHandler is just syntactic sugar for an RDR registration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The Event type, of the form EVENT_&lt;type&gt;</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>A <a class="el" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a> structure containing a pointer to the Event Handler function, and optionally its private context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>A priority, as for RDR registrations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, if successfully registered.</dd></dl>
<p>SW_RDR_ERROR in the unlikely event of too many Handlers being registered. </p>

</div>
</div>
<a class="anchor" id="gab7c0cfc3d880805438628953a3740f0e"></a><!-- doxytag: member="eventapi.h::SwRegisterHandlers" ref="gab7c0cfc3d880805438628953a3740f0e" args="(sw_event_handlers *handlers, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL SwRegisterHandlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__event__handlers.html">sw_event_handlers</a> *&nbsp;</td>
          <td class="paramname"> <em>handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register multiple Event Handlers atomically. </p>
<p>This registers a number of Handlers in one call, and does so atomically - if any fail to register, any that have will be deregistered.</p>
<p>This is more concise than multiple calls to <a class="el" href="group__swevents.html#ga32b45b007d447cc455734d9dc8650bef" title="Register an Event Handler.">SwRegisterHandler()</a>, but is entirely equivalent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handlers</em>&nbsp;</td><td>An array of <a class="el" href="structsw__event__handlers.html" title="Atomic multiple Handler registration.">sw_event_handlers</a> containing a pointer to the Event Handler function, its private context, the Event type and the priority.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The number of entries in the above array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, if successfully registered.</dd></dl>
<p>SW_RDR_ERROR in the unlikely event of too many Handlers being registered.</p>
<p>Should this call return an error it is guaranteed that no Handlers are registered or threaded. However, it cannot guarantee that none were called. </p>

</div>
</div>
<a class="anchor" id="gac6e12cb49b39f3a5d5d82b6f58fd003c"></a><!-- doxytag: member="eventapi.h::SwSafeDeregisterHandler" ref="gac6e12cb49b39f3a5d5d82b6f58fd003c" args="(sw_event_type type, sw_event_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL SwSafeDeregisterHandler </td>
          <td>(</td>
          <td class="paramtype">sw_event_type&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsw__event__handler.html">sw_event_handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deregister an Event Handler detecting Handler threading. </p>
<p>This deregisters a Handler immediately like <a class="el" href="group__swevents.html#gaacda6ced123b30242a7b1136d7e963d3" title="Deregister an Event Handler registered with SwRegisterHandler.">SwDeregisterHandler()</a> but also detects whether the Handler is currently threaded. If so it does not return until the Handler exits.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The Event type, of the form EVENT_&lt;type&gt;.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The <a class="el" href="structsw__event__handler.html" title="Event Handler structure.">sw_event_handler</a> structure previously registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, if successfully deregistered. SW_RDR_ERROR_UNKNOWN, if the Handler is not registered.</dd></dl>
<p>Note that this call cannot be used by a Handler to deregister itself. Be careful not to use this call in any code that can be called from the Handler that is to be deregistered. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
