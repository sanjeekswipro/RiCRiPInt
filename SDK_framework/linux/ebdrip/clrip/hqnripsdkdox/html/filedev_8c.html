<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: filedev.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>filedev.c File Reference</h1>
<p>Implementation of the file system device type.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="std_8h.html">std.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="devutils_8h.html">devutils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqstr_8h.html">hqstr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="file_8h.html">file.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="paths_8h.html">paths.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync_8h.html">sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="skindevs_8h.html">skindevs.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="swdevice_8h.html">swdevice.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="swoften_8h.html">swoften.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFileState.html">FileState</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold file-specific state.  <a href="structFileState.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFileDeviceState.html">FileDeviceState</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold device-specific state.  <a href="structFileDeviceState.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf37663ceefbab225ec71ca7683b5082"></a><!-- doxytag: member="filedev.c::fs_device_init" ref="abf37663ceefbab225ec71ca7683b5082" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#abf37663ceefbab225ec71ca7683b5082">fs_device_init</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File system device initialisation. See PR5.8.7. This is called for each device (note: not device type) when its type number is assigned by a call to setdevparams. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a5e0e4888706157214947ab79e8016"></a><!-- doxytag: member="filedev.c::fs_ioerror" ref="aa0a5e0e4888706157214947ab79e8016" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#aa0a5e0e4888706157214947ab79e8016">fs_ioerror</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The following routines are simple stub routines for cases where the only functionality required is to set the appropriate error condition. Take care which is used in which circumstances. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49472cbc224ba5b2519ddeff51e25322"></a><!-- doxytag: member="filedev.c::fs_open_file" ref="a49472cbc224ba5b2519ddeff51e25322" args="(DEVICELIST *dev, uint8 *filename, int32 openflags)" -->
static DEVICE_FILEDESCRIPTOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a49472cbc224ba5b2519ddeff51e25322">fs_open_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> openflags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The file_open call for the file system device type. See PR 5.8.8. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a7ef52dbcf84fa7b039132a395800321b">fs_read_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read_file routine for the file system device type. See PR 5.8.9.  <a href="#a7ef52dbcf84fa7b039132a395800321b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a4308ebd3e7e06a4293f7746b78dd83cd">fs_write_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *buff, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The write_file routine for the file system device type. See PR 5.8.10.  <a href="#a4308ebd3e7e06a4293f7746b78dd83cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a1c069b95ecc965807a16785e52ced5cb">fs_close_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The close_file routine for the file system device type. See PR 5.8.11 and PR 5.8.12.  <a href="#a1c069b95ecc965807a16785e52ced5cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f2f43e05f917ff05142dacc7505cc17"></a><!-- doxytag: member="filedev.c::fs_seek_file" ref="a3f2f43e05f917ff05142dacc7505cc17" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *destination, int32 flags)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a3f2f43e05f917ff05142dacc7505cc17">fs_seek_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *destination, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The seek_file routine for the file system device type. See PR 5.8.13. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a99c120a20e0208e5ab29b6d7452c212a">fs_bytes_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="structHq32x2.html">Hq32x2</a> *bytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bytes_file routine for the file system device type. See 5.8.14.  <a href="#a99c120a20e0208e5ab29b6d7452c212a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e5c6e6a3c84bfe12288091cffea9a6"></a><!-- doxytag: member="filedev.c::fs_status_file" ref="aa9e5c6e6a3c84bfe12288091cffea9a6" args="(DEVICELIST *dev, uint8 *filename, STAT *statbuff)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#aa9e5c6e6a3c84bfe12288091cffea9a6">fs_status_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename, <a class="el" href="structSTAT.html">STAT</a> *statbuff)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status_file routine for the file system device type. See 5.8.15. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ea69852815c9d2f9f250b2e66f4eac"></a><!-- doxytag: member="filedev.c::fs_start_file_list" ref="a80ea69852815c9d2f9f250b2e66f4eac" args="(DEVICELIST *dev, uint8 *pattern)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a80ea69852815c9d2f9f250b2e66f4eac">fs_start_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">* fs_start_file_list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80c09c0c0576254bc38691f5010db959"></a><!-- doxytag: member="filedev.c::fs_next_file" ref="a80c09c0c0576254bc38691f5010db959" args="(DEVICELIST *dev, void **handle, uint8 *pattern, FILEENTRY *entry)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a80c09c0c0576254bc38691f5010db959">fs_next_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void **handle, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pattern, <a class="el" href="structFILEENTRY.html">FILEENTRY</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fs_next_file <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e7d0e9b7f6603d2097a0a46d98c228"></a><!-- doxytag: member="filedev.c::fs_end_file_list" ref="ab8e7d0e9b7f6603d2097a0a46d98c228" args="(DEVICELIST *dev, void *handle)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ab8e7d0e9b7f6603d2097a0a46d98c228">fs_end_file_list</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, void *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fs_end_file_list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ad742b09514fbbed4e529d538dac0cc0e">fs_rename_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file1, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *file2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rename_file routine for the file system device type. See PR 5.8.19.  <a href="#ad742b09514fbbed4e529d538dac0cc0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac801d182c6a26c9715b9abb36c214018"></a><!-- doxytag: member="filedev.c::fs_delete_file" ref="ac801d182c6a26c9715b9abb36c214018" args="(DEVICELIST *dev, uint8 *filename)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ac801d182c6a26c9715b9abb36c214018">fs_delete_file</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The delete_file routine for the file system device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#abb56f68bca2d1b7db69718b49140ec7f">fs_set_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set_param routine for the file system device type. See PR 5.8.21.  <a href="#abb56f68bca2d1b7db69718b49140ec7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#aacfa7b617930d38ed9d606153a38c742">fs_get_param</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, <a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The get_param routine for the file system device type. See PR 5.8.23.  <a href="#aacfa7b617930d38ed9d606153a38c742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a077754c77d7b911d14cfd25d6214144b">fs_status_device</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVSTAT *devstat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status_device routine for the file system device type.  <a href="#a077754c77d7b911d14cfd25d6214144b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91756bb170ac122c69d501d87da058a9"></a><!-- doxytag: member="filedev.c::fs_device_dismount" ref="a91756bb170ac122c69d501d87da058a9" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a91756bb170ac122c69d501d87da058a9">fs_device_dismount</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The status_dismount routine for the file system device type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#aec947081b5533691536bc798b9b37bbf">fs_ioctl</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev, DEVICE_FILEDESCRIPTOR descriptor, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> opcode, intptr_t arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ioctl routine for the file system device type.  <a href="#aec947081b5533691536bc798b9b37bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e8a2f88ccd361b337ff26ca926edcc4"></a><!-- doxytag: member="filedev.c::KInitFilenameForAll" ref="a5e8a2f88ccd361b337ff26ca926edcc4" args="(FilenameForAll *ls, uint8 *pszDirName, int32 *pfIOError)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a5e8a2f88ccd361b337ff26ca926edcc4">KInitFilenameForAll</a> (FilenameForAll *ls, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszDirName, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *pfIOError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">KInitFilenameForAll. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04c087b88f2519494e8d1f82885af0b8"></a><!-- doxytag: member="filedev.c::KAbandonFilenameForAll" ref="a04c087b88f2519494e8d1f82885af0b8" args="(FilenameForAll *ls)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a04c087b88f2519494e8d1f82885af0b8">KAbandonFilenameForAll</a> (FilenameForAll *ls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">KAbandonFilenameForAll. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2c017ef5580e442f0bc58fa6065dd7"></a><!-- doxytag: member="filedev.c::createFileState" ref="aaa2c017ef5580e442f0bc58fa6065dd7" args="()" -->
static <a class="el" href="structFileState.html">FileState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#aaa2c017ef5580e442f0bc58fa6065dd7">createFileState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a <a class="el" href="structFileState.html" title="Structure to hold file-specific state.">FileState</a> object. Should be released with <a class="el" href="filedev_8c.html#ab20b59a50cbdd80b7f6da066e343929d" title="Release a FileState object.">releaseFileState()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab20b59a50cbdd80b7f6da066e343929d"></a><!-- doxytag: member="filedev.c::releaseFileState" ref="ab20b59a50cbdd80b7f6da066e343929d" args="(FileState *pState)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ab20b59a50cbdd80b7f6da066e343929d">releaseFileState</a> (<a class="el" href="structFileState.html">FileState</a> *pState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a <a class="el" href="structFileState.html" title="Structure to hold file-specific state.">FileState</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1105f32dacbad636a665e638a0264971"></a><!-- doxytag: member="filedev.c::initialiseDeviceState" ref="a1105f32dacbad636a665e638a0264971" args="(DEVICELIST *dev)" -->
static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a1105f32dacbad636a665e638a0264971">initialiseDeviceState</a> (<a class="el" href="structdevicelist.html">DEVICELIST</a> *dev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a <a class="el" href="structFileDeviceState.html" title="Structure to hold device-specific state.">FileDeviceState</a> object. pDeviceState should point to preallocated memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19a1a1b19cb809c61b335bb71f22140e"></a><!-- doxytag: member="filedev.c::uninitialiseDeviceState" ref="a19a1a1b19cb809c61b335bb71f22140e" args="(FileDeviceState *pDeviceState)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a19a1a1b19cb809c61b335bb71f22140e">uninitialiseDeviceState</a> (<a class="el" href="structFileDeviceState.html">FileDeviceState</a> *pDeviceState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninitialise a <a class="el" href="structFileDeviceState.html" title="Structure to hold device-specific state.">FileDeviceState</a> object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ae23f216f3ebedbae08f16cef9afb6f5f">KSetSWDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pSWDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record an explicit path to the SW folder, overriding any default search rules.  <a href="#ae23f216f3ebedbae08f16cef9afb6f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a9a4c2134484bd40d72f62f7fc12b8704">KGetSWDir</a> (<a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pSWDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an explicit path to the SW folder, taking into account any path set using <a class="el" href="filedev_8c.html#ae23f216f3ebedbae08f16cef9afb6f5f" title="Record an explicit path to the SW folder, overriding any default search rules.">KSetSWDir()</a>.  <a href="#a9a4c2134484bd40d72f62f7fc12b8704"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDeviceType.html">DEVICETYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#ad55a532bb0e6a0c550c1575fff36da0d">Fs_Device_Type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The device type structure for the file system devices. This is a specific example of the structure defined in PR5.8.  <a href="#ad55a532bb0e6a0c550c1575fff36da0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="filedev_8c.html#a384830ccae4f3f17aa3e72d20e0a3945">fs_param_count</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The start_param routine for the file system device type. See 5.8.22.  <a href="#a384830ccae4f3f17aa3e72d20e0a3945"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of the file system device type. </p>
<h2><a class="anchor" id="filedev_details">
Implementation of the file system device type.</a></h2>
<p>This is a largely complete, though simple, implementation.</p>
<p>The most complex part is the implementation of the filenameforall operator through the three relevant functions in the device.</p>
<p>This is the device type which is assigned the device type number 0</p>
<ul>
<li>see <a class="el" href="ripthread_8h.html" title="RIP lifecycle code.">ripthread.h</a> and Programmer's Reference manual section 5.6 for a discussion of device type numbers.</li>
</ul>
<p>A system which does not have a disk is still required to support a device type 0. However, the semantics would be different: it would only need to be readable, and supply known named files, such as Sys/ExtraDevices (which is essential) and built-in fonts. It could provide the byte stream for the read calls straight out of memory (ROM perhaps) rather than accessing a disk.</p>
<p>The operation of this implementation of the device type is that each device of this type represents a portion of the file system, e.g. on a PC the devices might be used to represent drives (C%, D%, ...) and on a Macintosh they represent volumes. There will always be a device os% created implictly by the core rip, and this will usually be a restricted part of the file system: Harlequin's own products have a directory called "SW" by default which is what os% refers to. Such a directory is supplied with the corerip library, including example system files, many of which may be used unchanged.</p>
<p>This implementation uses one device parameter, "/Prefix". This identifies where on the filing system the PostScript device is to refer to. This is a string representing a native pathname on the target file system. When PostScript refers to a file called "%p%aa/bb/cc", we map this to a name in the file system. This implementation does this by prefixing the name passed to the open call ("aa/bb/cc") with the prefix for the device (which is assumed to terminate with a '/'). The prefix is stored in the private data field of the devicelist structure for each device.</p>
<p>There is nothing special about the '/' in the PostScript name (see PR 5.3), but we map it to the platform's directory separator. This has two consequences: because the semantics of the name "aa/bb/cc" are those of a flat file system, when a request is made to open the file for writing, if we are to use the same name, we must create any directories in the path in order to open the file. The mapping also means that we ignore the difference between files called "aa/bb/cc/" and "aa/bb/cc". These are both valid PostScript names and should refer to different files, but are mapped to the same file in this implementation. To be strictly correct this should be handled by some more sophisticated name mapping.</p>
<p>Some names will causes failures, e.g. names with &gt; 31 chars on the Mac. To overcome this some name mapping mechanism would need to be implemented.</p>
<p>The prefix is obtained by the setdevparams PostScript operator, so a useful piece of PostScript (to go in Sys/ExtraDevices, for example) would be:</p>
<p>statusdict begin (cd%) dup devmount pop &lt;&lt; /Password 0 /DeviceType 0 /Prefix (./) /Enable true &gt;&gt; setdevparams end</p>
<p>(devmount is not listed in the PostScript Language Reference Manual, but is found in all PostScript rips with file systems).</p>
<p>However, there is no PostScript associated with mounting the os% device: it needs to exist in order for Sys/ExtraDevices to be executed. This implementation assumes its prefix is always "SW/" (i.e. a directory called SW in the current working directory). More general solutions include obtaining this from an environment variable, configuration file or command line option.</p>
<p>Though almost complete more general consideration might be given to the following:</p>
<ul>
<li>A complete implementation of the device_status function. </li>
<li>A comprehensive file name mapping scheme. </li>
<li>A more general mechanism for specifying and relocating the root os% device </li>
<li>A more general mechanism particularly for systems on which multiple copies of the rip may be running at the same time: especially to distribute files so that system files (including fonts) are available as a central resource, but users do not interfere with each other when, for example, writing files to the file system. </li>
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a99c120a20e0208e5ab29b6d7452c212a"></a><!-- doxytag: member="filedev.c::fs_bytes_file" ref="a99c120a20e0208e5ab29b6d7452c212a" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, Hq32x2 *bytes, int32 reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_bytes_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structHq32x2.html">Hq32x2</a> *&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bytes_file routine for the file system device type. See 5.8.14. </p>
<p>reason SW_BYTES_AVAIL_REL - immediately available after current pos reason SW_BYTES_TOTAL_ABS - total extent of file in bytes </p>

</div>
</div>
<a class="anchor" id="a1c069b95ecc965807a16785e52ced5cb"></a><!-- doxytag: member="filedev.c::fs_close_file" ref="a1c069b95ecc965807a16785e52ced5cb" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_close_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The close_file routine for the file system device type. See PR 5.8.11 and PR 5.8.12. </p>
<p>The abort call also invokes this function, because an abnormal close is the same as a normal close for the file system device type. </p>

</div>
</div>
<a class="anchor" id="aacfa7b617930d38ed9d606153a38c742"></a><!-- doxytag: member="filedev.c::fs_get_param" ref="aacfa7b617930d38ed9d606153a38c742" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_get_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The get_param routine for the file system device type. See PR 5.8.23. </p>
<p>This routine serves two purposes: when the parameter name is NULL, it is to return the next device parameter - fs_param_count keeps track of how far through the list we are, though in this case there is only one - otherwise it should return the one called for by the name.</p>
<p>There is a more complex example in the example implementation of the pagebuffer device type. </p>

</div>
</div>
<a class="anchor" id="aec947081b5533691536bc798b9b37bbf"></a><!-- doxytag: member="filedev.c::fs_ioctl" ref="aec947081b5533691536bc798b9b37bbf" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, int32 opcode, intptr_t arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ioctl routine for the file system device type. </p>
<p>At the time of this writing, the only ioctl opcode is ..._ShortRead, which is used to indicate that, although Harlequin RIP will ask for an entire buffer's data in the read_file call, only a certain number of bytes will be used: read-ahead won't help. Other opcodes may be added in the future. </p>

</div>
</div>
<a class="anchor" id="a7ef52dbcf84fa7b039132a395800321b"></a><!-- doxytag: member="filedev.c::fs_read_file" ref="a7ef52dbcf84fa7b039132a395800321b" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_read_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The read_file routine for the file system device type. See PR 5.8.9. </p>
<p>Read from file described by 'descriptor' which is on the device 'dev' into the buffer 'buff'.</p>
<p>For abnormally large buffers (only when the device requests such sizes by the appropriate device type call), reading from the file system in chunks might be required, with SwOften calls between each. </p>

</div>
</div>
<a class="anchor" id="ad742b09514fbbed4e529d538dac0cc0e"></a><!-- doxytag: member="filedev.c::fs_rename_file" ref="ad742b09514fbbed4e529d538dac0cc0e" args="(DEVICELIST *dev, uint8 *file1, uint8 *file2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_rename_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>file2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rename_file routine for the file system device type. See PR 5.8.19. </p>

</div>
</div>
<a class="anchor" id="abb56f68bca2d1b7db69718b49140ec7f"></a><!-- doxytag: member="filedev.c::fs_set_param" ref="abb56f68bca2d1b7db69718b49140ec7f" args="(DEVICELIST *dev, DEVICEPARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_set_param </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDEVICEPARAM.html">DEVICEPARAM</a> *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The set_param routine for the file system device type. See PR 5.8.21. </p>
<p>The only parameter that this implementation recognises is /Prefix, which must be a string, and it is used to define the prefix which is tacked on to the beginning of any filename requested by Harlequin RIP.</p>
<p>For a more complex example of device parameter handling see the example pagebuffer device implementation. </p>

</div>
</div>
<a class="anchor" id="a077754c77d7b911d14cfd25d6214144b"></a><!-- doxytag: member="filedev.c::fs_status_device" ref="a077754c77d7b911d14cfd25d6214144b" args="(DEVICELIST *dev, DEVSTAT *devstat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_status_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVSTAT *&nbsp;</td>
          <td class="paramname"> <em>devstat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The status_device routine for the file system device type. </p>
<p>This is in contrast to status_file: it returns information about a device of this device type, rather than a file open on the device. The comprehensive implementation of this routine is likely to be complex. The example here simply gives no useful information. </p>

</div>
</div>
<a class="anchor" id="a4308ebd3e7e06a4293f7746b78dd83cd"></a><!-- doxytag: member="filedev.c::fs_write_file" ref="a4308ebd3e7e06a4293f7746b78dd83cd" args="(DEVICELIST *dev, DEVICE_FILEDESCRIPTOR descriptor, uint8 *buff, int32 len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fs_write_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevicelist.html">DEVICELIST</a> *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DEVICE_FILEDESCRIPTOR&nbsp;</td>
          <td class="paramname"> <em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The write_file routine for the file system device type. See PR 5.8.10. </p>
<p>Write to the file described by 'descriptor' which is on the device 'dev' from the buffer 'buff'.</p>
<p>The comment for reading regarding SwOften also applies here. </p>

</div>
</div>
<a class="anchor" id="a9a4c2134484bd40d72f62f7fc12b8704"></a><!-- doxytag: member="filedev.c::KGetSWDir" ref="a9a4c2134484bd40d72f62f7fc12b8704" args="(uint8 *pSWDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KGetSWDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pSWDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an explicit path to the SW folder, taking into account any path set using <a class="el" href="filedev_8c.html#ae23f216f3ebedbae08f16cef9afb6f5f" title="Record an explicit path to the SW folder, overriding any default search rules.">KSetSWDir()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to memory at least LONGESTFILENAME bytes in length, which on output contains the SW folder path (terminated with a directory separator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae23f216f3ebedbae08f16cef9afb6f5f"></a><!-- doxytag: member="filedev.c::KSetSWDir" ref="ae23f216f3ebedbae08f16cef9afb6f5f" args="(uint8 *pSWDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> KSetSWDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td>
          <td class="paramname"> <em>pSWDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Record an explicit path to the SW folder, overriding any default search rules. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pSWDir</em>&nbsp;</td><td>Pointer to a null-terminated path, which may not exceed LONGESTFILENAME in length (inclusive of the terminator), and which must end with a directory separator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success; FALSE otherwise.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is not thread-safe, and so should be called prior to the creation of any file device instances. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ad55a532bb0e6a0c550c1575fff36da0d"></a><!-- doxytag: member="filedev.c::Fs_Device_Type" ref="ad55a532bb0e6a0c550c1575fff36da0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDeviceType.html">DEVICETYPE</a> <a class="el" href="ripthread_8c.html#ad55a532bb0e6a0c550c1575fff36da0d">Fs_Device_Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The device type structure for the file system devices. This is a specific example of the structure defined in PR5.8. </p>
<p>Points to note: (a) of the function pointers included in this structure, only the tickle function may be a NULL pointer. The rest must be filled in with stub routines which at least set the last error flag appropriately. The dismount call does nothing else but indicates success with its return code; however the buffer size function indicates failure, which means that a fixed size buffer will be allocated see PR5.8.2 and PR5.8.26. (b) the device is "relative" (it can support named files, unlike, for example, a serial line). This means that when an attempt is made to open a named file in PostScript unqualified by a device, devices of this type will each receive open requests until one does not report an "undefined" error. See PR5.8.2 (c) the device is "writable": this means that devices of this type will be considered when trying to open a file for writing from PostScript. </p>

</div>
</div>
<a class="anchor" id="a384830ccae4f3f17aa3e72d20e0a3945"></a><!-- doxytag: member="filedev.c::fs_param_count" ref="a384830ccae4f3f17aa3e72d20e0a3945" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="filedev_8c.html#a384830ccae4f3f17aa3e72d20e0a3945">fs_param_count</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The start_param routine for the file system device type. See 5.8.22. </p>
<p>The routine is called as part of the currentdevparams operator; the individual parameters are returned one at a time by subsequent calls to the get_param function. fs_param_count is used to maintain the state between calls to get_param.</p>
<p>Also return the number of parameters recognized by this implementation of the file system device type. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
