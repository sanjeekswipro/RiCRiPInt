<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sw_data_api Struct Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sw_data_api Struct Reference<br/>
<small>
[<a class="el" href="group__swdataapi.html">Structured data callback API</a>]</small>
</h1><!-- doxytag: class="sw_data_api" -->
<p>A structure containing callback functions for structured data access.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;swdataapi.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__api__info.html">sw_api_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629">get_indexed</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *array, size_t index, <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an indexed value from an array or stack datum.  <a href="#a101cb68f8614d8866fb8555a84a3b629"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a30bbc33197fbea44d9f41b15545ca16c">set_indexed</a> )(<a class="el" href="structsw__datum.html">sw_datum</a> *array, size_t index, const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store an indexed value in an array or stack datum.  <a href="#a30bbc33197fbea44d9f41b15545ca16c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#aa49dc28fbd0e9f9488bacd510d2fac18">get_keyed</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *dict, const <a class="el" href="structsw__datum.html">sw_datum</a> *key, <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a keyed value from a dictionary datum.  <a href="#aa49dc28fbd0e9f9488bacd510d2fac18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#aa24c0d20173ddb95c8afd5f700aef3b1">set_keyed</a> )(<a class="el" href="structsw__datum.html">sw_datum</a> *dict, const <a class="el" href="structsw__datum.html">sw_datum</a> *key, const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store a keyed value in a dictionary datum.  <a href="#aa24c0d20173ddb95c8afd5f700aef3b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a921ebb4102d233fadd989d3ddc9148f6">match</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite, <a class="el" href="structsw__data__match.html">sw_data_match</a> *<a class="el" href="structsw__data__api.html#a921ebb4102d233fadd989d3ddc9148f6">match</a>, size_t match_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match multiple data entries in a dictionary or array datum.  <a href="#a921ebb4102d233fadd989d3ddc9148f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#aee3012e8a393740dc7932666455dbe9b">iterate_begin</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite, <a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> **iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a new iteration over a dictionary or array datum.  <a href="#aee3012e8a393740dc7932666455dbe9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a9780a53ec10673910ec43358789b528c">iterate_next</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite, <a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> *iterator, <a class="el" href="structsw__datum.html">sw_datum</a> *key, <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a key-value pair from a dictionary or array datum iteration.  <a href="#a9780a53ec10673910ec43358789b528c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#abb790b510429e32f3b11c78db69be065">iterate_end</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite, <a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> **iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard resources associated with a data structure iterator state.  <a href="#abb790b510429e32f3b11c78db69be065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a5bbbda80151d5bc3993f62dca1bf7541">equal</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *one, const <a class="el" href="structsw__datum.html">sw_datum</a> *two)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two datums for equality.  <a href="#a5bbbda80151d5bc3993f62dca1bf7541"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a7ffd86fe33f4d28b65dcfd349764c33f">open_blob</a> )(const <a class="el" href="structsw__datum.html">sw_datum</a> *datum, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> mode, <a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **blob)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a SW_DATUM_TYPE_BLOB datum for access via the <a class="el" href="structsw__blob__api.html" title="A structure containing callback functions for BLOB (Binary Large Object) access.">sw_blob_api</a> interface.  <a href="#a7ffd86fe33f4d28b65dcfd349764c33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#a9ae03d6cd0bf51bf08f0b71acec1e6a6">pop</a> )(<a class="el" href="structsw__datum.html">sw_datum</a> *stack)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop the top element from the stack. A stack is an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY.  <a href="#a9ae03d6cd0bf51bf08f0b71acec1e6a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__data__api.html#ae7f007e4c23cb2414b28f98827c6b7de">push</a> )(<a class="el" href="structsw__datum.html">sw_datum</a> *stack, const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push an entry onto a stack. A stack is an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY.  <a href="#ae7f007e4c23cb2414b28f98827c6b7de"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A structure containing callback functions for structured data access. </p>
<p>Data references provided from the RIP are automatically invalidated at the end of the callback that passed them to a module. All data that is to be stored between calls to the module must be copied from the RIP.</p>
<p>Note that in the case of complex types such as strings, arrays and dictionaries, it is not enough to copy the <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> - its contents must be copied. This includes the bytes of a strings, and all the elements of an array or dictionary. It is not usually necessary to copy datums in this way.</p>
<p>Creators of <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> complex types can implement this API, pointing the datum's owner field at their <a class="el" href="structsw__data__api.html" title="A structure containing callback functions for structured data access.">sw_data_api</a> structure, to enable on-demand creation or delivery of array, stack and dictionary contents. In such a case, the implementor uses the datum's value.opaque field for its own purposes. A <a class="el" href="structsw__data__api.html" title="A structure containing callback functions for structured data access.">sw_data_api</a> created for this purpose need only implement those methods that are relevant - NULL methods return SW_DATA_ERROR_INVALIDACCESS if used. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a5bbbda80151d5bc3993f62dca1bf7541"></a><!-- doxytag: member="sw_data_api::equal" ref="a5bbbda80151d5bc3993f62dca1bf7541" args=")(const sw_datum *one, const sw_datum *two)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__data__api.html#a5bbbda80151d5bc3993f62dca1bf7541">equal</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *one,const <a class="el" href="structsw__datum.html">sw_datum</a> *two)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two datums for equality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>one</em>&nbsp;</td><td>The first <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>two</em>&nbsp;</td><td>The second <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>the values were of incomparable types, or were not equal.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>the values were of comparable types of the same value.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a strict equality test for composites, but is otherwise an equivalence test, so the numeric value of a float can be equal to the value of an integer, for example. For composites such as arrays this does not compare the contents, but tests whether they are the same array. </p>

</div>
</div>
<a class="anchor" id="a101cb68f8614d8866fb8555a84a3b629"></a><!-- doxytag: member="sw_data_api::get_indexed" ref="a101cb68f8614d8866fb8555a84a3b629" args=")(const sw_datum *array, size_t index, sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629">get_indexed</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *array, size_t index,<a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an indexed value from an array or stack datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>array</em>&nbsp;</td><td>An array or stack datum from which an indexed value will be extracted.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the value to extract. Zero means the first element of the array, or the topmost element of the stack.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The location to be filled in with the returned value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The <em>value</em> entry is filled with the indexed array or stack entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_RANGECHECK</em>&nbsp;</td><td>Returned if the index is out of range.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if the indexed value is an unsupported type or the first parameter isn't an array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the array was not readable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa49dc28fbd0e9f9488bacd510d2fac18"></a><!-- doxytag: member="sw_data_api::get_keyed" ref="aa49dc28fbd0e9f9488bacd510d2fac18" args=")(const sw_datum *dict, const sw_datum *key, sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#aa49dc28fbd0e9f9488bacd510d2fac18">get_keyed</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *dict,const <a class="el" href="structsw__datum.html">sw_datum</a> *key,<a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a keyed value from a dictionary datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dict</em>&nbsp;</td><td>A dictionary datum from which a keyed value will be extracted.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>A key for the value to extract. The type of the key may be restricted to transparent type (strings, integer, boolean, real, null), depending on the owner of the dictionary.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The location to be filled in with the returned value.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The <em>value</em> entry is filled with the keyed array entry.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_UNDEFINED</em>&nbsp;</td><td>Returned if the key does not exist in the dictionary.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if the keyed value is an unsupported type or the first parameter is not a dictionary.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the dictionary was not readable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab716503b26170e15c9990c190bd2e175"></a><!-- doxytag: member="sw_data_api::info" ref="ab716503b26170e15c9990c190bd2e175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__api__info.html">sw_api_info</a> <a class="el" href="structsw__data__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Version number, name, display name, size. This is REQUIRED to be the first field. </p>

</div>
</div>
<a class="anchor" id="aee3012e8a393740dc7932666455dbe9b"></a><!-- doxytag: member="sw_data_api::iterate_begin" ref="aee3012e8a393740dc7932666455dbe9b" args=")(const sw_datum *composite, sw_data_iterator **iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#aee3012e8a393740dc7932666455dbe9b">iterate_begin</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite,<a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> **iterator)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a new iteration over a dictionary or array datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>composite</em>&nbsp;</td><td>The datum to iterate over.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>A pointer to an opaque iteration state.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Returned if the iterator was started. <code><a class="el" href="structsw__data__api.html#abb790b510429e32f3b11c78db69be065" title="Discard resources associated with a data structure iterator state.">iterate_end()</a></code> must be called when complete to dispose of the iterator state.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if the composite datum is not of a suitable type to iterate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_MEMORY</em>&nbsp;</td><td>Returned if the iteration state could not be created because of a memory allocation failure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the composite datum was not readable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb790b510429e32f3b11c78db69be065"></a><!-- doxytag: member="sw_data_api::iterate_end" ref="abb790b510429e32f3b11c78db69be065" args=")(const sw_datum *composite, sw_data_iterator **iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__data__api.html#abb790b510429e32f3b11c78db69be065">iterate_end</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite,<a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> **iterator)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard resources associated with a data structure iterator state. </p>
<p>If <code><a class="el" href="structsw__data__api.html#aee3012e8a393740dc7932666455dbe9b" title="Start a new iteration over a dictionary or array datum.">iterate_begin()</a></code> succeeded, this function must be called to dispose of the iterator state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>composite</em>&nbsp;</td><td>The data structure being iterated.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>The location where the iterator state is stored. The iterator state pointer will be invalidated on exit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9780a53ec10673910ec43358789b528c"></a><!-- doxytag: member="sw_data_api::iterate_next" ref="a9780a53ec10673910ec43358789b528c" args=")(const sw_datum *composite, sw_data_iterator *iterator, sw_datum *key, sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a9780a53ec10673910ec43358789b528c">iterate_next</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite,<a class="el" href="group__swdataapi.html#gaa626b53acbb676c3f567d1fc4d6f233f">sw_data_iterator</a> *iterator,<a class="el" href="structsw__datum.html">sw_datum</a> *key,<a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a key-value pair from a dictionary or array datum iteration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>composite</em>&nbsp;</td><td>The datum being iterated.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>An iterator state previously created by <code><a class="el" href="structsw__data__api.html#aee3012e8a393740dc7932666455dbe9b" title="Start a new iteration over a dictionary or array datum.">iterate_begin()</a></code>.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>A unique key identifying the datum in the composite structure. When iterating over arrays, this will be set to an integer datum with the index of the associated value.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value associated with <em>key</em> in the composite structure.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The <em>key</em> and <em>value</em> parameters are filled in.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_FINISHED</em>&nbsp;</td><td>Returned when there are no more keys to iterate over.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_MEMORY</em>&nbsp;</td><td>Returned if the iteration state could not be updated because of a memory allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a921ebb4102d233fadd989d3ddc9148f6"></a><!-- doxytag: member="sw_data_api::match" ref="a921ebb4102d233fadd989d3ddc9148f6" args=")(const sw_datum *composite, sw_data_match *match, size_t match_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a921ebb4102d233fadd989d3ddc9148f6">match</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *composite,<a class="el" href="structsw__data__match.html">sw_data_match</a> *<a class="el" href="structsw__data__api.html#a921ebb4102d233fadd989d3ddc9148f6">match</a>, size_t match_length)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Match multiple data entries in a dictionary or array datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>composite</em>&nbsp;</td><td>An array or dictionary datum from which values will be extracted.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>match</em>&nbsp;</td><td>An array of match structures, determining the key to match, what types are acceptable for the match, how to treat type mismatches or missing values, and where to store the value.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>match_length</em>&nbsp;</td><td>The number of entries to match.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The match result data are updated with the value of the extracted entries, or set to SW_DATUM_TYPE_NOTHING if the key was not matched but was optional.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_UNDEFINED</em>&nbsp;</td><td>Returned if a required entry was not present. The match data should not be examined if this error occurs.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if a matched value has the wrong type, and the SW_DATA_TYPE_INVALID bit was not set in the allowed type mask of the match. The match data should not be examined if this error occurs. This error is also returned if the first parameter is not an array or dictionary.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the data structure to match was not readable. The match data should not be examined if this error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ffd86fe33f4d28b65dcfd349764c33f"></a><!-- doxytag: member="sw_data_api::open_blob" ref="a7ffd86fe33f4d28b65dcfd349764c33f" args=")(const sw_datum *datum, int32 mode, sw_blob_instance **blob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a7ffd86fe33f4d28b65dcfd349764c33f">open_blob</a>)(const <a class="el" href="structsw__datum.html">sw_datum</a> *datum, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> mode,<a class="el" href="structsw__blob__instance.html">sw_blob_instance</a> **blob)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a SW_DATUM_TYPE_BLOB datum for access via the <a class="el" href="structsw__blob__api.html" title="A structure containing callback functions for BLOB (Binary Large Object) access.">sw_blob_api</a> interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>datum</em>&nbsp;</td><td>A datum of type SW_DATUM_TYPE_BLOB.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>An access mode of SW_RDONLY, SW_WRONLY, or SW_RDWR, possibly combined with the flags SW_FONT and SW_EXCL, as defined in <a class="el" href="swdevice_8h.html" title="This file provides the information required to set up devices outside the rip.">swdevice.h</a>. If none of the access mode flags are set, the RIP will derive the access mode from the datum itself.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blob</em>&nbsp;</td><td>A pointer to a handle for a <a class="el" href="structsw__blob__instance.html" title="An instance of the blob API implementation.">sw_blob_instance</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_DATA_OK if a blob was opened. In this case a valid blob handle will be stored in blob. The caller must release the blob reference when it has finished accessing it using the <a class="el" href="structsw__blob__api.html#a03deea78bc7a39ea5d0d2307c150f7fe" title="Close a blob reference, releasing its resources.">sw_blob_api::close</a> method. If the blob could not be opened, then one of the sw_data_result error codes will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ae03d6cd0bf51bf08f0b71acec1e6a6"></a><!-- doxytag: member="sw_data_api::pop" ref="a9ae03d6cd0bf51bf08f0b71acec1e6a6" args=")(sw_datum *stack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a9ae03d6cd0bf51bf08f0b71acec1e6a6">pop</a>)(<a class="el" href="structsw__datum.html">sw_datum</a> *stack)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop the top element from the stack. A stack is an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stack</em>&nbsp;</td><td>A stack datum from which the datum will be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The top entry was popped from the stack.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_RANGECHECK</em>&nbsp;</td><td>Returned if the stack is empty.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if stack is not an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the stack was not readable or mutable.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that like set_indexed, pop implicitly invalidates any opaque datum representing the value that has been popped from the stack. eg: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> top, temp ;
        (void)<a class="code" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629" title="Get an indexed value from an array or stack datum.">get_indexed</a>(stack, 0, &amp;top) ;    <span class="comment">// get topmost element</span>
        (void)<a class="code" href="structsw__data__api.html#a9ae03d6cd0bf51bf08f0b71acec1e6a6" title="Pop the top element from the stack. A stack is an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRA...">pop</a>(stack) ;                     <span class="comment">// implicitly invalidates &#39;top&#39;</span>
        <span class="keywordflow">if</span> (top.<a class="code" href="structsw__datum.html#aa5044999f3339d2ba3b1bf22fa6cfe95">type</a> == <a class="code" href="group__swdataapi.html#gga385c44f6fb256e5716a2302a5b940388a3c6ada4c228cc10181ebfd01b4691684">SW_DATUM_TYPE_ARRAY</a>) { <span class="comment">// ERROR! Invalid opaque type</span>
          (void)<a class="code" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629" title="Get an indexed value from an array or stack datum.">get_indexed</a>(stack, 0, &amp;temp) ; <span class="comment">// CRASH!</span>
</pre></div><p>Do not change or pop an opaque datum until you have finished with it. See set_indexed for more details. </p>

</div>
</div>
<a class="anchor" id="ae7f007e4c23cb2414b28f98827c6b7de"></a><!-- doxytag: member="sw_data_api::push" ref="ae7f007e4c23cb2414b28f98827c6b7de" args=")(sw_datum *stack, const sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#ae7f007e4c23cb2414b28f98827c6b7de">push</a>)(<a class="el" href="structsw__datum.html">sw_datum</a> *stack,const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push an entry onto a stack. A stack is an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stack</em>&nbsp;</td><td>A stack datum onto which the datum will be added.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The datum to be pushed onto the top of the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Success. The <em>value</em> entry has been pushed onto the top of the stack.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_RANGECHECK</em>&nbsp;</td><td>Returned if the stack is full.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if stack is not an array datum of subtype SW_DATUM_SUBTYPE_STACK_ARRAY or the value is not of a suitable type.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_MEMORY</em>&nbsp;</td><td>Returned if a memory allocation failed while trying to push the value.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the stack was not writeable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30bbc33197fbea44d9f41b15545ca16c"></a><!-- doxytag: member="sw_data_api::set_indexed" ref="a30bbc33197fbea44d9f41b15545ca16c" args=")(sw_datum *array, size_t index, const sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#a30bbc33197fbea44d9f41b15545ca16c">set_indexed</a>)(<a class="el" href="structsw__datum.html">sw_datum</a> *array, size_t index,const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store an indexed value in an array or stack datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>array</em>&nbsp;</td><td>An array or stack datum into which an indexed value will be stored.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index at which to store the value. Zero means the first element of the array, or the topmost element of the stack.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The datum to store into the array. Values in local module memory will be deep-copied when storing into RIP owned arrays or stacks.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Returned if successful.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if the first parameter isn't an array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_RANGECHECK</em>&nbsp;</td><td>Returned if the index is out of range.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the value cannot be stored into the array or stack.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_MEMORY</em>&nbsp;</td><td>Returned if a memory allocation failed while trying to store the value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that using set_indexed to change an element of an array or stack will invalidate any opaque datum already fetched from that index - datums represent data, they are not necessarily an independent copy of that data. eg: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> got, temp, change = <a class="code" href="group__swdataapi.html#gaaae72d41ff8ea336f575ec8a96e100c5">SW_DATUM_INTEGER</a>(0) ;
        (void)<a class="code" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629" title="Get an indexed value from an array or stack datum.">get_indexed</a>(arr, 0, &amp;got) ;      <span class="comment">// ignore errors for this example</span>
        (void)<a class="code" href="structsw__data__api.html#a30bbc33197fbea44d9f41b15545ca16c" title="Store an indexed value in an array or stack datum.">set_indexed</a>(arr, 0, &amp;change) ;   <span class="comment">// implicitly invalidates &#39;got&#39;</span>
        <span class="keywordflow">if</span> (got.<a class="code" href="structsw__datum.html#aa5044999f3339d2ba3b1bf22fa6cfe95">type</a> == <a class="code" href="group__swdataapi.html#gga385c44f6fb256e5716a2302a5b940388a3c6ada4c228cc10181ebfd01b4691684">SW_DATUM_TYPE_ARRAY</a>) { <span class="comment">// ERROR! got is no longer valid</span>
          (void)<a class="code" href="structsw__data__api.html#a101cb68f8614d8866fb8555a84a3b629" title="Get an indexed value from an array or stack datum.">get_indexed</a>(&amp;got, 0 &amp;temp) ;   <span class="comment">// CRASH!</span>
</pre></div><p>In the above example, array index 0 is changed after having been fetched, so the fetched opaque datum no longer represents the actual data. Any attempt to use that outdated representation can fail in unpredictable and serious ways. </p>

</div>
</div>
<a class="anchor" id="aa24c0d20173ddb95c8afd5f700aef3b1"></a><!-- doxytag: member="sw_data_api::set_keyed" ref="aa24c0d20173ddb95c8afd5f700aef3b1" args=")(sw_datum *dict, const sw_datum *key, const sw_datum *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swdataapi.html#ga59c2724224a465eabd4d6ad836077338">sw_data_result</a>( * <a class="el" href="structsw__data__api.html#aa24c0d20173ddb95c8afd5f700aef3b1">set_keyed</a>)(<a class="el" href="structsw__datum.html">sw_datum</a> *dict,const <a class="el" href="structsw__datum.html">sw_datum</a> *key,const <a class="el" href="structsw__datum.html">sw_datum</a> *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store a keyed value in a dictionary datum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dict</em>&nbsp;</td><td>A dictionary datum into which a keyed value will be stored.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>A key for the value to store. The type of the key may be restricted to transparent type (strings, integer, boolean, real, null), depending on the owner of the dictionary.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The datum to store into the dictionary. Values in local module memory will be deep-copied when stored in RIP owned dictionaries.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_OK</em>&nbsp;</td><td>Returned if successful.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_TYPECHECK</em>&nbsp;</td><td>Returned if the first parameter is not a dictionary or the value is not of an appropriate type.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_INVALIDACCESS</em>&nbsp;</td><td>Returned if the value cannot be stored into the dictionary.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SW_DATA_ERROR_MEMORY</em>&nbsp;</td><td>Returned if a memory allocation failed while trying to store the value.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that like set_indexed, changing a dictionary value with set_keyed will invalidate any opaque datum fetched for that key. See set_indexed for details. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="swdataapi_8h.html">swdataapi.h</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
