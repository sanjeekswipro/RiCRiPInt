<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: mem.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>mem.c File Reference</h1>
<p>Memory-related utility functions.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;mpscmvff.h&quot;</code><br/>
<code>#include &quot;mpsavm.h&quot;</code><br/>
<code>#include &quot;mpsacl.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="skinkit_8h.html">skinkit.h</a>&quot;</code><br/>
<code>#include &quot;mps.h&quot;</code><br/>
<code>#include &quot;mpslib.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structheader__s.html">header_s</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Each block allocated needs to remember its size, so we add a header to keep it in. HEADER_BLOCK and BLOCK_HEADER translate between a pointer to the header and a pointer to the block (what the caller of malloc gets).  <a href="structheader__s.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df30b48781f4c5e05c493eb6f89abd9"></a><!-- doxytag: member="mem.c::OTHER_ALLOCATIONS_IN_BYTES" ref="a5df30b48781f4c5e05c493eb6f89abd9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a5df30b48781f4c5e05c493eb6f89abd9">OTHER_ALLOCATIONS_IN_BYTES</a>&nbsp;&nbsp;&nbsp;((size_t)50 * (size_t)1024 * (size_t)1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default maximum address space size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2bfbff2a1424939f95ea9f8c3883c72"></a><!-- doxytag: member="mem.c::RIP_DEFAULT_MEMORY_IN_BYTES" ref="ac2bfbff2a1424939f95ea9f8c3883c72" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#ac2bfbff2a1424939f95ea9f8c3883c72">RIP_DEFAULT_MEMORY_IN_BYTES</a>&nbsp;&nbsp;&nbsp;80 * 1024 * 1024</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum amount of memory, in bytes, to be used by the core RIP in cases where the physical RAM configuration cannot be determined. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a29f724a2d5a8ac53e46fc17e6b321c1d">MemLogInit</a> (const char *mps_log, unsigned long mps_telemetry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up the memory system to log to a file.  <a href="#a29f724a2d5a8ac53e46fc17e6b321c1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a01b3fee52fcfb51c608ba62d1da9dad8">MemInit</a> (size_t *RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, void *pMemory, <a class="el" href="structSysMemFns.html">SysMemFns</a> *pSysMemFns)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise the memory arena and create the memory pool for use in skin.  <a href="#a01b3fee52fcfb51c608ba62d1da9dad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#ac2155a537faf0d78c3de28f2d6020543">MemFinish</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fError)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the arena of managed memory.  <a href="#ac2155a537faf0d78c3de28f2d6020543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c">MemAlloc</a> (size_t cbSize, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fZero, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fExitOnFail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory for use by the skin layer.  <a href="#af063745d134a0169db13c01bf86af18c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a149e3ef90717b76250b80746c94a7c93">MemRealloc</a> (void *ptr, size_t cbSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocate a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code>.  <a href="#a149e3ef90717b76250b80746c94a7c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a57a7c5cb020740b2bcd35d774899c46e">MemFree</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code>.  <a href="#a57a7c5cb020740b2bcd35d774899c46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a1bd035af76be36b4f8eb41e52cd77786">SysAlloc</a> (size_t cbSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of system memory for use by the skin layer.  <a href="#a1bd035af76be36b4f8eb41e52cd77786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#abf2729b34d59d54dd85512c3a37ee8e1">SysFree</a> (void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#a1bd035af76be36b4f8eb41e52cd77786" title="Allocate a block of system memory for use by the skin layer.">SysAlloc()</a></code>.  <a href="#abf2729b34d59d54dd85512c3a37ee8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ca0b8ca13b6225f3703991b80fa55d"></a><!-- doxytag: member="mem.c::MemGetArena" ref="a58ca0b8ca13b6225f3703991b80fa55d" args="(void)" -->
mps_arena_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a58ca0b8ca13b6225f3703991b80fa55d">MemGetArena</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the single arena of managed memory that is shared between the core RIP and the skin layer. <br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4611a2d5ddbb14c5dfdc48939eaf826a"></a><!-- doxytag: member="mem.c::mem_arena" ref="a4611a2d5ddbb14c5dfdc48939eaf826a" args="" -->
static mps_arena_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a4611a2d5ddbb14c5dfdc48939eaf826a">mem_arena</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The single MPS arena used by both core and skin. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a7554c0220bb2bb071df58d5685fadc"></a><!-- doxytag: member="mem.c::skin_pool" ref="a2a7554c0220bb2bb071df58d5685fadc" args="" -->
static mps_pool_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem_8c.html#a2a7554c0220bb2bb071df58d5685fadc">skin_pool</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The memory pool for use in skin. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Memory-related utility functions. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af063745d134a0169db13c01bf86af18c"></a><!-- doxytag: member="mem.c::MemAlloc" ref="af063745d134a0169db13c01bf86af18c" args="(size_t cbSize, int32 fZero, int32 fExitOnFail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* MemAlloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>cbSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fExitOnFail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory for use by the skin layer. </p>
<p>Always use <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code> and <code><a class="el" href="mem_8c.html#a57a7c5cb020740b2bcd35d774899c46e" title="Free a block of memory that was allocated by a prior call to MemAlloc().">MemFree()</a></code> to manage allocations in the skin where possible. These functions allow the memory to be managed more effectively, and also allow the skin code to be subjected to the same heap limitation controls as the core RIP. Direct use of malloc can cause the skin to overflow any such limitations that might be in place.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbSize</em>&nbsp;</td><td>The amount of memory required, measured in bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fZero</em>&nbsp;</td><td>Pass <code>TRUE</code> if you require the memory block to be initialized with zeros, otherwise pass <code>FALSE</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fExitOnFail</em>&nbsp;</td><td>Controls failing behaviour. If passed as <code>TRUE</code>, the entire host application will be terminated if the allocation fails. Otherwise, a failure will result in a NULL return value. It is usually better to pass <code>FALSE</code>, and write additional code to handle failed allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory block, or NULL if the allocation failed (and <code>fExitOnFail==FALSE</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="ac2155a537faf0d78c3de28f2d6020543"></a><!-- doxytag: member="mem.c::MemFinish" ref="ac2155a537faf0d78c3de28f2d6020543" args="(int32 fError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>fError</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the arena of managed memory. </p>
<p>A call to this function should be one of the final acts in shutting down the host application. Once this function has been called, neither the RIP nor the skin layer will be permitted to use the shared arena of managed memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fError</em>&nbsp;</td><td>Indicates whether the application is shutting down in an error state. Pass zero if the application is shutting down successfully. Pass any non-zero to indicate an error state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a7c5cb020740b2bcd35d774899c46e"></a><!-- doxytag: member="mem.c::MemFree" ref="a57a7c5cb020740b2bcd35d774899c46e" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemFree </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pbMem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pbMem</em>&nbsp;</td><td>The memory block to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01b3fee52fcfb51c608ba62d1da9dad8"></a><!-- doxytag: member="mem.c::MemInit" ref="a01b3fee52fcfb51c608ba62d1da9dad8" args="(size_t *RIP_maxAddressSpaceInBytes, size_t RIP_workingSizeInBytes, void *pMemory, SysMemFns *pSysMemFns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemInit </td>
          <td>(</td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>RIP_maxAddressSpaceInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>RIP_workingSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSysMemFns.html">SysMemFns</a> *&nbsp;</td>
          <td class="paramname"> <em>pSysMemFns</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the memory arena and create the memory pool for use in skin. </p>
<p>The core RIP and the demonstration skin will share the same memory arena. However, the skin will have its own pool within that arena. It is possible to apply a constraint to the amount of memory that the core RIP and the skin are permitted to use in combination. Use the <code>RIP_workingSizeInBytes</code> parameter to do this.</p>
<p>It is also possible for the RIP to work within a region of memory that has been pre-allocated by the host application. Use the <code>pMemory</code> argument to do this.</p>
<p>This function <em>must</em> be called before booting the RIP, and before any use of the other skin memory-management functions defined in this file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RIP_maxAddressSpaceInBytes</em>&nbsp;</td><td>The size of maximum address space the RIP can use. This value gets filled in.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RIP_workingSizeInBytes</em>&nbsp;</td><td>The size of working memory permitted for the RIP, measured in bytes. If you pass zero, the function will attempt to calculate a suitable default based upon the memory configuration of the host machine. If details of the memory configuration cannot be determined, a hard-coded default will be applied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMemory</em>&nbsp;</td><td>Points to a caller-allocated memory block that the RIP should use. If this is non-NULL, the RIP will work within this memory block, rather than allocating its own memory. The size of the block is defined by <code>RIP_workingSizeInBytes</code>, which must not be zero. If this pointer is NULL, then the RIP will allocate and manage its own memory, suitably constrained by <code>RIP_workingSizeInBytes</code>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pSysMemFns</em>&nbsp;</td><td>Points to a structure providing the suite of system memory handling functions for use by <code>SysAlloc</code>, and <code>SysFree</code>. If this is NULL the default functions are used, which are implemented using the OS <code>malloc</code> and <code>free</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual size of working memory applied for the RIP. This would normally be equal to <code>RIP_workingSizeInBytes</code>, except for the case where <code>RIP_workingSizeInBytes == 0</code>, where the value returned will be whatever default size was applied. </dd></dl>

</div>
</div>
<a class="anchor" id="a29f724a2d5a8ac53e46fc17e6b321c1d"></a><!-- doxytag: member="mem.c::MemLogInit" ref="a29f724a2d5a8ac53e46fc17e6b321c1d" args="(const char *mps_log, unsigned long mps_telemetry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemLogInit </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mps_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mps_telemetry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up the memory system to log to a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mps_log</em>&nbsp;</td><td>Filename for MPS memory logging. If the MPS library linked in the RIP supports logging, all of the enabled telemetry will be written to this file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mps_telemetry</em>&nbsp;</td><td>MPS telemetry options. If the MPS library linked in the RIP supports logging, this option controls which events are logged to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function must be called before <code><a class="el" href="mem_8c.html#a01b3fee52fcfb51c608ba62d1da9dad8" title="Initialise the memory arena and create the memory pool for use in skin.">MemInit()</a></code> (and <code><a class="el" href="group__skinkit.html#ga6f0a7db8aaffd844f27976a4d7eeac24" title="Initialise SDK support libraries for the RIP.">SwLeSDKStart()</a></code>, which calls <code><a class="el" href="mem_8c.html#a01b3fee52fcfb51c608ba62d1da9dad8" title="Initialise the memory arena and create the memory pool for use in skin.">MemInit()</a></code>). </dd></dl>

</div>
</div>
<a class="anchor" id="a149e3ef90717b76250b80746c94a7c93"></a><!-- doxytag: member="mem.c::MemRealloc" ref="a149e3ef90717b76250b80746c94a7c93" args="(void *ptr, size_t cbSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* MemRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>cbSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reallocate a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>The memory block to be reallocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSize</em>&nbsp;</td><td>The amount of memory required, measured in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bd035af76be36b4f8eb41e52cd77786"></a><!-- doxytag: member="mem.c::SysAlloc" ref="a1bd035af76be36b4f8eb41e52cd77786" args="(size_t cbSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SysAlloc </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>cbSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of system memory for use by the skin layer. </p>
<p>Uses the function passed via the <code><a class="el" href="structSysMemFns.html" title="Defines a structure to hold a set of system memory allocation functions.">SysMemFns</a></code> structure to <code>MemInit</code>, or <code>malloc</code> if no structure was passed.</p>
<p>Allocate memory when it is not possible or appropriate to use <code><a class="el" href="mem_8c.html#af063745d134a0169db13c01bf86af18c" title="Allocate a block of memory for use by the skin layer.">MemAlloc()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbSize</em>&nbsp;</td><td>The amount of memory required, measured in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the allocated memory block, or NULL if the allocation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="abf2729b34d59d54dd85512c3a37ee8e1"></a><!-- doxytag: member="mem.c::SysFree" ref="abf2729b34d59d54dd85512c3a37ee8e1" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysFree </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pbMem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a block of memory that was allocated by a prior call to <code><a class="el" href="mem_8c.html#a1bd035af76be36b4f8eb41e52cd77786" title="Allocate a block of system memory for use by the skin layer.">SysAlloc()</a></code>. </p>
<p>Uses the function passed via the <code><a class="el" href="structSysMemFns.html" title="Defines a structure to hold a set of system memory allocation functions.">SysMemFns</a></code> structure to <code>MemInit</code>, or <code>free</code> if no structure was passed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pbMem</em>&nbsp;</td><td>The memory block to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
