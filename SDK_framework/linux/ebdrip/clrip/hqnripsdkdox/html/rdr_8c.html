<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: rdr.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_5447373cf4a6d916fd5542a2ac065105.html">rdrevent</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_4cabbbfd250f53c8870db080ce7ad97a.html">src</a>
  </div>
</div>
<div class="contents">
<h1>rdr.c File Reference</h1>
<p>This file provides the ROM Data Resource API.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="rdrpriv_8h.html">rdrpriv.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a5d073b3ea1397e2e051147c04b3a4d22">move_iterator</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *find, <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> **from, <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> **to)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr.html">sw_rdr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a7bef74e62e0dc0fa70d3064d034ff8cb">find_rdr</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *find, int unlock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an rdr from an iterator structure.  <a href="#a7bef74e62e0dc0fa70d3064d034ff8cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1da2f0e6720352e277375e8ff07e9e05"></a><!-- doxytag: member="rdr.c::link_iterator" ref="a1da2f0e6720352e277375e8ff07e9e05" args="(sw_rdr_iterator *iterator, sw_rdr_iterator **list)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a1da2f0e6720352e277375e8ff07e9e05">link_iterator</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> **list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link an iterator into a list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aff9ee3fab2c51d6652f5a8cd3eab1f"></a><!-- doxytag: member="rdr.c::unlink_iterator" ref="a2aff9ee3fab2c51d6652f5a8cd3eab1f" args="(sw_rdr_iterator *iterator)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a2aff9ee3fab2c51d6652f5a8cd3eab1f">unlink_iterator</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unlink an iterator from either list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab83d70fc2de9b51fc120ca6796faef4d"></a><!-- doxytag: member="rdr.c::new_iterator" ref="ab83d70fc2de9b51fc120ca6796faef4d" args="(int32 flags)" -->
<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#ab83d70fc2de9b51fc120ca6796faef4d">new_iterator</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new iterator and add it to the list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2d1d5343b3c44344c615df5f387b50"></a><!-- doxytag: member="rdr.c::unlock_previous_rdr" ref="a8d2d1d5343b3c44344c615df5f387b50" args="(sw_rdr_iterator *iterator)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a8d2d1d5343b3c44344c615df5f387b50">unlock_previous_rdr</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a previously locked RDR. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga4864d63f49b5705aff5890fdc5bad0f8">found</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the iterator.  <a href="group__swrdr.html#ga4864d63f49b5705aff5890fdc5bad0f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga097af3d11f3b06fe7414f851ecccb969">find</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a specific RDR by Class, Type and ID - the usual case.  <a href="group__swrdr.html#ga097af3d11f3b06fe7414f851ecccb969"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gab56f3b0b58c1f18187baffa2e622c657">restart</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart an iteration of RDRs.  <a href="group__swrdr.html#gab56f3b0b58c1f18187baffa2e622c657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga1b46698fb0982ba9c74f97b91fdda532">find_type</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an iteration of RDRs by Class and Type.  <a href="group__swrdr.html#ga1b46698fb0982ba9c74f97b91fdda532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga4445c17e5db250734ccd119357a618d5">find_class</a> (sw_rdr_class rdrclass)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an iteration of RDRs by Class.  <a href="group__swrdr.html#ga4445c17e5db250734ccd119357a618d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga9005f95b58d2910470fea7c3088bc934">find_all</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an iteration of all RDRs (the highest priority of each).  <a href="group__swrdr.html#ga9005f95b58d2910470fea7c3088bc934"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sw_rdr_result HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#aca28260565b66443cf243072ff9d8cbe">find_next_rdr</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, sw_rdr_class *pclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *ptype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *pid, void **pptr, size_t *plength, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find and optionally lock an RDR from an iterator.  <a href="#aca28260565b66443cf243072ff9d8cbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gae0c0bd41ca1143e6637f5777c0af07bd">next</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, sw_rdr_class *pclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *ptype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *pid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an RDR from an iterator.  <a href="group__swrdr.html#gae0c0bd41ca1143e6637f5777c0af07bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga9ae38da88691ea7bfadf4223ba66b70b">lock_next</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, sw_rdr_class *pclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *ptype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *pid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find and lock an RDR from an iterator.  <a href="group__swrdr.html#ga9ae38da88691ea7bfadf4223ba66b70b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a57ec7c3b2a59893a79bb54de87097"></a><!-- doxytag: member="rdr.c::new_rdr" ref="a05a57ec7c3b2a59893a79bb54de87097" args="(sw_rdr *rdr, sw_rdr_class rdrclass, sw_rdr_type rdrtype, sw_rdr_id rdrid, void *ptr, size_t length, sw_rdr_priority priority)" -->
static <a class="el" href="structsw__rdr.html">sw_rdr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdr_8c.html#a05a57ec7c3b2a59893a79bb54de87097">new_rdr</a> (<a class="el" href="structsw__rdr.html">sw_rdr</a> *rdr, sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void *ptr, size_t length, <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialise a new <a class="el" href="structsw__rdr.html" title="Our internal representation of an RDR registration.">sw_rdr</a> structure, but don't add it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gaf0b144b0c1679c5ae1334e9d21324213">register_rdr</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void *ptr, size_t length, <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register or reregister an RDR.  <a href="group__swrdr.html#gaf0b144b0c1679c5ae1334e9d21324213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga095af8ac15cf4e562b0ccbca7f4ef1ca">register_id</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *prdrid, void *ptr, size_t length, <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an RDR allocating a unique ID.  <a href="group__swrdr.html#ga095af8ac15cf4e562b0ccbca7f4ef1ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gad89ea97c90729eba6c5e1367b11cb006">deregister</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void *ptr, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister an RDR.  <a href="group__swrdr.html#gad89ea97c90729eba6c5e1367b11cb006"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file provides the ROM Data Resource API. </p>
<dl class="rcs"><dt><b>HopeName</b></dt><dd>SWrdr!src:<a class="el" href="rdr_8c.html" title="This file provides the ROM Data Resource API.">rdr.c</a>(EBDSDK_P.1) </dd></dl>
<p>Copyright (C) 2009-2013 Global Graphics Software Ltd. All rights reserved. This source code contains the confidential and trade secret information of Global Graphics Software Ltd. It may not be used, copied or distributed for any reason except as set forth in the applicable Global Graphics license agreement.</p>
<p>The RDR API is primarily used to share blocks of data between the skin and core, or in general, between multiple Providers and Consumers. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aca28260565b66443cf243072ff9d8cbe"></a><!-- doxytag: member="rdr.c::find_next_rdr" ref="aca28260565b66443cf243072ff9d8cbe" args="(sw_rdr_iterator *iterator, sw_rdr_class *pclass, sw_rdr_type *ptype, sw_rdr_id *pid, void **pptr, size_t *plength, HqBool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sw_rdr_result HQNCALL find_next_rdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw_rdr_class *&nbsp;</td>
          <td class="paramname"> <em>pclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *&nbsp;</td>
          <td class="paramname"> <em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>plength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find and optionally lock an RDR from an iterator. </p>
<p>This is an internal call but is marked HQNCALL in case that makes it easier to optimise the tail-calls in SwNextRDR() and SwLockNextRDR() below. </p>

</div>
</div>
<a class="anchor" id="a7bef74e62e0dc0fa70d3064d034ff8cb"></a><!-- doxytag: member="rdr.c::find_rdr" ref="a7bef74e62e0dc0fa70d3064d034ff8cb" args="(sw_rdr_iterator *find, int unlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__rdr.html">sw_rdr</a>* find_rdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>unlock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an rdr from an iterator structure. </p>
<p>This is the central find routine used by all API find and iterate calls, and used internally by the (de)registration calls.</p>
<p>As well as finding the first matching RDR for a particular set of criteria, it returns the parent of the returned RDR (or the last in the list), and the next RDR to check (for continuing the search).</p>
<p>Note that when multithreading this function MUST be protected by mutex on entry. It can optionally unlock the mutex during the search.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>find</em>&nbsp;</td><td>The iterator to use and update. When multithreading, access to iterators MUST be protected by mutex.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unlock</em>&nbsp;</td><td>TRUE if called with a mutex that is to be unlocked during the iteration. The concurrency count is incremented and the mutex unlocked, then locked and decremented on exit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The RDR found, or NULL. Note that when multithreading the RDR found by find_rdr could nevertheless be deregistered before this function has returned so must be protected against by the caller using mutex. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d073b3ea1397e2e051147c04b3a4d22"></a><!-- doxytag: member="rdr.c::move_iterator" ref="a5d073b3ea1397e2e051147c04b3a4d22" args="(sw_rdr_iterator *find, sw_rdr_iterator **from, sw_rdr_iterator **to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> **&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> **&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find an iterator in one list and if found move it to another. This MUST be protected by a mutex. </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
