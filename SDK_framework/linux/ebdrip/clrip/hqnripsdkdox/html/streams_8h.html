<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: streams.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_30ea0f072a45d4235daf97fe839164a5.html">export</a>
  </div>
</div>
<div class="contents">
<h1>streams.h File Reference</h1>
<p>A simple streaming abstraction to handle RIP I/O when using the Reference API.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="std_8h.html">std.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripcall_8h.html">ripcall.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__HqnReadStream.html">_HqnReadStream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the functions required to implement an input stream.  <a href="struct__HqnReadStream.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__HqnWriteStream.html">_HqnWriteStream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the functions required to implement an output stream.  <a href="struct__HqnWriteStream.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__PTHandler.html">_PTHandler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets.  <a href="struct__PTHandler.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSContentTypeEntry.html">_XPSContentTypeEntry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the mapping between a single XPS document part and its corresponding content type.  <a href="struct__XPSContentTypeEntry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSContentTypeMap.html">_XPSContentTypeMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a bounded array of content type mappings.  <a href="struct__XPSContentTypeMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSPageDescription.html">_XPSPageDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a single page within an XPS package.  <a href="struct__XPSPageDescription.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSDocumentDescription.html">_XPSDocumentDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a single document within an XPS package.  <a href="struct__XPSDocumentDescription.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSPackageDescription.html">_XPSPackageDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a complete XPS package, whose individual part streams are managed outside of the RIP.  <a href="struct__XPSPackageDescription.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__XPSPackageStreamManager.html">_XPSPackageStreamManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines the function protocols for opening and closing individual XPS part streams, along with the client data pointer that should be passed to each function.  <a href="struct__XPSPackageStreamManager.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#ae0d49968702cf60da87d98af442bb139">StreamCloseFn</a> )(void *pPrivate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the RIP to close the stream. The implementation may perform any cleanup actions that are required by the underlying streaming protocol.  <a href="#ae0d49968702cf60da87d98af442bb139"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a4b72ad00b54c0bc9450742dc73aeee21">StreamBytesFn</a> )(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pBytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the bytes available or the total size of the stream.  <a href="#a4b72ad00b54c0bc9450742dc73aeee21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#acbc262da3ca92fb843fe750d62bc7b42">ReadStreamSeekFn</a> )(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pos, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a seek on the input stream.  <a href="#acbc262da3ca92fb843fe750d62bc7b42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a89a2a716a6c264ee231c9c42452e25e5">ReadStreamReadFn</a> )(void *pPrivate, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbRequested)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some bytes from the input stream.  <a href="#a89a2a716a6c264ee231c9c42452e25e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a048cd5f4ea49994acc25392ca28f38bc">WriteStreamSeekFn</a> )(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pPos, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a seek on the output stream.  <a href="#a048cd5f4ea49994acc25392ca28f38bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a3575c77465bc50414d725facf9b4f237">WriteStreamWriteFn</a> )(void *pPrivate, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbAvailable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some bytes to the output stream.  <a href="#a3575c77465bc50414d725facf9b4f237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0649a77b80a198b1205a9ed525b957f5"></a><!-- doxytag: member="streams.h::HqnReadStream" ref="a0649a77b80a198b1205a9ed525b957f5" args="" -->
typedef struct <a class="el" href="struct__HqnReadStream.html">_HqnReadStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a0649a77b80a198b1205a9ed525b957f5">HqnReadStream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the functions required to implement an input stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdcad78f0c5703c18b94530e6c6814e4"></a><!-- doxytag: member="streams.h::HqnWriteStream" ref="afdcad78f0c5703c18b94530e6c6814e4" args="" -->
typedef struct <a class="el" href="struct__HqnWriteStream.html">_HqnWriteStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#afdcad78f0c5703c18b94530e6c6814e4">HqnWriteStream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the functions required to implement an output stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct__HqnWriteStream.html">HqnWriteStream</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#aa53e2532d3c200f3695e2d25b5232ebd">PTHandlerOpenDeltaFn</a> )(void *pPrivate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a stream into which a new Print Ticket part can be written.  <a href="#aa53e2532d3c200f3695e2d25b5232ebd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#ae3292117ea264b3b8ebcab164f469698">PTHandlerMergeDeltaFn</a> )(void *pPrivate, <a class="el" href="struct__HqnWriteStream.html">HqnWriteStream</a> *pDelta, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nLevel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge a print ticket delta with the current.  <a href="#ae3292117ea264b3b8ebcab164f469698"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a083304be580ed6714f409b445b1c7ea2">PTHandlerProgressCallbackFn</a> )(void *pPrivate, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nLevel, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fEntered)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal XPS progress information.  <a href="#a083304be580ed6714f409b445b1c7ea2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#ae0fd2b82f134f5d274ab59927c808416">PTHandlerGetDigitalSignatureStatusFn</a> )(void *pPrivate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the digital signing status of the current job.  <a href="#ae0fd2b82f134f5d274ab59927c808416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__PTHandler.html">_PTHandler</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#aa8f071f425f429258b1e56f8776eba9b">PTHandler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure encapsulates the protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets.  <a href="#aa8f071f425f429258b1e56f8776eba9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__XPSContentTypeEntry.html">_XPSContentTypeEntry</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#af18e82c01bf6c12dc6b18f361301a045">XPSContentTypeEntry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates the mapping between a single XPS document part and its corresponding content type.  <a href="#af18e82c01bf6c12dc6b18f361301a045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__XPSContentTypeMap.html">_XPSContentTypeMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a8e09d4af75921e800455a7d562d11729">XPSContentTypeMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a bounded array of content type mappings.  <a href="#a8e09d4af75921e800455a7d562d11729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0417207a12e6ea04579148623d8f08d5"></a><!-- doxytag: member="streams.h::XPSPageDescription" ref="a0417207a12e6ea04579148623d8f08d5" args="" -->
typedef struct <a class="el" href="struct__XPSPageDescription.html">_XPSPageDescription</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a0417207a12e6ea04579148623d8f08d5">XPSPageDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a single page within an XPS package. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73a1bff8335c976f1042f42397772756"></a><!-- doxytag: member="streams.h::XPSDocumentDescription" ref="a73a1bff8335c976f1042f42397772756" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__XPSDocumentDescription.html">_XPSDocumentDescription</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a73a1bff8335c976f1042f42397772756">XPSDocumentDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a single document within an XPS package. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__XPSPackageDescription.html">_XPSPackageDescription</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a5874d356acaf906db3495fae05234e38">XPSPackageDescription</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a complete XPS package, whose individual part streams are managed outside of the RIP.  <a href="#a5874d356acaf906db3495fae05234e38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#ad723adb3ef2667a23cc5145fa7a6024d">OpenResourceStreamFn</a> )(void *pPrivate, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> iDocument, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> iPage, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> resourceType, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszUri, <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a> **pStream)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function called by the RIP to open a stream on a specified resource within the context of an XPS package.  <a href="#ad723adb3ef2667a23cc5145fa7a6024d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a97d7f3dba2dc4ef829bf71438e8eff18">CloseResourceStreamFn</a> )(void *pPrivate, <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a> *pStream)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function called by the RIP to close a stream on an XPS package resource.  <a href="#a97d7f3dba2dc4ef829bf71438e8eff18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10ff454f078fa87142fe2b5651b8e10e"></a><!-- doxytag: member="streams.h::XPSPackageStreamManager" ref="a10ff454f078fa87142fe2b5651b8e10e" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__XPSPackageStreamManager.html">_XPSPackageStreamManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="streams_8h.html#a10ff454f078fa87142fe2b5651b8e10e">XPSPackageStreamManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines the function protocols for opening and closing individual XPS part streams, along with the client data pointer that should be passed to each function. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbbaddbeb34ad39d7cfc39337ab7e18ce0e6">ResourceType_Job_PT</a>, 
<a class="el" href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbba73adba4a2a31dc09cbf8d6e2f5065d08">ResourceType_Document_PT</a>, 
<a class="el" href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbbac093eae6d3e03283d41f5627a249953a">ResourceType_Page_PT</a>, 
<a class="el" href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbbaee43ae464238573568bcbf69c9f7a731">ResourceType_Page_Markup</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbbac09d8e8abfa835b28b25fb9c8a390e20">ResourceType_URI</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Classifies XPS package stream types. </p>
 <a href="streams_8h.html#a109bfaad92bd6d348dab484aec11edbb">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A simple streaming abstraction to handle RIP I/O when using the Reference API. </p>
<p>The Reference API permits jobs to be submitted as static files on disk, and for the output to be written to disk in various supported formats. However, it is also possible for the input and output to be handled via arbitrary streams, provided that those streams are implemented by the caller. This header file provides the signatures for such implementations.</p>
<p>To implement an input stream, the calling code must supply an implementation of <code>StreamCloseFn</code>, <code>StreamBytesFn</code>, <code>ReadStreamSeekFn</code> and <code>ReadStreamReadFn</code>. The seeking function must be implemented, although it is permitted to return an error in cases where random access is not supported. These four implementations must be packaged into a <code>HqnReadStream</code> object structure, also defined in this file.</p>
<p>To implement an output stream, the calling code must supply an implementation of <code>StreamCloseFn</code>, <code>StreamBytesFn</code>, <code>WriteStreamSeekFn</code> and <code>WriteStreamWriteFn</code>. These are then packaged into a <code>HqnWriteStream</code> structure.</p>
<p>A stream is <em>per-job</em>. There is no call to open a stream, or to reset it, either for input or output. A close call is provided in case the implementation needs to perform cleanup actions at the end of a job.</p>
<p>For further information about the use of <code>HqnReadStream</code> and <code>HqnWriteStream</code>, please refer to the documentation for the refimpl Reference API. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a97d7f3dba2dc4ef829bf71438e8eff18"></a><!-- doxytag: member="streams.h::CloseResourceStreamFn" ref="a97d7f3dba2dc4ef829bf71438e8eff18" args=")(void *pPrivate, HqnReadStream *pStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#a97d7f3dba2dc4ef829bf71438e8eff18">CloseResourceStreamFn</a>)(void *pPrivate, <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a> *pStream)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function called by the RIP to close a stream on an XPS package resource. </p>
<p>This function signature forms part of the <code>XPSPackageStreamManager</code> protocol, which allows the RIP to consume XPS from a virtual package, whose separate part streams are managed by the RIP's client.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>Pointer to arbitrary, client-managed data. The client stores this pointer as the <code>pPrivate</code> member of the <code>XPSPackageStreamManager</code> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pStream</em>&nbsp;</td><td>A stream that was previously opened by a call to <code>OpenResourceStreamFn</code> within the scope of the same <code>XPSPackageStreamManager</code>. The stream's own <code>Close()</code> function will already have been called by the RIP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="streams_8h.html#a5874d356acaf906db3495fae05234e38" title="Describes a complete XPS package, whose individual part streams are managed outside...">XPSPackageDescription</a> </dd>
<dd>
<a class="el" href="streams_8h.html#a10ff454f078fa87142fe2b5651b8e10e" title="Combines the function protocols for opening and closing individual XPS part streams...">XPSPackageStreamManager</a> </dd>
<dd>
<a class="el" href="streams_8h.html#ad723adb3ef2667a23cc5145fa7a6024d" title="Function called by the RIP to open a stream on a specified resource within the context...">OpenResourceStreamFn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad723adb3ef2667a23cc5145fa7a6024d"></a><!-- doxytag: member="streams.h::OpenResourceStreamFn" ref="ad723adb3ef2667a23cc5145fa7a6024d" args=")(void *pPrivate, uint32 iDocument, uint32 iPage, uint32 resourceType, uint8 *pszUri, HqnReadStream **pStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#ad723adb3ef2667a23cc5145fa7a6024d">OpenResourceStreamFn</a>)(void *pPrivate, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> iDocument, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> iPage, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> resourceType, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pszUri, <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a> **pStream)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function called by the RIP to open a stream on a specified resource within the context of an XPS package. </p>
<p>This function signature forms part of the <code>XPSPackageStreamManager</code> protocol, which allows the RIP to consume XPS from a virtual package, whose separate part streams are managed by the RIP's client.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>Pointer to arbitrary, client-managed data. The client stores this pointer as the <code>pPrivate</code> member of the <code>XPSPackageStreamManager</code> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iDocument</em>&nbsp;</td><td>Zero-based index indicating the document context. The number of documents in the package will have been described earlier by the caller using an <code>XPSPackageDescription</code> structure. This index will never exceed one less than the number of documents.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iPage</em>&nbsp;</td><td>Zero-based index indicating the page context, relative to the document context given by <code>iDocument</code>. The number of pages in the document will have been described earlier by the caller using an <code>XPSDocumentDescription</code> structure, nested within an <code>XPSPackageDescription</code>. This index will never exceed one less than the number of pages in the relevant document.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resourceType</em>&nbsp;</td><td>A member of the <code>ResourceType_*</code> enumeration.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pszUri</em>&nbsp;</td><td>When the resource type is <code>ResourceType_URI</code>, this argument is a pointer to a NUL-terminated string, which gives the part name of the resource that the RIP needs to read. This string should be treated in a <em>case-insensitive</em> fashion, and should be used to lookup the correct resource, in the context of the given document and page.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pStream</em>&nbsp;</td><td>If the function succeeds, this parameter receives a pointer to the <code>HqnReadStream</code>, from which the RIP can read the required data. The stream should be fully initialized, with the data pointer set at the beginning. If the function fails, this pointer should be set to <code>NULL</code>. The stream returned <em>must</em> support the <code>Seek()</code> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>TRUE</code> if the function succeeds, otherwise <code>FALSE</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="streams_8h.html#a5874d356acaf906db3495fae05234e38" title="Describes a complete XPS package, whose individual part streams are managed outside...">XPSPackageDescription</a> </dd>
<dd>
<a class="el" href="streams_8h.html#a10ff454f078fa87142fe2b5651b8e10e" title="Combines the function protocols for opening and closing individual XPS part streams...">XPSPackageStreamManager</a> </dd>
<dd>
<a class="el" href="streams_8h.html#a97d7f3dba2dc4ef829bf71438e8eff18" title="Function called by the RIP to close a stream on an XPS package resource.">CloseResourceStreamFn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa8f071f425f429258b1e56f8776eba9b"></a><!-- doxytag: member="streams.h::PTHandler" ref="aa8f071f425f429258b1e56f8776eba9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__PTHandler.html">_PTHandler</a>  <a class="el" href="struct__PTHandler.html">PTHandler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This structure encapsulates the protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets. </p>
<p>If the hosting application uses the Reference API to drive the RIP, it can pass a pointer to this structure through the <code>RunXPSJob()</code> entry point. </p>
<p>If pfProgressCallback is NULL then no progress callbacks will occur. </p>

</div>
</div>
<a class="anchor" id="ae0fd2b82f134f5d274ab59927c808416"></a><!-- doxytag: member="streams.h::PTHandlerGetDigitalSignatureStatusFn" ref="ae0fd2b82f134f5d274ab59927c808416" args=")(void *pPrivate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>( * <a class="el" href="streams_8h.html#ae0fd2b82f134f5d274ab59927c808416">PTHandlerGetDigitalSignatureStatusFn</a>)(void *pPrivate)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the digital signing status of the current job. </p>
<p>This function is part of a protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets. Digital signatures are not directly related to print tickets. However, it is a print ticket setting (<code>JobDigitalSignatureProcessing</code>) that dictates whether the signing status needs to be verified.</p>
<p>The RIP calls this function when it determines that the job needs a signature check. This will happen at most once per job. For performance reasons, digital signature checks are skipped unless the print ticket requires them. Also, checks are not performed via this protocol if they have already been performed prior to starting the job.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer of the <code>PTHandler</code> structure, of which this function is a part. This <em>must</em> be supplied to every call, in order for the implementation to access any internal state that it needs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of <code>XPSPT_DIGSIG_NOTCHECKED</code>, <code>XPSPT_DIGSIG_NOTSIGNED</code>, <code>XPSPT_DIGSIG_INVALID</code>, <code>XPSPT_DIGSIG_VALID</code>, <code>XPSPT_DIGSIG_ERROR</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3292117ea264b3b8ebcab164f469698"></a><!-- doxytag: member="streams.h::PTHandlerMergeDeltaFn" ref="ae3292117ea264b3b8ebcab164f469698" args=")(void *pPrivate, HqnWriteStream *pDelta, int32 nLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct__HqnReadStream.html">HqnReadStream</a>*( * <a class="el" href="streams_8h.html#ae3292117ea264b3b8ebcab164f469698">PTHandlerMergeDeltaFn</a>)(void *pPrivate, <a class="el" href="struct__HqnWriteStream.html">HqnWriteStream</a> *pDelta, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nLevel)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge a print ticket delta with the current. </p>
<p>This function is part of a protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer of the <code>PTHandler</code> structure, of which this function is a part. This <em>must</em> be supplied to every call, in order for the implementation to access any internal state that it needs.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDelta</em>&nbsp;</td><td>A stream that was previously obtained from a call to the <code>PTHandlerOpenDeltaFn</code>. The stream is expected to have been populated with the new print ticket XML fragment. If this function succeeds, it will close and dispose of the stream, and the caller should not use it again. It is legal for the stream to be empty. In this case, a degenerate merge will take place, returning the current effective print ticket unchanged.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLevel</em>&nbsp;</td><td>The scope level for the merged print ticket. This must be greater than or equal to <code>XPSPT_LEVEL_JOB</code>, but not greater than <code>XPSPT_LEVEL_PAGE</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa53e2532d3c200f3695e2d25b5232ebd"></a><!-- doxytag: member="streams.h::PTHandlerOpenDeltaFn" ref="aa53e2532d3c200f3695e2d25b5232ebd" args=")(void *pPrivate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct__HqnWriteStream.html">HqnWriteStream</a>*( * <a class="el" href="streams_8h.html#aa53e2532d3c200f3695e2d25b5232ebd">PTHandlerOpenDeltaFn</a>)(void *pPrivate)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain a stream into which a new Print Ticket part can be written. </p>
<p>This function is part of a protocol that allows the Harlequin RIP SDK to use an exterior component for handling print tickets. When a new print ticket XML part is discovered, this method can be used to transmit the XML text out to the hosting application.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer of the <code>PTHandler</code> structure, of which this function is a part. This <em>must</em> be supplied to every call, in order for the implementation to access any internal state that it needs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a083304be580ed6714f409b445b1c7ea2"></a><!-- doxytag: member="streams.h::PTHandlerProgressCallbackFn" ref="a083304be580ed6714f409b445b1c7ea2" args=")(void *pPrivate, int32 nLevel, int32 fEntered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * <a class="el" href="streams_8h.html#a083304be580ed6714f409b445b1c7ea2">PTHandlerProgressCallbackFn</a>)(void *pPrivate, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> nLevel, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> fEntered)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal XPS progress information. </p>
<p>This function is part of a protocol that allows the Harlequin RIP SDK to use an exterior component to monitor progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer of the <code>PTHandler</code> structure, of which this function is a part. This <em>must</em> be supplied to every call, in order for the implementation to access any internal state that it needs.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nLevel</em>&nbsp;</td><td>The XPS level at which processing is currently being performed. This must be greater than or equal to <code>XPSPT_LEVEL_JOB</code>, and not greater than <code>XPSPT_LEVEL_PAGE</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fEntered</em>&nbsp;</td><td><code>TRUE</code> if processing is beginning at the specified <code>nLevel</code>, <code>FALSE</code> if processing is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89a2a716a6c264ee231c9c42452e25e5"></a><!-- doxytag: member="streams.h::ReadStreamReadFn" ref="a89a2a716a6c264ee231c9c42452e25e5" args=")(void *pPrivate, uint8 *pBuffer, int32 cbRequested)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#a89a2a716a6c264ee231c9c42452e25e5">ReadStreamReadFn</a>)(void *pPrivate, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbRequested)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read some bytes from the input stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Pointer to a byte buffer, into which the stream implementation should copy the next chunk of input data. This buffer memory is managed by the RIP. The stream implementation should not attempt to free this memory, nor should it ever store away the pointer for later use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbRequested</em>&nbsp;</td><td>Maximum number of bytes that should be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value less than zero should be returned to indicate an IO error. If the read is successful, the function should return the actual number of bytes copied. </dd></dl>

</div>
</div>
<a class="anchor" id="acbc262da3ca92fb843fe750d62bc7b42"></a><!-- doxytag: member="streams.h::ReadStreamSeekFn" ref="acbc262da3ca92fb843fe750d62bc7b42" args=")(void *pPrivate, Hq32x2 *pos, int32 flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#acbc262da3ca92fb843fe750d62bc7b42">ReadStreamSeekFn</a>)(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pos, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flag)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a seek on the input stream. </p>
<p>If random access is not supported by the stream implementation, the RIP may still call this function as a way of obtaining the current value of the stream pointer. It does this by requesting a seek of zero, relative to the current file position.</p>
<p>A seek of zero relative to the end of the stream must be interpreted as a flush operation. For a seekable stream this will simply be a seek to the end of the stream. For a non-seekable stream it requires all pending input to be discarded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPos</em>&nbsp;</td><td>A signed 64-bit value indicating the target movement. The implementation should always update this value with the current stream pointer after performing the seek.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>One of <code>STREAM_POSITION_START</code>, <code>STREAM_POSITION_CURRENT</code> or <code>STREAM_POSITION_END</code>. The <code>pPos</code> argument is then interpreted as being relative to the start of the stream, relative to the current location, or relative to the end of the stream respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return a value of zero to indicate an error, a non-zero value to indicate success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b72ad00b54c0bc9450742dc73aeee21"></a><!-- doxytag: member="streams.h::StreamBytesFn" ref="a4b72ad00b54c0bc9450742dc73aeee21" args=")(void *pPrivate, Hq32x2 *pBytes, int32 reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#a4b72ad00b54c0bc9450742dc73aeee21">StreamBytesFn</a>)(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pBytes, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> reason)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the bytes available or the total size of the stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBytes</em>&nbsp;</td><td>A signed 64-bit value to be updated with the bytes available or total size as appropriate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Either <code>STREAM_BYTES_AVAILABLE</code> or <code>STREAM_BYTES_TOTAL</code> to indicate what <code>pBytes</code> should be set to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return a value of zero to indicate an error, a non-zero value to indicate success. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d49968702cf60da87d98af442bb139"></a><!-- doxytag: member="streams.h::StreamCloseFn" ref="ae0d49968702cf60da87d98af442bb139" args=")(void *pPrivate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#ae0d49968702cf60da87d98af442bb139">StreamCloseFn</a>)(void *pPrivate)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the RIP to close the stream. The implementation may perform any cleanup actions that are required by the underlying streaming protocol. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return a value less than zero to indicate an error in closing the stream, otherwise return zero. </dd></dl>

</div>
</div>
<a class="anchor" id="a048cd5f4ea49994acc25392ca28f38bc"></a><!-- doxytag: member="streams.h::WriteStreamSeekFn" ref="a048cd5f4ea49994acc25392ca28f38bc" args=")(void *pPrivate, Hq32x2 *pPos, int32 flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#a048cd5f4ea49994acc25392ca28f38bc">WriteStreamSeekFn</a>)(void *pPrivate, <a class="el" href="structHq32x2.html">Hq32x2</a> *pPos, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> flag)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a seek on the output stream. </p>
<p>If random access is not supported by the stream implementation, the RIP may still call this function as a way of obtaining the current value of the stream pointer. It does this by requesting a seek of zero, relative to the current file position.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pPos</em>&nbsp;</td><td>A signed 64-bit value indicating the target movement. The implementation should always update this value with the current stream pointer after performing the seek.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>One of <code>STREAM_POSITION_START</code>, <code>STREAM_POSITION_CURRENT</code> or <code>STREAM_POSITION_END</code>. The <code>pPos</code> argument is then interpreted as being relative to the start of the stream, relative to the current location, or relative to the end of the stream respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return a value of zero to indicate an error, a non-zero value to indicate success. </dd></dl>

</div>
</div>
<a class="anchor" id="a3575c77465bc50414d725facf9b4f237"></a><!-- doxytag: member="streams.h::WriteStreamWriteFn" ref="a3575c77465bc50414d725facf9b4f237" args=")(void *pPrivate, uint8 *pBuffer, int32 cbAvailable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>( * <a class="el" href="streams_8h.html#a3575c77465bc50414d725facf9b4f237">WriteStreamWriteFn</a>)(void *pPrivate, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *pBuffer, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> cbAvailable)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write some bytes to the output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pPrivate</em>&nbsp;</td><td>The private data pointer from the stream structure. This must be supplied to every function call made on the stream, in order for the implementation to access any internal state that it needs to store.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Pointer to a byte buffer, from which the stream implementation should copy the next chunk of output data. This buffer memory is managed by the RIP. The stream implementation should not attempt to free this memory, nor should it ever store away the pointer for later use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbAvailable</em>&nbsp;</td><td>Maximum number of bytes that should be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value less than zero should be returned to indicate an IO error. If the read is successful, the function should return the actual number of bytes written. </dd></dl>

</div>
</div>
<a class="anchor" id="af18e82c01bf6c12dc6b18f361301a045"></a><!-- doxytag: member="streams.h::XPSContentTypeEntry" ref="af18e82c01bf6c12dc6b18f361301a045" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__XPSContentTypeEntry.html">_XPSContentTypeEntry</a>  <a class="el" href="struct__XPSContentTypeEntry.html">XPSContentTypeEntry</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates the mapping between a single XPS document part and its corresponding content type. </p>
<p>This structure is analogous to a single <b>&lt;Override&amp;gt</b> element in the <code>[Content_Types].xml</code> file of an XPS package. It maps a part name URI, such as <code>"/Documents/1/Resources/Fonts/Times.ttf"</code> onto its content type, such as <code>"application/vnd.ms-opentype"</code>. </p>

</div>
</div>
<a class="anchor" id="a8e09d4af75921e800455a7d562d11729"></a><!-- doxytag: member="streams.h::XPSContentTypeMap" ref="a8e09d4af75921e800455a7d562d11729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__XPSContentTypeMap.html">_XPSContentTypeMap</a>  <a class="el" href="struct__XPSContentTypeMap.html">XPSContentTypeMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes a bounded array of content type mappings. </p>
<p>An <code>XPSContentTypeMap</code> is required as part of the description of a single page within an XPS package. The map must have an entry for every resource that is known to be used by that page. </p>

</div>
</div>
<a class="anchor" id="a5874d356acaf906db3495fae05234e38"></a><!-- doxytag: member="streams.h::XPSPackageDescription" ref="a5874d356acaf906db3495fae05234e38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__XPSPackageDescription.html">_XPSPackageDescription</a>  <a class="el" href="struct__XPSPackageDescription.html">XPSPackageDescription</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes a complete XPS package, whose individual part streams are managed outside of the RIP. </p>
<p>The RIP has the ability to render XPS files from "virtual" packages, without needing them to be contained within a physical ZIP file. The <code>XPSPackageDescription</code> and <code>XPSPackageStreamManager</code> structures allow the RIP client to describe the contents of an XPS package abstractly, and then to provide streams on individual package parts as and when the RIP needs to read them.</p>
<p>This structure, along with those nested beneath it, is responsible for describing the overall <code>shape</code> of the package: the number of documents in the package, the number of pages in each document, the content types of the resources used by each page. None of the actual package <em>contents</em> are contained within this structure: there are no pointers to XML markup strings, nor to any image or font data. Instead, the package description can be seen as an implicit declaration that a certain number of <code>part streams</code> exist, and are known to the client. Given this declaration, the RIP can process the package, as long as it also has a means of opening each part stream on demand. This facility is provided by the <code>XPSPackageStreamManager</code>.</p>
<p>Suppose that we have a single-page XPS package. The page markup is known to reference a font resource whose URI is <code>"/Documents/1/Resources/Fonts/Times.ttf"</code>. The package has a job-level print ticket, but no document or page-level print tickets. This example package could be described to the RIP using the following sequence of declarations:</p>
<div class="fragment"><pre class="fragment">
  static XPSContentTypeEntry ctEntries[] =
  {
    { "/Documents/1/Resources/Fonts/Times.ttf", "application/vnd.ms-opentype" }
  };
 
  static XPSContentTypeMap ctMap = { 1, ctEntries };
 
  static XPSPageDescription pages[] = { { FALSE, &amp;ctMap } };
 
  static XPSDocumentDescription docs[] = { { FALSE, 1, pages } };
 
  static XPSPackageDescription package = { TRUE, 1, docs };
  </pre></div><p>If the caller were to describe this package to the RIP, it would also need to be prepared to provide <code>HqnReadStream</code>s for: the job-level print ticket, the page markup, and the font resource whose URI is <code>"/Documents/1/Resources/Fonts/Times.ttf"</code>. As long as the RIP can read from these three external streams, it can interpret and render the complete package.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="streams_8h.html#a10ff454f078fa87142fe2b5651b8e10e" title="Combines the function protocols for opening and closing individual XPS part streams...">XPSPackageStreamManager</a> </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a109bfaad92bd6d348dab484aec11edbb"></a><!-- doxytag: member="streams.h::@69" ref="a109bfaad92bd6d348dab484aec11edbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Classifies XPS package stream types. </p>
<p>When the RIP renders an XPS document whose part streams are managed by the caller, the <code>XPSPackageStreamManager</code> protocol is used by the RIP to open streams on the individual package parts. For arbitrary resources (such as fonts or images), the RIP addresses the stream using the original URI of the part, as described by the caller in the <code>XPSPackageDescription</code>. For more specific streams, such as page markup and print tickets, the part is addressed solely by its overall type and its context within the package. (The "context" is the page number within the document, and the document number within the package). This avoids the RIP needing to make any assumptions about the URIs for parts that were not explicitly declared. For instance, the markup for page 5 of document 1 would <em>usually</em> be <code>"/Documents/1/Pages/5.fpage"</code>, but it could just as easily be something quite different. Rather than opening the markup using this URI, the RIP can open the markup by using <code>ResourceType_Page_Markup</code>, and then just specifying the document number and page number as integers. The RIP client can interpret these according to its own URI-allocation scheme.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="streams_8h.html#ad723adb3ef2667a23cc5145fa7a6024d" title="Function called by the RIP to open a stream on a specified resource within the context...">OpenResourceStreamFn</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a109bfaad92bd6d348dab484aec11edbbaddbeb34ad39d7cfc39337ab7e18ce0e6"></a><!-- doxytag: member="ResourceType_Job_PT" ref="a109bfaad92bd6d348dab484aec11edbbaddbeb34ad39d7cfc39337ab7e18ce0e6" args="" -->ResourceType_Job_PT</em>&nbsp;</td><td>
<p>The job-level print ticket stream. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a109bfaad92bd6d348dab484aec11edbba73adba4a2a31dc09cbf8d6e2f5065d08"></a><!-- doxytag: member="ResourceType_Document_PT" ref="a109bfaad92bd6d348dab484aec11edbba73adba4a2a31dc09cbf8d6e2f5065d08" args="" -->ResourceType_Document_PT</em>&nbsp;</td><td>
<p>The document-level print ticket stream. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a109bfaad92bd6d348dab484aec11edbbac093eae6d3e03283d41f5627a249953a"></a><!-- doxytag: member="ResourceType_Page_PT" ref="a109bfaad92bd6d348dab484aec11edbbac093eae6d3e03283d41f5627a249953a" args="" -->ResourceType_Page_PT</em>&nbsp;</td><td>
<p>The page-level print ticket stream. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a109bfaad92bd6d348dab484aec11edbbaee43ae464238573568bcbf69c9f7a731"></a><!-- doxytag: member="ResourceType_Page_Markup" ref="a109bfaad92bd6d348dab484aec11edbbaee43ae464238573568bcbf69c9f7a731" args="" -->ResourceType_Page_Markup</em>&nbsp;</td><td>
<p>The XML markup for a specific page. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a109bfaad92bd6d348dab484aec11edbbac09d8e8abfa835b28b25fb9c8a390e20"></a><!-- doxytag: member="ResourceType_URI" ref="a109bfaad92bd6d348dab484aec11edbbac09d8e8abfa835b28b25fb9c8a390e20" args="" -->ResourceType_URI</em>&nbsp;</td><td>
<p>An arbitrary package resource. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
