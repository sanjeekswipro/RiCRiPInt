<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sw_pfin_api Struct Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sw_pfin_api Struct Reference<br/>
<small>
[<a class="el" href="group__swpfinapi.html">Pluggable Font API</a>]</small>
</h1><!-- doxytag: class="sw_pfin_api" -->
<p>The definition of an implementation of the PFIN interface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;swpfinapi.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__api__info.html">sw_api_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#a1219b61eb4767ee6f217182e9360aa6f">init</a> )(<a class="el" href="structsw__pfin__api.html">sw_pfin_api</a> *impl, const <a class="el" href="structsw__pfin__init__params.html">sw_pfin_init_params</a> *params)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise any implementation-specific data.  <a href="#a1219b61eb4767ee6f217182e9360aa6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#a95a513f076a9163f276d39f8ae9ef8e0">finish</a> )(<a class="el" href="structsw__pfin__api.html">sw_pfin_api</a> *impl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called when the RIP is shutting down, after all calls to the implementation or its instances.  <a href="#a95a513f076a9163f276d39f8ae9ef8e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47">start</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, <a class="el" href="group__swpfinapi.html#ga08201091634c90c540bb8f6b2b18ea87">sw_pfin_reason</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start using an instance of the font module, and define fonts.  <a href="#afe3914d409f52346345e0eb469d64b47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e">stop</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, <a class="el" href="group__swpfinapi.html#ga08201091634c90c540bb8f6b2b18ea87">sw_pfin_reason</a> reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close down the font module, close files and undefine fonts.  <a href="#a316a46097d622324c9135c4ff822a34e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67">configure</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, const <a class="el" href="structsw__datum.html">sw_datum</a> *config)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This call allows the module to respond to changes in configuration.  <a href="#ab1141cf11d9c3399b28a3892b3fb2d67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#ad2c496b36098da70208291f02b8365ff">find</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, const <a class="el" href="structsw__datum.html">sw_datum</a> *fontname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A last-minute chance for the module to define required fonts.  <a href="#ad2c496b36098da70208291f02b8365ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#ae410c91e435c6b308ee261eca60dd020">metrics</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, const <a class="el" href="structsw__pfin__font.html">sw_pfin_font</a> *font, const <a class="el" href="structsw__datum.html">sw_datum</a> *glyph, double <a class="el" href="structsw__pfin__api.html#ae410c91e435c6b308ee261eca60dd020">metrics</a>[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the metrics for a given character and font.  <a href="#ae410c91e435c6b308ee261eca60dd020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#a37cc16609795d06e4b265e8053e08086">outline</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#gafcb365d52ee0761b31bebc215be34416">sw_pfin_outline_context</a> *context, const <a class="el" href="structsw__pfin__font.html">sw_pfin_font</a> *font, const <a class="el" href="structsw__datum.html">sw_datum</a> *glyph)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a representation of a given glyph.  <a href="#a37cc16609795d06e4b265e8053e08086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#a65be56d792c316f387915a62d846ed19">miscop</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, <a class="el" href="structsw__datum.html">sw_datum</a> **param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This call allows the module to perform implementation-specific operations, including communication with the PostScript environment.  <a href="#a65be56d792c316f387915a62d846ed19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__pfin__api.html#adb6756010e10b2d0f6fbb89a98bea5d7">raster</a> )(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin, <a class="el" href="structsw__datum.html">sw_datum</a> *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return raster data for a bitimage glyph.  <a href="#adb6756010e10b2d0f6fbb89a98bea5d7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The definition of an implementation of the PFIN interface. </p>
<p>PFIN guarantees to call <code><a class="el" href="structsw__pfin__api.html#a1219b61eb4767ee6f217182e9360aa6f" title="Initialise any implementation-specific data.">init()</a></code> before any other calls, and <code><a class="el" href="structsw__pfin__api.html#a95a513f076a9163f276d39f8ae9ef8e0" title="This method is called when the RIP is shutting down, after all calls to the implementation...">finish()</a></code> after all other calls. It may be that PFIN starts and stops the instance contextually, or the instance may be active for the lifetime of the RIP. This is not defined. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ab1141cf11d9c3399b28a3892b3fb2d67"></a><!-- doxytag: member="sw_pfin_api::configure" ref="ab1141cf11d9c3399b28a3892b3fb2d67" args=")(sw_pfin_instance *pfin, sw_pfin_define_context *define_context, const sw_datum *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67">configure</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context,const <a class="el" href="structsw__datum.html">sw_datum</a> *config)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This call allows the module to respond to changes in configuration. </p>
<p>This call is optional and may be NULL if the module has no configuration options.</p>
<p>Whenever setpfinparams is invoked, all active PFIN modules with a <code><a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67" title="This call allows the module to respond to changes in configuration.">configure()</a></code> entry will be called with the value of their configuration key. A module called "SynthFonts" will be called with the value of the /SynthFonts key in the dictionary supplied to setpfinparams. If this key is not present, the <code><a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67" title="This call allows the module to respond to changes in configuration.">configure()</a></code> method is not called.</p>
<p>The module may respond to its configuration by defining or undefining fonts through the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> and <a class="el" href="structsw__pfin__callback__api.html#aef7e22de745e0279287bd04f026518b0" title="Undefine a previously-defined module-supplied Font or CIDFont.">sw_pfin_callback_api::undefine()</a> PFIN callback api calls.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>define_context</em>&nbsp;</td><td>A context allowing the module to call the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> and <a class="el" href="structsw__pfin__callback__api.html#aef7e22de745e0279287bd04f026518b0" title="Undefine a previously-defined module-supplied Font or CIDFont.">sw_pfin_callback_api::undefine()</a> methods.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>The configuration datum. This is expected to be a dictionary, but modules should rigorously check the type of the datum since this is a user-configurable parameter. Attempting to match or extract values from non-dictionary parameters using the <a class="el" href="structsw__data__api.html" title="A structure containing callback functions for structured data access.">sw_data_api</a> methods will return appropriate errors, so the module can rely on checking the error return values from those calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Any errors in configuration can be rejected by returning SW_PFIN_ERROR_INVALID, otherwise SW_PFIN_SUCCESS denotes a lack of error. Modules are encouraged to be as forgiving and adaptive as possible with user-generated configuration. Nonsensical configuration should be ignored or defaulted, with a warning if necessary, rather than automatically generating an error.</dd></dl>
<p>For example, if a configuration file contains "/SynthFonts mark" then a datum of type SW_DATUM_TYPE_INVALID will be delivered to the SynthFonts module, and it should act as it sees fit. </p>

</div>
</div>
<a class="anchor" id="ad2c496b36098da70208291f02b8365ff"></a><!-- doxytag: member="sw_pfin_api::find" ref="ad2c496b36098da70208291f02b8365ff" args=")(sw_pfin_instance *pfin, sw_pfin_define_context *define_context, const sw_datum *fontname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#ad2c496b36098da70208291f02b8365ff">find</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context,const <a class="el" href="structsw__datum.html">sw_datum</a> *fontname)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A last-minute chance for the module to define required fonts. </p>
<p>This call is optional and should be NULL if the module defines all its fonts during <code><a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47" title="Start using an instance of the font module, and define fonts.">start()</a></code> or <code><a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67" title="This call allows the module to respond to changes in configuration.">configure()</a></code> calls.</p>
<p>If a /Font or /CIDFont findresource call was unable to find the required resource (or if resourceforall is about to be executed), all PFIN modules are called with the name of the missing resource (or a null datum) at which point a module may choose to define the missing font (or all fonts it can supply) by calling <code>define()</code>.</p>
<p>In the case of findresource, if any module does call <code>define()</code> then the findresource will be tried again. If that still fails, the appropriate error is generated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN context.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>define_context</em>&nbsp;</td><td>A context allowing PFIN to call the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> method.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fontname</em>&nbsp;</td><td>If this is a null datum then a resourceforall is about to occur, so the module should define all fonts it had not already defined. Otherwise fontname is a string datum containing a font (or CIDFont) name, and the module should try to define just that one font, if it can.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The module should return SW_PFIN_SUCCESS whether it can supply the missing font or not. PFIN detects the module's ability to supply the missing font by the fact the module called define. Returning SW_PFIN_ERROR_MEMORY may allow PFIN to free memory and try again, but will not have any other adverse effect. Returning any other error will cause the findresource or resourceforall to fail, and may cause the module to be shut down. </dd></dl>

</div>
</div>
<a class="anchor" id="a95a513f076a9163f276d39f8ae9ef8e0"></a><!-- doxytag: member="sw_pfin_api::finish" ref="a95a513f076a9163f276d39f8ae9ef8e0" args=")(sw_pfin_api *impl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__pfin__api.html#a95a513f076a9163f276d39f8ae9ef8e0">finish</a>)(<a class="el" href="structsw__pfin__api.html">sw_pfin_api</a> *impl)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called when the RIP is shutting down, after all calls to the implementation or its instances. </p>
<p>The module instances should not access any data owned by the RIP after this call, nor should they call any implementation or RIP callback API methods after this call. This method is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>impl</em>&nbsp;</td><td>A registered PFIN implementation to finalise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab716503b26170e15c9990c190bd2e175"></a><!-- doxytag: member="sw_pfin_api::info" ref="ab716503b26170e15c9990c190bd2e175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__api__info.html">sw_api_info</a> <a class="el" href="structsw__pfin__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Version number, name, display name, instance size. </p>

</div>
</div>
<a class="anchor" id="a1219b61eb4767ee6f217182e9360aa6f"></a><!-- doxytag: member="sw_pfin_api::init" ref="a1219b61eb4767ee6f217182e9360aa6f" args=")(sw_pfin_api *impl, const sw_pfin_init_params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__pfin__api.html#a1219b61eb4767ee6f217182e9360aa6f">init</a>)(<a class="el" href="structsw__pfin__api.html">sw_pfin_api</a> *impl,const <a class="el" href="structsw__pfin__init__params.html">sw_pfin_init_params</a> *params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise any implementation-specific data. </p>
<p>This method is called when the RIP is booted up. It will be the first call that the implementation receives.</p>
<p>This call is optional (indicated by NULL).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>impl</em>&nbsp;</td><td>The registered PFIN implementation to be initialised.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>A structure containing callback APIs and parameters valid for the lifetime of the module. Any parameters that the implementation needs access to should be copied out of this structure into private storage for the registered implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>Success, indicating that the implementation is fully initialised.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>Failure to initialise the implementation. If this is returned, the implementation will not be finalised, and the RIP will terminate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae410c91e435c6b308ee261eca60dd020"></a><!-- doxytag: member="sw_pfin_api::metrics" ref="ae410c91e435c6b308ee261eca60dd020" args=")(sw_pfin_instance *pfin, const sw_pfin_font *font, const sw_datum *glyph, double metrics[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#ae410c91e435c6b308ee261eca60dd020">metrics</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,const <a class="el" href="structsw__pfin__font.html">sw_pfin_font</a> *font,const <a class="el" href="structsw__datum.html">sw_datum</a> *glyph,double <a class="el" href="structsw__pfin__api.html#ae410c91e435c6b308ee261eca60dd020">metrics</a>[2])</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the metrics for a given character and font. </p>
<p>This call is mandatory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>font</em>&nbsp;</td><td>The PFIN font. This contains the font dictionary as a datum, and the size of a device pixel in glyph coordinates.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>glyph</em>&nbsp;</td><td>The required glyph. Depending on font type this will be delivered as an integer gid or a glyph name string.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>metrics</em>&nbsp;</td><td>The array into which to put the escapement vector of the glyph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The module should return SW_PFIN_ERROR_UNKNOWN if it is unable to find the glyph in the font. This may result in a notdef glyph being used. If the module believes the font to be broken in some way it must return SW_PFIN_ERROR_INVALID. This may result in PFIN passing the font to another module, or may result in an INVALIDFONT error. However, if the module is unable to handle the font due to support limitations, due to an unusual but not illegal font structure or unrecognised data representation, it should return SW_PFIN_ERROR_UNSUPPORTED. This will probably result in the font being passed to another module. Returning SW_PFIN_ERROR_MEMORY may allow PFIN to free memory and try again. If the metrics were succesfully found, SW_PFIN_SUCCESS must be returned.</dd></dl>
<p>It may be advantageous to cache glyph information at this point as a call to metrics will often be followed by a call to outline or raster. </p>

</div>
</div>
<a class="anchor" id="a65be56d792c316f387915a62d846ed19"></a><!-- doxytag: member="sw_pfin_api::miscop" ref="a65be56d792c316f387915a62d846ed19" args=")(sw_pfin_instance *pfin, sw_pfin_define_context *define_context, sw_datum **param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#a65be56d792c316f387915a62d846ed19">miscop</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context,<a class="el" href="structsw__datum.html">sw_datum</a> **param)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This call allows the module to perform implementation-specific operations, including communication with the PostScript environment. </p>
<p>This call is optional.</p>
<p>This can be invoked through the PostScript operator pfinop, with the syntax:</p>
<div class="fragment"><pre class="fragment">        /ModuleName &lt;single parameter&gt; pfinop -&gt; &lt;optional result&gt;
</pre></div><p>It is expected that the parameter will usually be an array or dictionary. The result optionally returned by the module can be of any form, though booleans and arrays will be useful.</p>
<p>The module may respond to the operation by defining or undefining fonts through the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> and <a class="el" href="structsw__pfin__callback__api.html#aef7e22de745e0279287bd04f026518b0" title="Undefine a previously-defined module-supplied Font or CIDFont.">sw_pfin_callback_api::undefine()</a> PFIN callback api calls, though this isn't its primary purpose.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>define_context</em>&nbsp;</td><td>A context allowing the module to call the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> and <a class="el" href="structsw__pfin__callback__api.html#aef7e22de745e0279287bd04f026518b0" title="Undefine a previously-defined module-supplied Font or CIDFont.">sw_pfin_callback_api::undefine()</a> methods.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>param</em>&nbsp;</td><td>A pointer to the pfinop parameter. This pointer should be updated by the module if it wants to return a result - leaving it unchanged is equivalent to setting it to null, resulting in pfinop leaving nothing on the stack.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that any <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> pointed to by params must continue to exist, so do not use a local <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> on the C stack - a <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> in the module's workspace or a static is necessary. Complex results such as arrays, if not static, will have to be allocated as required and must be discarded or reused at the next <a class="el" href="structsw__pfin__api.html#a65be56d792c316f387915a62d846ed19" title="This call allows the module to perform implementation-specific operations, including...">miscop()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the module does not understand or cannot process the request, an error of SW_PFIN_ERROR_UNSUPPORTED or SW_PFIN_ERROR_SYNTAX should be returned as appropriate, otherwise SW_PFIN_SUCCESS denotes success, and the result param will be passed back to the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a37cc16609795d06e4b265e8053e08086"></a><!-- doxytag: member="sw_pfin_api::outline" ref="a37cc16609795d06e4b265e8053e08086" args=")(sw_pfin_instance *pfin, sw_pfin_outline_context *context, const sw_pfin_font *font, const sw_datum *glyph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#a37cc16609795d06e4b265e8053e08086">outline</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#gafcb365d52ee0761b31bebc215be34416">sw_pfin_outline_context</a> *context,const <a class="el" href="structsw__pfin__font.html">sw_pfin_font</a> *font,const <a class="el" href="structsw__datum.html">sw_datum</a> *glyph)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a representation of a given glyph. </p>
<p>This call is mandatory.</p>
<p>From version 20080808 the module can choose to return a bitimaged or outline version of the glyph. Prior versions only support outlined glyphs, and this call's name still reflects that.</p>
<p>The module finds the glyph definition, scales and hints the outline appropriately, then delivers it through the <a class="el" href="structsw__pfin__callback__api.html" title="A structure containing callback functions for PFIN modules.">sw_pfin_callback_api</a> using the outline context supplied.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>A context allowing PFIN to call the <a class="el" href="structsw__pfin__callback__api.html#a6707c6006762294e67ab368d4cb409ff" title="Start a new contour, closing any previous contour.">sw_pfin_callback_api::move()</a>, <a class="el" href="structsw__pfin__callback__api.html#aee493337ce1a15a7b4e2ae36d36dbf2d" title="Add a straight line to the current contour.">sw_pfin_callback_api::line()</a>, and <a class="el" href="structsw__pfin__callback__api.html#ae0c0f2182dc095da184071b04aca4158" title="Add a bezier curve to the current contour.">sw_pfin_callback_api::curve()</a> methods or, from version 20080808, the <a class="el" href="structsw__pfin__callback__api.html#aeced142efa649d45071861407d67a7fc" title="Create a bitmapped glyph.">sw_pfin_callback_api::bitimage()</a> method.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>font</em>&nbsp;</td><td>The PFIN font. This contains the font dictionary as a datum, and the size of a device pixel in glyph coordinates. From version 20080808 this also contains the device resolution and a hint as to the preference for an outline or bitimage.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>glyph</em>&nbsp;</td><td>The required glyph. Depending on font type this will be delivered as an integer gid or a glyph name string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_PFIN_SUCCESS if the outline was delivered; SW_PFIN_ERROR_UNKNOWN if the glyph cannot be found; SW_PFIN_ERROR_MEMORY if there is a lack of memory; SW_PFIN_ERROR_UNSUPPORTED if the module cannot handle the font; SW_PFIN_ERROR_INVALID if the module believes the font to be broken.</dd></dl>
<p>If context-&gt;prefer == PFIN_OUTLINE_REQUIRED, then only move(), line() and curve() methods may be used, otherwise the module can opt instead for a single call to bitimage(). Modules are encouraged to pay attention to context-&gt;prefer </p>

</div>
</div>
<a class="anchor" id="adb6756010e10b2d0f6fbb89a98bea5d7"></a><!-- doxytag: member="sw_pfin_api::raster" ref="adb6756010e10b2d0f6fbb89a98bea5d7" args=")(sw_pfin_instance *pfin, sw_datum *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#adb6756010e10b2d0f6fbb89a98bea5d7">raster</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="structsw__datum.html">sw_datum</a> *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return raster data for a bitimage glyph. </p>
<p>This call is optional.</p>
<p>This is called if the module uses the bitimage() method in reponse to a request for a glyph (instead of building an outline) AND the bitimage isn't delivered whole at the time of that call.</p>
<p>Under those circumstances, PFIN will call back into the module from within the bitimage() call to retrieve raster data. It will be called repeatedly until it has returned enough data, or fails to return any (at which point the rest of the bitimage will be blank).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance. Note that the module can use this to pass information from the context of the <a class="el" href="structsw__pfin__api.html#a37cc16609795d06e4b265e8053e08086" title="Return a representation of a given glyph.">outline()</a> call.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A <a class="el" href="structsw__datum.html" title="Structured data instance type.">sw_datum</a> string to be updated by the module. The string will usually be zero length and have a null buffer pointer. The module should update the length and pointer fields in this case. However, PFIN may allocate a buffer into which the module may rasterise - see below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_PFIN_SUCCESS normally. Anything else will stop further raster callbacks occuring.</dd></dl>
<p>This callback is used by PFIN from within a bitimage() call if no buffer or insufficient data was supplied to that call.</p>
<p>It will usually be called with a zero-length data string, and the module must allocate a buffer and update the string datum accordingly. Note that any amount of data can be returned by this callback - it will be issued repeatedly until enough raster data has been returned, or the callback returns an empty string. The allocated buffer can be reused or discarded the next time control returns to the module - either at the next <a class="el" href="structsw__pfin__api.html#adb6756010e10b2d0f6fbb89a98bea5d7" title="Return raster data for a bitimage glyph.">raster()</a> call or on return from the surrounding bitimage() call. It is the module's responsibility to free such a buffer.</p>
<p>Under certain circumstances PFIN may preallocate a buffer, and the data string will then have a valid string pointer and a length. The module is encouraged to rasterise directly into this buffer. However, the module can just take the above approach in this case too, and override the string datum with its own buffer. If the module does this, and does not supply all the raster data immediately, further calls will occur as above (each with a null data string). Note that the module must never try to discard a buffer supplied by PFIN - to do so would generate an error.</p>
<p>Returning with an empty data string will blank the rest of the bitimage and cause no further <a class="el" href="structsw__pfin__api.html#adb6756010e10b2d0f6fbb89a98bea5d7" title="Return raster data for a bitimage glyph.">raster()</a> callbacks to occur for this bitimage. </p>

</div>
</div>
<a class="anchor" id="afe3914d409f52346345e0eb469d64b47"></a><!-- doxytag: member="sw_pfin_api::start" ref="afe3914d409f52346345e0eb469d64b47" args=")(sw_pfin_instance *pfin, sw_pfin_define_context *define_context, sw_pfin_reason reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47">start</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, <a class="el" href="group__swpfinapi.html#ga08201091634c90c540bb8f6b2b18ea87">sw_pfin_reason</a> reason)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start using an instance of the font module, and define fonts. </p>
<p>This call is optional (indicated by a null) but is expected to be present.</p>
<p>A module may choose not to define some or all of its fonts during <code><a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47" title="Start using an instance of the font module, and define fonts.">start()</a></code>; it may define fonts in response to an appropriate <code><a class="el" href="structsw__pfin__api.html#ab1141cf11d9c3399b28a3892b3fb2d67" title="This call allows the module to respond to changes in configuration.">configure()</a></code> call, or it may choose to defer definition until the last minute, via the <code><a class="el" href="structsw__pfin__api.html#ad2c496b36098da70208291f02b8365ff" title="A last-minute chance for the module to define required fonts.">find()</a></code> call. This may be preferable in systems where RIP booting speed is more crucial than findfont performance, and would suit modules that provide very many fonts, or whose mechanism for font discovery has performance implications.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>An instance of the <a class="el" href="structsw__pfin__instance.html" title="A structure containing the context of a PFIN module instance call.">sw_pfin_instance</a> structure to complete. The RIP will allocate a structure of the size presented in the implementation's sw_pfin_api::info.instance_size field, fill in the implementation and callback API pointers, and then pass it to this routine. If the module needs to allocate some workspace per-instance, it may sub-class the instance to allocate extra private workspace by initialising the implementation's sw_pfin_api::info.instance_size larger than the size of the <a class="el" href="structsw__pfin__instance.html" title="A structure containing the context of a PFIN module instance call.">sw_pfin_instance</a> structure, then downcasting the instance pointer in method calls.</td></tr>
  </table>
  </dd>
</dl>
<p>The PFIN instance contains the API implementation pointer and selected additional APIs which the module should use to call RIP methods.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>define_context</em>&nbsp;</td><td>A context allowing PFIN to call the <a class="el" href="structsw__pfin__callback__api.html#a9531bc6881e90f6760d7d1868757b067" title="Define a module-supplied Font or CIDFont.">sw_pfin_callback_api::define()</a> method.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>This will be either SW_PFIN_REASON_START or SW_PFIN_REASON_RESUME. If the reason is SW_PFIN_REASON_START, the module must initialise all data in the instance and its subclasses. If the reason is SW_PFIN_REASON_RESUME, the instance will have previously been suspended by calling <code><a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e" title="Close down the font module, close files and undefine fonts.">stop()</a></code> with reason code SW_PFIN_REASON_SUSPEND, and may have retained data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The module should return SW_PFIN_SUCCESS if it is to be active. A return of SW_PFIN_ERROR_MEMORY may cause PFIN to free resources and try again, or it may be fatal. Any other error is guaranteed to be fatal, and no other module entry points will be called, including <code><a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e" title="Close down the font module, close files and undefine fonts.">stop()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a316a46097d622324c9135c4ff822a34e"></a><!-- doxytag: member="sw_pfin_api::stop" ref="a316a46097d622324c9135c4ff822a34e" args=")(sw_pfin_instance *pfin, sw_pfin_define_context *define_context, sw_pfin_reason reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__swpfinapi.html#ga8015d311dd1dcee2c0412eaaefdbc530">sw_pfin_result</a>( * <a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e">stop</a>)(<a class="el" href="structsw__pfin__instance.html">sw_pfin_instance</a> *pfin,<a class="el" href="group__swpfinapi.html#ga2f3408e6dd4f7017e8d77f6874813df5">sw_pfin_define_context</a> *define_context, <a class="el" href="group__swpfinapi.html#ga08201091634c90c540bb8f6b2b18ea87">sw_pfin_reason</a> reason)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close down the font module, close files and undefine fonts. </p>
<p>This call is optional (indicated by a NULL) but is expected to be present if <code><a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47" title="Start using an instance of the font module, and define fonts.">start()</a></code> is. If not present, PFIN will attempt to free the module's resources - closing any files (blobs) the module opened, freeing memory, and undefining its fonts. Thus if this is all that is required, <code><a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e" title="Close down the font module, close files and undefine fonts.">stop()</a></code> may be omitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pfin</em>&nbsp;</td><td>The PFIN instance.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>define_context</em>&nbsp;</td><td>A context allowing PFIN to call the <a class="el" href="structsw__pfin__callback__api.html#aef7e22de745e0279287bd04f026518b0" title="Undefine a previously-defined module-supplied Font or CIDFont.">sw_pfin_callback_api::undefine()</a> method.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>This will be either SW_PFIN_REASON_STOP or SW_PFIN_REASON_SUSPEND. If the reason is SW_PFIN_REASON_QUIT, the module must make no further reference to the instance or any data allocated through the PFIN instance's memory allocator pointer. If the reason is SW_PFIN_REASON_SUSPEND, the implementation should free up resources, but may retain data in the instance subclass. After suspension, the only methods which will be called are either <code><a class="el" href="structsw__pfin__api.html#afe3914d409f52346345e0eb469d64b47" title="Start using an instance of the font module, and define fonts.">start()</a></code> (with a reason code of SW_PFIN_REASON_RESUME) or <code><a class="el" href="structsw__pfin__api.html#a316a46097d622324c9135c4ff822a34e" title="Close down the font module, close files and undefine fonts.">stop()</a></code> (with a reason code of SW_PFIN_REASON_STOP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The module should normally return SW_PFIN_SUCCESS. Any error return is unlikely to make any difference to RIP shutdown, but may make reinitialisation within one RIP lifetime impossible. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="swpfinapi_8h.html">swpfinapi.h</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
