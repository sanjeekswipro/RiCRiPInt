<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sw_flt_api Struct Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sw_flt_api Struct Reference<br/>
<small>
[<a class="el" href="group__PLUGIN__swflt.html">Image filtering API</a>]</small>
</h1><!-- doxytag: class="sw_flt_api" -->
<p>The definition of an implementation of the image filtering interface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;swflt.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__api__info.html">sw_api_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ae525ee940329f95941dc9b1c44d34263">superclass_name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsw__flt__api.html">sw_flt_api</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#aeffce85100af6afd7622dbb7571bf493">superclass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a6bce38b827aa5814e2892a6b3bd3ab46">init</a> )(<a class="el" href="structsw__flt__api.html">sw_flt_api</a> *api, const <a class="el" href="structsw__flt__init__params.html">sw_flt_init_params</a> *params)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <code><a class="el" href="structsw__flt__api.html#a6bce38b827aa5814e2892a6b3bd3ab46" title="The init() method is called before any other calls to the implementation.">init()</a></code> method is called before any other calls to the implementation.  <a href="#a6bce38b827aa5814e2892a6b3bd3ab46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a24f3ae9d776de4c3eb66a1b0df220ad1">finish</a> )(<a class="el" href="structsw__flt__api.html">sw_flt_api</a> *api)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <code><a class="el" href="structsw__flt__api.html#a24f3ae9d776de4c3eb66a1b0df220ad1" title="The finish() method is called after all calls to the implementation or its instances...">finish()</a></code> method is called after all calls to the implementation or its instances.  <a href="#a24f3ae9d776de4c3eb66a1b0df220ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a3cfd0b10c0338ff0bd43e0c90797f25b">present</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, const <a class="el" href="structsw__flt__construct__params.html">sw_flt_construct_params</a> *params)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a filter should be run.  <a href="#a3cfd0b10c0338ff0bd43e0c90797f25b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ab7afd50aad1409821bfe890096ebd711">construct</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, const <a class="el" href="structsw__flt__construct__params.html">sw_flt_construct_params</a> *params)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare an image instance for filtering.  <a href="#ab7afd50aad1409821bfe890096ebd711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a266c4153ee4022ad6d4ec0968e92487c">destruct</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is used to destroy an image filter instance.  <a href="#a266c4153ee4022ad6d4ec0968e92487c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a9dd9ea72e9cf0e7e8f3f8b70ef642f5c">getimageblock</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get image data for a particular block from an image.  <a href="#a9dd9ea72e9cf0e7e8f3f8b70ef642f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a477c8ee81dd04dd55cc3c026cc8c9deb">lockimageblock</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> lock, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks an image block.  <a href="#a477c8ee81dd04dd55cc3c026cc8c9deb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734">freeimageblock</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *freed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the data structures associated with a particular block of image data.  <a href="#a231579f31253c9f10cf5114cd8ac5734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ae426057148d6c8f25e2978c1f760e481">free_unneeded_blocks</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *purgedBlocks)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free blocks not needed from previous filters.  <a href="#ae426057148d6c8f25e2978c1f760e481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#adaf4c3bc469bb40455942c21616e0dc9">free_imstore</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the image store associated with a filter.  <a href="#adaf4c3bc469bb40455942c21616e0dc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a866c0b9f23fd1873e08bd68414439650">SW_FLT_security</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, void *buffer, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A security check.  <a href="#a866c0b9f23fd1873e08bd68414439650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7c9bb2f8704603583bbee7bca557a4d3">sw_flt_flags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a1820d0c008538a44d90e7d4560cf725b">flags</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a22f9b1d21d15ef33b9b4bf9a63c35b52">pipepos</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ab1a815d1a98626880e851c57b5de8bde">notifiable_colorspaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gac4abcef108b298f530a88e0bc5a95d44">sw_flt_compression</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a98886b02df1b4206493b737a05c53fff">notifiable_compressions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a0cfd9259c0c5e7602606702ad0d3533a">notifiable_pixel_formats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a857188af68655a8d0322265d697b592d">acceptable_colorspaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#ab104c2f791101eb203ca56f8a5241283">preferred_colorspace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a7d9d7d075a67117a071476dd98a94905">acceptable_pixel_formats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a40835cb207d96c3faf073efb43ad6e2d">preferred_pixel_format</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a865b11dbb25c2f49a1ba7b5bd7556f61">output_colorspace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#acfe3b2cd9491a2d71d374dbf8acef4be">output_pixel_format</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsw__datum.html">sw_datum</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a9292a37f404ecfa793f304b4908456df">requested_meta_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsw__datum.html">sw_datum</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__api.html#a3790575acdffaac8f09129e06a49db79">requested_device_config</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The definition of an implementation of the image filtering interface. </p>
<p>The RIP may construct multiple instances for each implementation registered. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a857188af68655a8d0322265d697b592d"></a><!-- doxytag: member="sw_flt_api::acceptable_colorspaces" ref="a857188af68655a8d0322265d697b592d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a> <a class="el" href="structsw__flt__api.html#a857188af68655a8d0322265d697b592d">acceptable_colorspaces</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the acceptable input colorspaces for the image filter. The RIP may choose to convert the image into one of these acceptable colorspaces. </p>

</div>
</div>
<a class="anchor" id="a7d9d7d075a67117a071476dd98a94905"></a><!-- doxytag: member="sw_flt_api::acceptable_pixel_formats" ref="a7d9d7d075a67117a071476dd98a94905" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a> <a class="el" href="structsw__flt__api.html#a7d9d7d075a67117a071476dd98a94905">acceptable_pixel_formats</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the acceptable input pixel formats for the image filter. The RIP may choose to convert the image into one of these acceptable pixel formats. </p>

</div>
</div>
<a class="anchor" id="ab7afd50aad1409821bfe890096ebd711"></a><!-- doxytag: member="sw_flt_api::construct" ref="ab7afd50aad1409821bfe890096ebd711" args=")(sw_flt_instance *idata, const sw_flt_construct_params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#ab7afd50aad1409821bfe890096ebd711">construct</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, const <a class="el" href="structsw__flt__construct__params.html">sw_flt_construct_params</a> *params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare an image instance for filtering. </p>
<p>After a filter says it would like to filter an image, it then gets called to complete initialisation of the instance data. This method should change the output image structure in the instance.</p>
<p>This method is optional. If it is NULL, and the <code><a class="el" href="structsw__flt__api.html#a3cfd0b10c0338ff0bd43e0c90797f25b" title="Determine if a filter should be run.">present()</a></code> function succeeded, the image filter will be enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter instance to be constructed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>A structure containing the image filter configuration data, and accessor APIs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the filter is enabled, SW_FLT_SKIP_FILTER if the filter is to be omitted from the pipeline, otherwise one of the sw_flt_result error codes. The <code><a class="el" href="structsw__flt__api.html#a266c4153ee4022ad6d4ec0968e92487c" title="This method is used to destroy an image filter instance.">destruct()</a></code> method will only be called if the value SW_FLT_SUCCESS was returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a266c4153ee4022ad6d4ec0968e92487c"></a><!-- doxytag: member="sw_flt_api::destruct" ref="a266c4153ee4022ad6d4ec0968e92487c" args=")(sw_flt_instance *idata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a266c4153ee4022ad6d4ec0968e92487c">destruct</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is used to destroy an image filter instance. </p>
<p>This method is optional.</p>
<p>The RIP will call the destructors individually for each instance after processing parts of the image pipeline. The filter implementation should free any memory it allocated for the instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>The filter instance to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the filter was destroyed without problems, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="a24f3ae9d776de4c3eb66a1b0df220ad1"></a><!-- doxytag: member="sw_flt_api::finish" ref="a24f3ae9d776de4c3eb66a1b0df220ad1" args=")(sw_flt_api *api)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a24f3ae9d776de4c3eb66a1b0df220ad1">finish</a>)(<a class="el" href="structsw__flt__api.html">sw_flt_api</a> *api)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <code><a class="el" href="structsw__flt__api.html#a24f3ae9d776de4c3eb66a1b0df220ad1" title="The finish() method is called after all calls to the implementation or its instances...">finish()</a></code> method is called after all calls to the implementation or its instances. </p>
<p>The implementation instances should not access any data owned by the RIP after this call, nor should they call any implementation or RIP callback API methods after this call. This method is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>api</em>&nbsp;</td><td>A registered filter implementation to finalise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1820d0c008538a44d90e7d4560cf725b"></a><!-- doxytag: member="sw_flt_api::flags" ref="a1820d0c008538a44d90e7d4560cf725b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7c9bb2f8704603583bbee7bca557a4d3">sw_flt_flags</a> <a class="el" href="structsw__flt__api.html#a1820d0c008538a44d90e7d4560cf725b">flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Filter flags are a combination of the sw_flt_flags values, indicating the filter's processing requirements. </p>

</div>
</div>
<a class="anchor" id="adaf4c3bc469bb40455942c21616e0dc9"></a><!-- doxytag: member="sw_flt_api::free_imstore" ref="adaf4c3bc469bb40455942c21616e0dc9" args=")(sw_flt_instance *idata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#adaf4c3bc469bb40455942c21616e0dc9">free_imstore</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the image store associated with a filter. </p>
<p>This method is typically called after filtering has occured, and if the filter isn't a terminal filter.</p>
<p>This method is required. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter implementation instance which should clean its image store. The instance pointer may be used to locate the store parameter to pass to the routines in the sw_flt_ifstore callback API to satisfy this request.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>purgedBlocks</em>&nbsp;</td><td>A pointer a counter, which should be incremented with the number of calls to the previous instance's <code><a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734" title="Frees the data structures associated with a particular block of image data.">freeimageblock()</a></code> method which actually freed memory, and also incremented by the number of blocks freed by calling the previous instance's <code><a class="el" href="structsw__flt__api.html#ae426057148d6c8f25e2978c1f760e481" title="Free blocks not needed from previous filters.">free_unneeded_blocks()</a></code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the request was fulfilled, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ae426057148d6c8f25e2978c1f760e481"></a><!-- doxytag: member="sw_flt_api::free_unneeded_blocks" ref="ae426057148d6c8f25e2978c1f760e481" args=")(sw_flt_instance *idata, uint32 *purgedBlocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#ae426057148d6c8f25e2978c1f760e481">free_unneeded_blocks</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *purgedBlocks)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free blocks not needed from previous filters. </p>
<p>This method is called in low memory situations. It should work out which blocks are not needed from the previous filter instance, and call the <code><a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734" title="Frees the data structures associated with a particular block of image data.">freeimageblock()</a></code> method on that instance to free those blocks. Note that this method should not free blocks in this filter instance.</p>
<p>To maximise the amount of memory recovered, this method should call <code><a class="el" href="structsw__flt__api.html#ae426057148d6c8f25e2978c1f760e481" title="Free blocks not needed from previous filters.">free_unneeded_blocks()</a></code> on the previous filter instance after making individual <code><a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734" title="Frees the data structures associated with a particular block of image data.">freeimageblock()</a></code> calls.</p>
<p>This method is required. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter implementation instance which should clean its required blocks. The instance pointer may be used to locate the store parameter to pass to the routines in the sw_flt_ifstore callback API to satisfy this request.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>purgedBlocks</em>&nbsp;</td><td>A pointer a counter, which should be incremented with the number of calls to the previous instance's <code><a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734" title="Frees the data structures associated with a particular block of image data.">freeimageblock()</a></code> method which actually freed memory, and also incremented by the number of blocks freed by calling the previous instance's <code><a class="el" href="structsw__flt__api.html#ae426057148d6c8f25e2978c1f760e481" title="Free blocks not needed from previous filters.">free_unneeded_blocks()</a></code> method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the request was fulfilled, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="a231579f31253c9f10cf5114cd8ac5734"></a><!-- doxytag: member="sw_flt_api::freeimageblock" ref="a231579f31253c9f10cf5114cd8ac5734" args=")(sw_flt_instance *idata, int32 x, int32 y, int32 plane, HqBool *freed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a231579f31253c9f10cf5114cd8ac5734">freeimageblock</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *freed)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the data structures associated with a particular block of image data. </p>
<p>Blocks are indexed by block indices. The standard block sizes can discovered by calling the <a class="el" href="structsw__flt__ifstore__api.html#a3d5cd5fb34f9b05913e5c79c42a74aa3">sw_flt_ifstore_api::if_blockWidth()</a> and <a class="el" href="structsw__flt__ifstore__api.html#a00d98874173563d48cac4e2f7113515e">sw_flt_ifstore_api::if_blockHeight()</a> in the <a class="el" href="structsw__flt__ifstore__api.html" title="Callback API for image filter store.">sw_flt_ifstore_api</a> callback interface. The block index is the pixel coordinate divided by the block height or width appropriately.</p>
<p>This method is required. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter implementation instance in which the block is being freed. The instance pointer may be used to locate an image store to pass to the routines in the sw_flt_ifstore callback API to satisfy this request.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The horizontal index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The vertical index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>A zero-based index for separated color planes, or -1 to indicate all planes .</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>freed</em>&nbsp;</td><td>A pointer to a boolean value, which should be set to TRUE if any memory was actually recovered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the request was fulfilled, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dd9ea72e9cf0e7e8f3f8b70ef642f5c"></a><!-- doxytag: member="sw_flt_api::getimageblock" ref="a9dd9ea72e9cf0e7e8f3f8b70ef642f5c" args=")(sw_flt_instance *idata, int32 x, int32 y, int32 plane, sw_flt_image_block *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a9dd9ea72e9cf0e7e8f3f8b70ef642f5c">getimageblock</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane,<a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *block)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get image data for a particular block from an image. </p>
<p>As a part of the process of getting the data for the specified block, the RIP may call methods from previous filters in the chain.</p>
<p>Blocks are indexed by block indices. The standard block sizes can discovered by calling <a class="el" href="structsw__flt__ifstore__api.html#a3d5cd5fb34f9b05913e5c79c42a74aa3">sw_flt_ifstore_api::if_blockWidth()</a> and <a class="el" href="structsw__flt__ifstore__api.html#a00d98874173563d48cac4e2f7113515e">sw_flt_ifstore_api::if_blockHeight()</a> in the <a class="el" href="structsw__flt__ifstore__api.html" title="Callback API for image filter store.">sw_flt_ifstore_api</a> callback interface. The block index is the pixel coordinate divided by the block height or width appropriately.</p>
<p>This method is required. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter implementation instance from which the block is being requested. The instance pointer may be used to locate an image store to pass to the routines in the sw_flt_ifstore callback API to satisfy this request.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The horizontal index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The vertical index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>A zero-based index for separated color planes, or -1 to indicate all planes should be returned.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>A pointer to a filter block structure in which the image block data requested will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the request was fulfilled, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab716503b26170e15c9990c190bd2e175"></a><!-- doxytag: member="sw_flt_api::info" ref="ab716503b26170e15c9990c190bd2e175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__api__info.html">sw_api_info</a> <a class="el" href="structsw__flt__api.html#ab716503b26170e15c9990c190bd2e175">info</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Version number etc. REQUIRED to be first </p>

</div>
</div>
<a class="anchor" id="a6bce38b827aa5814e2892a6b3bd3ab46"></a><!-- doxytag: member="sw_flt_api::init" ref="a6bce38b827aa5814e2892a6b3bd3ab46" args=")(sw_flt_api *api, const sw_flt_init_params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__api.html#a6bce38b827aa5814e2892a6b3bd3ab46">init</a>)(<a class="el" href="structsw__flt__api.html">sw_flt_api</a> *api,const <a class="el" href="structsw__flt__init__params.html">sw_flt_init_params</a> *params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <code><a class="el" href="structsw__flt__api.html#a6bce38b827aa5814e2892a6b3bd3ab46" title="The init() method is called before any other calls to the implementation.">init()</a></code> method is called before any other calls to the implementation. </p>
<p>This method may be used to initialise any implementation-specific data. This method is optional.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>api</em>&nbsp;</td><td>The registered filter implementation to be initialised.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>A structure containing callback APIs and parameters valid for the lifetime of the module. Any parameters that the implementation needs access to should be copied out of this structure into private storage for the registered implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>Success, indicating that the implementation is fully initialised.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>Failure to initialise the implementation. If this is returned, the implementation will not be finalised, and the RIP will terminate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a477c8ee81dd04dd55cc3c026cc8c9deb"></a><!-- doxytag: member="sw_flt_api::lockimageblock" ref="a477c8ee81dd04dd55cc3c026cc8c9deb" args=")(sw_flt_instance *idata, HqBool lock, int32 x, int32 y, int32 plane, sw_flt_image_block *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a477c8ee81dd04dd55cc3c026cc8c9deb">lockimageblock</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> lock, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *block)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks or unlocks an image block. </p>
<p>Locked blocks may not be purged by low-memory actions whilst the lock is in place.</p>
<p>Blocks are indexed by block indices. The standard block sizes can discovered by calling the <a class="el" href="structsw__flt__ifstore__api.html#a3d5cd5fb34f9b05913e5c79c42a74aa3">sw_flt_ifstore_api::if_blockWidth()</a> and <a class="el" href="structsw__flt__ifstore__api.html#a00d98874173563d48cac4e2f7113515e">sw_flt_ifstore_api::if_blockHeight()</a> in the <a class="el" href="structsw__flt__ifstore__api.html" title="Callback API for image filter store.">sw_flt_ifstore_api</a> callback interface. The block index is the pixel coordinate divided by the block height or width appropriately.</p>
<p>This method is required. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter implementation instance in which the block is being locked. The instance pointer may be used to locate an image store to pass to the routines in the sw_flt_ifstore callback API to satisfy this request.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>A boolean indicating whether the block should be locked (if TRUE), or unlocked (if FALSE).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The horizontal index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The vertical index of the block to access.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>A zero-based index for separated color planes, or -1 to indicate all planes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>A pointer to a filter block structure, previously filled in by <code><a class="el" href="structsw__flt__api.html#a9dd9ea72e9cf0e7e8f3f8b70ef642f5c" title="Get image data for a particular block from an image.">getimageblock()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the request was fulfilled, otherwise one of the sw_flt_result error codes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1a815d1a98626880e851c57b5de8bde"></a><!-- doxytag: member="sw_flt_api::notifiable_colorspaces" ref="ab1a815d1a98626880e851c57b5de8bde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a> <a class="el" href="structsw__flt__api.html#ab1a815d1a98626880e851c57b5de8bde">notifiable_colorspaces</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the colorspaces the image filter will get presented with. </p>

</div>
</div>
<a class="anchor" id="a98886b02df1b4206493b737a05c53fff"></a><!-- doxytag: member="sw_flt_api::notifiable_compressions" ref="a98886b02df1b4206493b737a05c53fff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gac4abcef108b298f530a88e0bc5a95d44">sw_flt_compression</a> <a class="el" href="structsw__flt__api.html#a98886b02df1b4206493b737a05c53fff">notifiable_compressions</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the compressions the image filter will get presented with. </p>

</div>
</div>
<a class="anchor" id="a0cfd9259c0c5e7602606702ad0d3533a"></a><!-- doxytag: member="sw_flt_api::notifiable_pixel_formats" ref="a0cfd9259c0c5e7602606702ad0d3533a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a> <a class="el" href="structsw__flt__api.html#a0cfd9259c0c5e7602606702ad0d3533a">notifiable_pixel_formats</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the pixel formats the image filter will get presented with. </p>

</div>
</div>
<a class="anchor" id="a865b11dbb25c2f49a1ba7b5bd7556f61"></a><!-- doxytag: member="sw_flt_api::output_colorspace" ref="a865b11dbb25c2f49a1ba7b5bd7556f61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a> <a class="el" href="structsw__flt__api.html#a865b11dbb25c2f49a1ba7b5bd7556f61">output_colorspace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the colorspace(s) the image filter can output. </p>

</div>
</div>
<a class="anchor" id="acfe3b2cd9491a2d71d374dbf8acef4be"></a><!-- doxytag: member="sw_flt_api::output_pixel_format" ref="acfe3b2cd9491a2d71d374dbf8acef4be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a> <a class="el" href="structsw__flt__api.html#acfe3b2cd9491a2d71d374dbf8acef4be">output_pixel_format</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the pixel format(s) the image filter can output. </p>

</div>
</div>
<a class="anchor" id="a22f9b1d21d15ef33b9b4bf9a63c35b52"></a><!-- doxytag: member="sw_flt_api::pipepos" ref="a22f9b1d21d15ef33b9b4bf9a63c35b52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="structsw__flt__api.html#a22f9b1d21d15ef33b9b4bf9a63c35b52">pipepos</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default position of the filter in the pipeline. Pre-DL filters must have a value in the range 1..9999. Post-DL filters must have a value in the range 10001-19999. </p>

</div>
</div>
<a class="anchor" id="ab104c2f791101eb203ca56f8a5241283"></a><!-- doxytag: member="sw_flt_api::preferred_colorspace" ref="ab104c2f791101eb203ca56f8a5241283" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaa7e031033d00f0ad6c1fb51414cdc392">sw_flt_colorspace</a> <a class="el" href="structsw__flt__api.html#ab104c2f791101eb203ca56f8a5241283">preferred_colorspace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the preferred input colorspace for the image filter. If the RIP is converting the image to an acceptable colorspace, this one will be chosen in preference. </p>

</div>
</div>
<a class="anchor" id="a40835cb207d96c3faf073efb43ad6e2d"></a><!-- doxytag: member="sw_flt_api::preferred_pixel_format" ref="a40835cb207d96c3faf073efb43ad6e2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#gaae1b4f0463cf26f89951c5573fbe8986">sw_flt_pixfmt</a> <a class="el" href="structsw__flt__api.html#a40835cb207d96c3faf073efb43ad6e2d">preferred_pixel_format</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class variable to specify the preferred input pixel format for the image filter. If the RIP is converting the image to an acceptable pixel format, this one will be chosen in preference. </p>

</div>
</div>
<a class="anchor" id="a3cfd0b10c0338ff0bd43e0c90797f25b"></a><!-- doxytag: member="sw_flt_api::present" ref="a3cfd0b10c0338ff0bd43e0c90797f25b" args=")(sw_flt_instance *idata, const sw_flt_construct_params *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__api.html#a3cfd0b10c0338ff0bd43e0c90797f25b">present</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, const <a class="el" href="structsw__flt__construct__params.html">sw_flt_construct_params</a> *params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a filter should be run. </p>
<p>The filter instance is given a chance to examine input image data from the previous step in the pipeline, look at the image parameters and modify the output image details. The return value indicates if the filter should be constructed or skipped.</p>
<p>All changes to the output image details should be done in the <code><a class="el" href="structsw__flt__api.html#a3cfd0b10c0338ff0bd43e0c90797f25b" title="Determine if a filter should be run.">present()</a></code> method.</p>
<p>This method is optional. If it is NULL, the image filter will be given a chance to construct itself, and then enabled if that is successful, but may not change pertinent details of the output image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>The filter instance presented for consideration.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>A structure containing the image filter configuration data, and accessor APIs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_FLT_SUCCESS if the filter is to be constructed, SW_FLT_SKIP_FILTER if the filter is to be omitted from the pipeline, otherwise one of the sw_flt_result error codes. The <code><a class="el" href="structsw__flt__api.html#a266c4153ee4022ad6d4ec0968e92487c" title="This method is used to destroy an image filter instance.">destruct()</a></code> method will only be called if the value SW_FLT_SUCCESS was returned by both this method and the <code><a class="el" href="structsw__flt__api.html#ab7afd50aad1409821bfe890096ebd711" title="Prepare an image instance for filtering.">construct()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3790575acdffaac8f09129e06a49db79"></a><!-- doxytag: member="sw_flt_api::requested_device_config" ref="a3790575acdffaac8f09129e06a49db79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsw__datum.html">sw_datum</a>* <a class="el" href="structsw__flt__api.html#a3790575acdffaac8f09129e06a49db79">requested_device_config</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A datum specifying the device configuration parameters that the image filter is interested in using when presented with the image. </p>

</div>
</div>
<a class="anchor" id="a9292a37f404ecfa793f304b4908456df"></a><!-- doxytag: member="sw_flt_api::requested_meta_data" ref="a9292a37f404ecfa793f304b4908456df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsw__datum.html">sw_datum</a>* <a class="el" href="structsw__flt__api.html#a9292a37f404ecfa793f304b4908456df">requested_meta_data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A datum specifying the image metadata that the image filter is interested in using when presented with the image. </p>

</div>
</div>
<a class="anchor" id="aeffce85100af6afd7622dbb7571bf493"></a><!-- doxytag: member="sw_flt_api::superclass" ref="aeffce85100af6afd7622dbb7571bf493" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsw__flt__api.html">sw_flt_api</a>* <a class="el" href="structsw__flt__api.html#aeffce85100af6afd7622dbb7571bf493">superclass</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pointer to the superclass of the implementation. If a superclass name is supplied, then this should be NULL, and the value will be initialised by the RIP at registration. This may be initialised to a valid superclass address before registration if the superclass name is NULL. </p>

</div>
</div>
<a class="anchor" id="ae525ee940329f95941dc9b1c44d34263"></a><!-- doxytag: member="sw_flt_api::superclass_name" ref="ae525ee940329f95941dc9b1c44d34263" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a>* <a class="el" href="structsw__flt__api.html#ae525ee940329f95941dc9b1c44d34263">superclass_name</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The internal name of the superclass of the filter. If this is non-NULL, the named API implementation must have already been registered, and the RIP will initialise the <em>superclass</em> pointer to the discovered filter. </p>

</div>
</div>
<a class="anchor" id="a866c0b9f23fd1873e08bd68414439650"></a><!-- doxytag: member="sw_flt_api::SW_FLT_security" ref="a866c0b9f23fd1873e08bd68414439650" args=")(sw_flt_instance *idata, void *buffer, uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__api.html#a866c0b9f23fd1873e08bd68414439650">SW_FLT_security</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, void *buffer, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A security check. </p>
<p>This method is optional. If this method pointer is NULL on registration, it will be inherited from the filter's superclass (if any). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="swflt_8h.html">swflt.h</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
