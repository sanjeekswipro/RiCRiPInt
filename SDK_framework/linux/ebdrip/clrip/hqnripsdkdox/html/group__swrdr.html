<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: RDR ROM Data Resource</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RDR ROM Data Resource<br/>
<small>
[<a class="el" href="group__interface.html">Harlequin RIP core interface.</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HqnIdent.  <a href="#gafee2b1509bc86bb08c9b05ea4ed99fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RDR Types.  <a href="#ga69ca376b88b1f5c2975979592b975ee8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RDR ID.  <a href="#ga399c71b627a20751d4893681abcd9c77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RDR priority.  <a href="#ga26d85789c6d3fcc64123c7e468b9cec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gab291d9a10aca77fffa8dbe068eadb1ba">sw_rdr_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for finding multiple RDRs.  <a href="#gab291d9a10aca77fffa8dbe068eadb1ba"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aac13914d5ee297861b9c6da0f2cf6a7c6">RDR_CLASS_EVENT</a> =  -1, 
<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aa5803c3f175b079b0e103e99a764ae94e">RDR_CLASS_RDR</a> =  1, 
<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aabe5d64fdd6ee554f1072d2679d683e5d">RDR_CLASS_FONT</a>, 
<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aa9ab523974e40fa4e96247782b2e79346">RDR_CLASS_PCL</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aaaa2700a840389667f29908232e152716">RDR_CLASS_API</a>, 
<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aa673bff2e0f703b1124231450e8432dfb">RDR_CLASS_TIMELINE</a>, 
<a class="el" href="group__swrdr.html#gga7cc2e4244ca368f68e5746185eda6c4aab9b6f221f45fccc544395ddf9947e3ee">RDR_CLASS_LOW_MEM</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>RDR Classes. </p>
 <a href="group__swrdr.html#ga7cc2e4244ca368f68e5746185eda6c4a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__swrdr.html#ggaedcf2109f459315e1a7f2af73ec9b603ab70a030b48d6a8b226de772dbb1e5110">SW_RDR_DEFAULT</a> =  -10000, 
<a class="el" href="group__swrdr.html#ggaedcf2109f459315e1a7f2af73ec9b603ac5c10ba7ffe2850af28b352b9fd54b4b">SW_RDR_NORMAL</a> =  0, 
<a class="el" href="group__swrdr.html#ggaedcf2109f459315e1a7f2af73ec9b603ab0b5b8d314143463fabe8ca119076464">SW_RDR_OVERRIDE</a> =  10000
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of RDR priorities. </p>
 <a href="group__swrdr.html#gaedcf2109f459315e1a7f2af73ec9b603">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47ba34d31e6d3d9529d945a4d8c5aa459ebc">SW_RDR_SUCCESS</a> =  0, 
<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47ba739052b947cd012bacb16458a64b0c99">SW_RDR_ERROR</a>, 
<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47ba848eedc1bc09c553dd8436dbf01d8937">SW_RDR_ERROR_UNKNOWN</a>, 
<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47babd325e8c55c7fde9ef4d3bed8f686ef3">SW_RDR_ERROR_SYNTAX</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47bac664b67b99028360d0cec47c18cc752c">SW_RDR_ERROR_IN_USE</a>, 
<a class="el" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47badcc4e94e21f4c35621b5cde360d34c26">SW_RDR_ERROR_MEMORY</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Return values from RDR API calls. </p>
 <a href="group__swrdr.html#ga900dca9b26de42491763226e12dcd47b">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gae824fcecb6784120f82bf09305f6e5bd">rdr_start</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise the RDR system.  <a href="#gae824fcecb6784120f82bf09305f6e5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void HQNCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga2ba6e097a68cb96a4c58f5f741d5b562">rdr_end</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finalise the RDR system.  <a href="#ga2ba6e097a68cb96a4c58f5f741d5b562"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gaf0b144b0c1679c5ae1334e9d21324213">register_rdr</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void *ptr, size_t length, <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an RDR.  <a href="#gaf0b144b0c1679c5ae1334e9d21324213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga095af8ac15cf4e562b0ccbca7f4ef1ca">register_id</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *prdrid, void *ptr, size_t length, <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a> priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an RDR and allocate it a unique ID.  <a href="#ga095af8ac15cf4e562b0ccbca7f4ef1ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gad89ea97c90729eba6c5e1367b11cb006">deregister</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void *ptr, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister an RDR.  <a href="#gad89ea97c90729eba6c5e1367b11cb006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga097af3d11f3b06fe7414f851ecccb969">find</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> rdrid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an RDR given the Class, Type and ID.  <a href="#ga097af3d11f3b06fe7414f851ecccb969"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga1b46698fb0982ba9c74f97b91fdda532">find_type</a> (sw_rdr_class rdrclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> rdrtype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all RDRs of a specified Class and Type.  <a href="#ga1b46698fb0982ba9c74f97b91fdda532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga4445c17e5db250734ccd119357a618d5">find_class</a> (sw_rdr_class rdrclass)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all RDRs of a specified Class.  <a href="#ga4445c17e5db250734ccd119357a618d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga9005f95b58d2910470fea7c3088bc934">find_all</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all RDRs.  <a href="#ga9005f95b58d2910470fea7c3088bc934"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gae0c0bd41ca1143e6637f5777c0af07bd">next</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, sw_rdr_class *pclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *ptype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *pid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an RDR by iteration.  <a href="#gae0c0bd41ca1143e6637f5777c0af07bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga9ae38da88691ea7bfadf4223ba66b70b">lock_next</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator, sw_rdr_class *pclass, <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *ptype, <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *pid, void **pptr, size_t *plength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an RDR by iteration and lock it to prevent deregistration.  <a href="#ga9ae38da88691ea7bfadf4223ba66b70b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#gab56f3b0b58c1f18187baffa2e622c657">restart</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart an RDR iterator.  <a href="#gab56f3b0b58c1f18187baffa2e622c657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sw_rdr_result HQNCALL rdr_api&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__swrdr.html#ga4864d63f49b5705aff5890fdc5bad0f8">found</a> (<a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *iterator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an RDR iterator.  <a href="#ga4864d63f49b5705aff5890fdc5bad0f8"></a><br/></td></tr>
</table>


<h3><a class="anchor" id="rdrapi">The ROM Data Resource API</a></h3><p>The ROM Data Resource (RDR) API allows data to be discovered at run time in RIP, rather than being statically linked at build time. This allows complete decoupling of skin-supplied, RIP-consumed data (or vice versa); allows the skin to optionally override RIP-embedded data; and even allows data to be selected contextually.</p>
<p>Individual blocks of data - RDRs - are identified by Class, Type and ID. A Consumer can iterate through available RDRs, filtered by Class and Type if required, or can directly locate a specific RDR.</p>
<h2><a class="anchor" id="RDRClasses">
RDR Classes</a></h2>
<p>RDR classes are enumerated in this header file. Classes are subdivided into Types. The distinction between Class and Type is usually clear from the context - embedded fonts registered as RDRs might have a Class of "Font", and a Type indicating their format.</p>
<h2><a class="anchor" id="RDRTypes">
RDR Types</a></h2>
<p>RDR Types are enumerated elsewhere, as they are unique only within a single Class. For example, the Font Class may use the value "1" to indicate a Type1 font, "42" to indicate a TrueType, etc. Within another Class, Type "1" will have a different meaning.</p>
<h2><a class="anchor" id="RDRIDs">
RDR IDs</a></h2>
<p>Individual RDRs of a particular Class and Type are discerned by ID. There can only ever be one RDR with a particular Class:Type:ID combination. The most recently registered (or highest priority) RDR with that combination is the visible one - see below for prioritisation.</p>
<p>Previous registrations are remembered in chronological order, and will be restored if the current RDR is deregistered. This allows contextual overriding of a default RDR.</p>
<h2><a class="anchor" id="RDRPriority">
RDR Priority</a></h2>
<p>Ideally, where two RDRs of the same Class:Type:ID are registered, the first would be the default definition, and the second the overridden version. In practice this chronology may be difficult to ensure, so RDR registration takes a priority parameter. High priority registrations always override lower priority registrations, regardless of registration ordering. Strict chronological ordering is still maintained within any one priority level.</p>
<h2><a class="anchor" id="RDRFormat">
RDR Format</a></h2>
<p>An RDR is simply a contiguous block of memory - though it doesn't have to be in ROM or even part of the executable, that is its primary purpose. As long as Provider and Consumer agree, the data may not even have to exist. RDRs are registered through the RDR API with a Class, Type and ID, plus a pointer to the data and its length. Class and Type must be specified, but an ID can be allocated automatically if required. RDRs can also be removed, by deregistering them by their Class, Type and ID, or by their location and length.</p>
<h2><a class="anchor" id="RDRUses">
RDR Uses</a></h2>
<p>RDRs can be used for many things in addition to registering and discovering blocks of prebuilt data. The RDR System itself places no interpretation on the content of any RDR - the interpretation is defined by the owner of the RDR Class in question. The only exception is a null pointer, zero length registration, which has a special meaning described later.</p>
<p>RDRs can therefore be used to do any of the following, and many more:</p>
<p>1. Identify a block of data.</p>
<p>2. Identify a memory location, such as a threshold or limit.</p>
<p>3. Identify a memory size, such as a cache limit.</p>
<p>4. Supply a filename or environment string (the data being the C string)</p>
<p>5. Specify PostScript fragments to be run at job start. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gafee2b1509bc86bb08c9b05ea4ed99fc6"></a><!-- doxytag: member="rdrapi.h::HqnIdent" ref="gafee2b1509bc86bb08c9b05ea4ed99fc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>HqnIdent. </p>
<p>HqnIdent is a superclass of identifiers used by the RDR, Event and Timeline APIs and are defined to be interworkable. It is therefore possible to use a Timeline reference as an RDR ID within some Class and Type, for example. </p>

</div>
</div>
<a class="anchor" id="ga399c71b627a20751d4893681abcd9c77"></a><!-- doxytag: member="rdrapi.h::sw_rdr_id" ref="ga399c71b627a20751d4893681abcd9c77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a> <a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RDR ID. </p>
<p>IDs are unique per Class and Type, and are either predefined elsewhere or allocated on demand by SwRegisterRDRandID(). </p>

</div>
</div>
<a class="anchor" id="gab291d9a10aca77fffa8dbe068eadb1ba"></a><!-- doxytag: member="rdrapi.h::sw_rdr_iterator" ref="gab291d9a10aca77fffa8dbe068eadb1ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> <a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator for finding multiple RDRs. </p>
<p>These are created by any of the SwFindRDR*() calls, passed to SwNextRDR(), can be restarted by SwRestartFindRDR() and are destroyed by SwFoundRDR().</p>
<p>They are opaque and should not be inspected or altered. </p>

</div>
</div>
<a class="anchor" id="ga26d85789c6d3fcc64123c7e468b9cec5"></a><!-- doxytag: member="rdrapi.h::sw_rdr_priority" ref="ga26d85789c6d3fcc64123c7e468b9cec5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> <a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RDR priority. </p>
<p>RDRs defined with the same Class:Type:ID combination are held in strict chronological order, with the most recent registration being the visible definition. Prioritisation allows this chronology to be overridden, in that low priority RDRs are guaranteed to be superseded by higher priority registrations, regardless of chronology. Strict chronological ordering is maintained for RDRs at the same priority level. </p>

</div>
</div>
<a class="anchor" id="ga69ca376b88b1f5c2975979592b975ee8"></a><!-- doxytag: member="rdrapi.h::sw_rdr_type" ref="ga69ca376b88b1f5c2975979592b975ee8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__swrdr.html#gafee2b1509bc86bb08c9b05ea4ed99fc6">HqnIdent</a> <a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RDR Types. </p>
<p>Types are defined on a per-Class basis elsewhere. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga7cc2e4244ca368f68e5746185eda6c4a"></a><!-- doxytag: member="rdrapi.h::@52" ref="ga7cc2e4244ca368f68e5746185eda6c4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RDR Classes. </p>
<p>Classes are defined here and subdivided into Types defined elsewhere. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aac13914d5ee297861b9c6da0f2cf6a7c6"></a><!-- doxytag: member="RDR_CLASS_EVENT" ref="gga7cc2e4244ca368f68e5746185eda6c4aac13914d5ee297861b9c6da0f2cf6a7c6" args="" -->RDR_CLASS_EVENT</em>&nbsp;</td><td>
<p>Asynchronous Events and Messages </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aa5803c3f175b079b0e103e99a764ae94e"></a><!-- doxytag: member="RDR_CLASS_RDR" ref="gga7cc2e4244ca368f68e5746185eda6c4aa5803c3f175b079b0e103e99a764ae94e" args="" -->RDR_CLASS_RDR</em>&nbsp;</td><td>
<p>For RDR's internal use </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aabe5d64fdd6ee554f1072d2679d683e5d"></a><!-- doxytag: member="RDR_CLASS_FONT" ref="gga7cc2e4244ca368f68e5746185eda6c4aabe5d64fdd6ee554f1072d2679d683e5d" args="" -->RDR_CLASS_FONT</em>&nbsp;</td><td>
<p>Embedded font files </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aa9ab523974e40fa4e96247782b2e79346"></a><!-- doxytag: member="RDR_CLASS_PCL" ref="gga7cc2e4244ca368f68e5746185eda6c4aa9ab523974e40fa4e96247782b2e79346" args="" -->RDR_CLASS_PCL</em>&nbsp;</td><td>
<p>PCL related data tables </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aaaa2700a840389667f29908232e152716"></a><!-- doxytag: member="RDR_CLASS_API" ref="gga7cc2e4244ca368f68e5746185eda6c4aaaa2700a840389667f29908232e152716" args="" -->RDR_CLASS_API</em>&nbsp;</td><td>
<p>Function tables, such as skin-supplied UFST. Type is identifier, ID is version number. Types are defined in <a class="el" href="apis_8h.html" title="This header file defines Types of RDR_CLASS_API, used to identify APIs exposed through...">apis.h</a> </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aa673bff2e0f703b1124231450e8432dfb"></a><!-- doxytag: member="RDR_CLASS_TIMELINE" ref="gga7cc2e4244ca368f68e5746185eda6c4aa673bff2e0f703b1124231450e8432dfb" args="" -->RDR_CLASS_TIMELINE</em>&nbsp;</td><td>
<p>Timeline specific definitions </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga7cc2e4244ca368f68e5746185eda6c4aab9b6f221f45fccc544395ddf9947e3ee"></a><!-- doxytag: member="RDR_CLASS_LOW_MEM" ref="gga7cc2e4244ca368f68e5746185eda6c4aab9b6f221f45fccc544395ddf9947e3ee" args="" -->RDR_CLASS_LOW_MEM</em>&nbsp;</td><td>
<p>Low-memory handlers </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedcf2109f459315e1a7f2af73ec9b603"></a><!-- doxytag: member="rdrapi.h::@53" ref="gaedcf2109f459315e1a7f2af73ec9b603" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of RDR priorities. </p>
<p>It is defined that the usual case is a priority of zero, so SW_RDR_NORMAL can be replaced with "0" in actual code.</p>
<p>Priority is primarily used to discern default from override definitions, but within any particular Class and Type, prioritisation can be used to implement any weighting, preference or selection process.</p>
<p>Note however that priority is an attribute of the Provider's registration, not of the RDR that is being registered - the priority of the RDR is not revealed to the Consumer. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaedcf2109f459315e1a7f2af73ec9b603ab70a030b48d6a8b226de772dbb1e5110"></a><!-- doxytag: member="SW_RDR_DEFAULT" ref="ggaedcf2109f459315e1a7f2af73ec9b603ab70a030b48d6a8b226de772dbb1e5110" args="" -->SW_RDR_DEFAULT</em>&nbsp;</td><td>
<p>Known to be a default </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaedcf2109f459315e1a7f2af73ec9b603ac5c10ba7ffe2850af28b352b9fd54b4b"></a><!-- doxytag: member="SW_RDR_NORMAL" ref="ggaedcf2109f459315e1a7f2af73ec9b603ac5c10ba7ffe2850af28b352b9fd54b4b" args="" -->SW_RDR_NORMAL</em>&nbsp;</td><td>
<p>The usual case </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaedcf2109f459315e1a7f2af73ec9b603ab0b5b8d314143463fabe8ca119076464"></a><!-- doxytag: member="SW_RDR_OVERRIDE" ref="ggaedcf2109f459315e1a7f2af73ec9b603ab0b5b8d314143463fabe8ca119076464" args="" -->SW_RDR_OVERRIDE</em>&nbsp;</td><td>
<p>High priority registration </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga900dca9b26de42491763226e12dcd47b"></a><!-- doxytag: member="rdrapi.h::@54" ref="ga900dca9b26de42491763226e12dcd47b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return values from RDR API calls. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47ba34d31e6d3d9529d945a4d8c5aa459ebc"></a><!-- doxytag: member="SW_RDR_SUCCESS" ref="gga900dca9b26de42491763226e12dcd47ba34d31e6d3d9529d945a4d8c5aa459ebc" args="" -->SW_RDR_SUCCESS</em>&nbsp;</td><td>
<p>Normal return value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47ba739052b947cd012bacb16458a64b0c99"></a><!-- doxytag: member="SW_RDR_ERROR" ref="gga900dca9b26de42491763226e12dcd47ba739052b947cd012bacb16458a64b0c99" args="" -->SW_RDR_ERROR</em>&nbsp;</td><td>
<p>Some unknown failure occurred </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47ba848eedc1bc09c553dd8436dbf01d8937"></a><!-- doxytag: member="SW_RDR_ERROR_UNKNOWN" ref="gga900dca9b26de42491763226e12dcd47ba848eedc1bc09c553dd8436dbf01d8937" args="" -->SW_RDR_ERROR_UNKNOWN</em>&nbsp;</td><td>
<p>Specified RDR is undefined </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47babd325e8c55c7fde9ef4d3bed8f686ef3"></a><!-- doxytag: member="SW_RDR_ERROR_SYNTAX" ref="gga900dca9b26de42491763226e12dcd47babd325e8c55c7fde9ef4d3bed8f686ef3" args="" -->SW_RDR_ERROR_SYNTAX</em>&nbsp;</td><td>
<p>Programming error - illegal parameters </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47bac664b67b99028360d0cec47c18cc752c"></a><!-- doxytag: member="SW_RDR_ERROR_IN_USE" ref="gga900dca9b26de42491763226e12dcd47bac664b67b99028360d0cec47c18cc752c" args="" -->SW_RDR_ERROR_IN_USE</em>&nbsp;</td><td>
<p>Re-entrancy error - iterator conflict </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga900dca9b26de42491763226e12dcd47badcc4e94e21f4c35621b5cde360d34c26"></a><!-- doxytag: member="SW_RDR_ERROR_MEMORY" ref="gga900dca9b26de42491763226e12dcd47badcc4e94e21f4c35621b5cde360d34c26" args="" -->SW_RDR_ERROR_MEMORY</em>&nbsp;</td><td>
<p>Memory allocation failed </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad89ea97c90729eba6c5e1367b11cb006"></a><!-- doxytag: member="rdrapi.h::deregister" ref="gad89ea97c90729eba6c5e1367b11cb006" args="(sw_rdr_class rdrclass, sw_rdr_type rdrtype, sw_rdr_id rdrid, void *ptr, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api deregister </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a>&nbsp;</td>
          <td class="paramname"> <em>rdrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a>&nbsp;</td>
          <td class="paramname"> <em>rdrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deregister an RDR. </p>
<p>This call deregisters an RDR of a particular Class, Type and ID. Any previously registered RDR of that Class, Type and ID will reappear.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR when registered.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrtype</em>&nbsp;</td><td>The Type of the RDR when registered.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrid</em>&nbsp;</td><td>The ID of the RDR within this Class and Type.</td></tr>
  </table>
  </dd>
</dl>
<p>If an ID was automatically allocated, it must be supplied to deregister the RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>A pointer to the start of the data.</td></tr>
  </table>
  </dd>
</dl>
<p>This must be the originally registered pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data.</td></tr>
  </table>
  </dd>
</dl>
<p>This must be the originally registered length.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS if the RDR was deregistered.</dd></dl>
<p>SW_RDR_ERROR_UNKNOWN is returned if the RDR could not be found.</p>
<p>SW_RDR_ERROR_IN_USE if the RDR is locked. This is informational - the RDR has been deregistered and cannot be found again. It will be discarded only when there are no remaining locks on it. It is not safe to dispose of the RDR contents if this error is returned, see below.</p>
<p>All parameters MUST match those specified during registration for the RDR to be deregistered.</p>
<p>Note that this prevents (or at least changes) discovery of a particular RDR - it does not withdraw access rights from Consumers that have already found the RDR - that must be achieved by some additional protocol such as an Event or Timeline.</p>
<p>If the RDR has been locked by SwLockNextRDR(), it is deregistered but SW_RDR_ERROR_IN_USE is returned. This call can be repeated and will continue to return SW_RDR_ERROR_IN_USE for as long as the RDR is locked. Once unlocked it will automatically be discarded and this call will return SW_RDR_ERROR_UNKNOWN. See SwLockNextRDR() for more details of RDR locking.</p>
<p>Important: If the RDR refers to something that is to be discarded after deregistration it must NOT be discarded until SwDeregisterRDR() returns something other than SW_RDR_ERROR_IN_USE.</p>
<p>This removes a registration, and also updates any current iterators that are in any way linked to this RDR. </p>

</div>
</div>
<a class="anchor" id="ga097af3d11f3b06fe7414f851ecccb969"></a><!-- doxytag: member="rdrapi.h::find" ref="ga097af3d11f3b06fe7414f851ecccb969" args="(sw_rdr_class rdrclass, sw_rdr_type rdrtype, sw_rdr_id rdrid, void **pptr, size_t *plength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api find </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a>&nbsp;</td>
          <td class="paramname"> <em>rdrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a>&nbsp;</td>
          <td class="paramname"> <em>rdrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>plength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an RDR given the Class, Type and ID. </p>
<p>This call allows the consumer to find a specific RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrtype</em>&nbsp;</td><td>The Type of the RDR.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrid</em>&nbsp;</td><td>The ID of the RDR.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pptr</em>&nbsp;</td><td>A pointer to a pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the pointer if the RDR is found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>plength</em>&nbsp;</td><td>A pointer to a length.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the length if the RDR is found.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS if the RDR was found.</dd></dl>
<p>SW_RDR_ERROR_UNKNOWN is returned if no RDR of the specified Class, Type and ID was found.</p>
<p>eg: </p>
<div class="fragment"><pre class="fragment">      result = SwFindRDR(myclass, mytype, myid, &amp;ptr, &amp;len);
      <span class="keywordflow">if</span> (result == <a class="code" href="group__swrdr.html#gga900dca9b26de42491763226e12dcd47ba34d31e6d3d9529d945a4d8c5aa459ebc">SW_RDR_SUCCESS</a>) {
        ...
      }
</pre></div> 
</div>
</div>
<a class="anchor" id="ga9005f95b58d2910470fea7c3088bc934"></a><!-- doxytag: member="rdrapi.h::find_all" ref="ga9005f95b58d2910470fea7c3088bc934" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a>* HQNCALL rdr_api find_all </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all RDRs. </p>
<p>This call begins an iteration to find all RDRs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a <a class="el" href="structsw__rdr__iterator.html" title="Our private iterator structure.">sw_rdr_iterator</a> or null.</dd></dl>
<p>If null, there was insufficient memory to create the iterator.</p>
<p>Otherwise, this is passed (multiple times) to SwNextRDR(), and ultimately must be destroyed by calling SwFoundRDR().</p>
<p>As above, it is permissible to create the iterator in advance.</p>
<p>eg: </p>
<div class="fragment"><pre class="fragment">      iterator = SwFindRDRs();
      <span class="keywordflow">if</span> (iterator) {
        <span class="keywordflow">while</span> (SwNextRDR(iterator, &amp;<span class="keyword">class</span>, &amp;type, &amp;<span class="keywordtype">id</span>, &amp;ptr, &amp;len)) {
          ...
        }
        SwFoundRDR(iterator);
      }
</pre></div> 
</div>
</div>
<a class="anchor" id="ga4445c17e5db250734ccd119357a618d5"></a><!-- doxytag: member="rdrapi.h::find_class" ref="ga4445c17e5db250734ccd119357a618d5" args="(sw_rdr_class rdrclass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a>* HQNCALL rdr_api find_class </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all RDRs of a specified Class. </p>
<p>This call begins an iteration to find all RDRs of a specific class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a <a class="el" href="structsw__rdr__iterator.html" title="Our private iterator structure.">sw_rdr_iterator</a> or null.</dd></dl>
<p>If null, there was insufficient memory to create the iterator.</p>
<p>Otherwise, this is passed (multiple times) to SwNextRDR(), and ultimately must be destroyed by calling SwFoundRDR().</p>
<p>As above, it is permissible to create the iterator in advance.</p>
<p>eg: </p>
<div class="fragment"><pre class="fragment">      iterator = SwFindRDRbyClass(myclass);
      <span class="keywordflow">if</span> (iterator) {
        <span class="keywordflow">while</span> (SwNextRDR(iterator, 0, &amp;type, &amp;<span class="keywordtype">id</span>, &amp;ptr, &amp;len)) {
          ...
        }
        SwFoundRDR(iterator);
      }
</pre></div> 
</div>
</div>
<a class="anchor" id="ga1b46698fb0982ba9c74f97b91fdda532"></a><!-- doxytag: member="rdrapi.h::find_type" ref="ga1b46698fb0982ba9c74f97b91fdda532" args="(sw_rdr_class rdrclass, sw_rdr_type rdrtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a>* HQNCALL rdr_api find_type </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a>&nbsp;</td>
          <td class="paramname"> <em>rdrtype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all RDRs of a specified Class and Type. </p>
<p>This call begins an iteration to find all RDRs of a specific type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrtype</em>&nbsp;</td><td>The Type of the RDR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a <a class="el" href="structsw__rdr__iterator.html" title="Our private iterator structure.">sw_rdr_iterator</a> or null.</dd></dl>
<p>If null, there was insufficient memory to create the iterator.</p>
<p>Otherwise, this is passed (multiple times) to SwNextRDR(), and ultimately must be destroyed by calling SwFoundRDR().</p>
<p>It is permissible to create the iterator long in advance of calling SwNextRDR() to avoid the possibility of failing due to insufficient memory. Iterators can be restarted using SwRestartFindRDR() and hence multiple searches can be performed using the same iterator without having to call SwFoundRDR() and SwFindRDRbyType() again.</p>
<p>eg: </p>
<div class="fragment"><pre class="fragment">      iterator = SwFindRDRbyType(myclass, mytype);
      <span class="keywordflow">if</span> (iterator) {
        <span class="keywordflow">while</span> (SwNextRDR(iterator, 0, 0, &amp;<span class="keywordtype">id</span>, &amp;ptr, &amp;len)) {
          ...
        }
        SwFoundRDR(iterator);
      }
</pre></div> 
</div>
</div>
<a class="anchor" id="ga4864d63f49b5705aff5890fdc5bad0f8"></a><!-- doxytag: member="rdrapi.h::found" ref="ga4864d63f49b5705aff5890fdc5bad0f8" args="(sw_rdr_iterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api found </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy an RDR iterator. </p>
<p>This call ends an iteration to find RDRs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>The iterator to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Passing in a null iterator is pointless but safe.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, normally; SW_RDR_ERROR_IN_USE if the iterator cannot be destroyed because it is threaded; SW_RDR_ERROR_SYNTAX if the iterator is not recognised.</dd></dl>
<p>This automatically unlocks the RDR returned by a call to SwLockNextRDR(). </p>

</div>
</div>
<a class="anchor" id="ga9ae38da88691ea7bfadf4223ba66b70b"></a><!-- doxytag: member="rdrapi.h::lock_next" ref="ga9ae38da88691ea7bfadf4223ba66b70b" args="(sw_rdr_iterator *iterator, sw_rdr_class *pclass, sw_rdr_type *ptype, sw_rdr_id *pid, void **pptr, size_t *plength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api lock_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw_rdr_class *&nbsp;</td>
          <td class="paramname"> <em>pclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *&nbsp;</td>
          <td class="paramname"> <em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>plength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an RDR by iteration and lock it to prevent deregistration. </p>
<p>All parameters and behavour as SwNextRDR() above, except the returned RDR is locked and can not be deregistered. It is unlocked automatically when the iterator is next passed to SwNextRDR(), SwLockNextRDR(), SwFoundRDR() or SwRestartFindRDR().</p>
<p>If SwDeregisterRDR() is called on a locked RDR it is deregistered at once to prevent further discovery but is only discarded once fully unlocked. Note that multiple seperate find operations could have locked the RDR many times, and all must unlock before the RDR is finally discarded.</p>
<p>Important: If the RDR refers to something that is to be discarded after deregistration it must NOT be discarded until SwDeregisterRDR() returned something other than SW_RDR_ERROR_IN_USE. </p>

</div>
</div>
<a class="anchor" id="gae0c0bd41ca1143e6637f5777c0af07bd"></a><!-- doxytag: member="rdrapi.h::next" ref="gae0c0bd41ca1143e6637f5777c0af07bd" args="(sw_rdr_iterator *iterator, sw_rdr_class *pclass, sw_rdr_type *ptype, sw_rdr_id *pid, void **pptr, size_t *plength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw_rdr_class *&nbsp;</td>
          <td class="paramname"> <em>pclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a> *&nbsp;</td>
          <td class="paramname"> <em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>plength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an RDR by iteration. </p>
<p>This call returns an RDR from the given iterator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>The <a class="el" href="structsw__rdr__iterator.html" title="Our private iterator structure.">sw_rdr_iterator</a> created by SwFindRDR*().</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pclass</em>&nbsp;</td><td>Optional pointer to an RDR class.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the class of the found RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ptype</em>&nbsp;</td><td>Optional pointer to an RDR type.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the type of the found RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pid</em>&nbsp;</td><td>Optional pointer to an RDR id.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the id of the found RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pptr</em>&nbsp;</td><td>Pointer to a pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the ptr of the found RDR.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>plength</em>&nbsp;</td><td>Pointer to a length.</td></tr>
  </table>
  </dd>
</dl>
<p>If not null, this will be filled in with the length of the found RDR.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SW_RDR_SUCCESS if an RDR was found, SW_RDR_ERROR_UNKNOWN if no further RDRs match or SW_RDR_ERROR_SYNTAX if the iterator is invalid.</dd></dl>
<p>Once the iteration is finished, the iterator must be destroyed by calling SwFoundRDR(), or reset using SwRestartFindRDR() if the iterator is to persist or be reused immediately.</p>
<p>Note that in a multithreaded system it is possible for an RDR to be deregistered after this call has returned but before the caller tries to use it. See SwLockNextRDR() below. </p>

</div>
</div>
<a class="anchor" id="ga2ba6e097a68cb96a4c58f5f741d5b562"></a><!-- doxytag: member="rdrapi.h::rdr_end" ref="ga2ba6e097a68cb96a4c58f5f741d5b562" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HQNCALL rdr_end </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalise the RDR system. </p>
<p>The control variable and mutex are destroyed, and allocations discarded. </p>

</div>
</div>
<a class="anchor" id="gae824fcecb6784120f82bf09305f6e5bd"></a><!-- doxytag: member="rdrapi.h::rdr_start" ref="gae824fcecb6784120f82bf09305f6e5bd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HQNCALL rdr_start </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the RDR system. </p>
<p>The mutex and control variables are created and configured, and the concurrency count zeroed. </p>

</div>
</div>
<a class="anchor" id="ga095af8ac15cf4e562b0ccbca7f4ef1ca"></a><!-- doxytag: member="rdrapi.h::register_id" ref="ga095af8ac15cf4e562b0ccbca7f4ef1ca" args="(sw_rdr_class rdrclass, sw_rdr_type rdrtype, sw_rdr_id *prdrid, void *ptr, size_t length, sw_rdr_priority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api register_id </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a>&nbsp;</td>
          <td class="paramname"> <em>rdrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a> *&nbsp;</td>
          <td class="paramname"> <em>prdrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an RDR and allocate it a unique ID. </p>
<p>This call registers an RDR as above, but also allocates it a new ID which has not been used within that Class and Type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrtype</em>&nbsp;</td><td>The Type of the RDR.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>prdrid</em>&nbsp;</td><td>A pointer to an RDR ID, or null.</td></tr>
  </table>
  </dd>
</dl>
<p>An unused ID (within this Class and Type) will be allocated and returned if this pointer is not null. If no pointer is provided, an ID is still allocated but is not returned to the provider, so the RDR cannot be deregistered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>A pointer to the start of the data.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>The priority of the registration - usually zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS if the RDR was successfully registered.</dd></dl>
<p>SW_RDR_ERROR is returned in the unlikely event of every ID already having been allocated.</p>
<p>Register an RDR and allocate it a unique ID.</p>
<p>The allocated ID is guaranteed not to match any existing registration. It is returned if required. </p>

</div>
</div>
<a class="anchor" id="gaf0b144b0c1679c5ae1334e9d21324213"></a><!-- doxytag: member="rdrapi.h::register_rdr" ref="gaf0b144b0c1679c5ae1334e9d21324213" args="(sw_rdr_class rdrclass, sw_rdr_type rdrtype, sw_rdr_id rdrid, void *ptr, size_t length, sw_rdr_priority priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api register_rdr </td>
          <td>(</td>
          <td class="paramtype">sw_rdr_class&nbsp;</td>
          <td class="paramname"> <em>rdrclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga69ca376b88b1f5c2975979592b975ee8">sw_rdr_type</a>&nbsp;</td>
          <td class="paramname"> <em>rdrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga399c71b627a20751d4893681abcd9c77">sw_rdr_id</a>&nbsp;</td>
          <td class="paramname"> <em>rdrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__swrdr.html#ga26d85789c6d3fcc64123c7e468b9cec5">sw_rdr_priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an RDR. </p>
<p>This call registers an RDR of a particular Class, Type and ID.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrclass</em>&nbsp;</td><td>The Class of the RDR, as enumerated above.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrtype</em>&nbsp;</td><td>The Type of the RDR.</td></tr>
  </table>
  </dd>
</dl>
<p>RDR Classes are subdivided into Types, which are enumerated elsewhere.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rdrid</em>&nbsp;</td><td>The ID of the RDR within this Class and Type.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ptr</em>&nbsp;</td><td>A pointer to the start of the data.</td></tr>
  </table>
  </dd>
</dl>
<p>This pointer can be null. See below for special behaviour if length is also zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the data.</td></tr>
  </table>
  </dd>
</dl>
<p>This length can be zero. If ptr is NOT null then this delivers a zero-length RDR. This may still be meaningful to the consumer.</p>
<p>If the length is zero AND the ptr is null (and this RDR is the highest priority registration), then any existing RDR of this Class, Type and ID is suppressed and therefore appears to the consumer to be unregistered. Deregistering this RDR will cause the previous registration to reappear.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>The priority of the registration - usually zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Known defaults can be registered with a negative priority such as SW_RDR_DEFAULT. This ensures they are placed *below* any existing definition of the same Class:Type:ID combination (with a higher priority)</p>
<ul>
<li>as though the default registration occured first.</li>
</ul>
<p>Similarly, a positive priority such as SW_RDR_OVERRIDE will remain the definitive registration until a registration at the same or higher priority is made.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS if the RDR was successfully registered.</dd></dl>
<p>Reregistering an existing RDR (with the same parameters including ptr and length) does not produce multiple RDRs - it simply ensures that this RDR definition supersedes any of the same priority.</p>
<p>Register an RDR.</p>
<p>A registration with zero ptr and length suppressed this Class/Type/ID as though nothing has been registered. </p>

</div>
</div>
<a class="anchor" id="gab56f3b0b58c1f18187baffa2e622c657"></a><!-- doxytag: member="rdrapi.h::restart" ref="gab56f3b0b58c1f18187baffa2e622c657" args="(sw_rdr_iterator *iterator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sw_rdr_result HQNCALL rdr_api restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw__rdr__iterator.html">sw_rdr_iterator</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restart an RDR iterator. </p>
<p>This call restarts the find process by returning the iterator to its initial state. It can be called instead of SwFoundRDR() to reuse a persistent iterator. Note that ultimately it is still necessary to call SwFoundRDR() to destroy the iterator. It can be called before SwNextRDR() has exhausted its results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterator</em>&nbsp;</td><td>The iterator to restart.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SW_RDR_SUCCESS, normally; SW_RDR_ERROR_IN_USE if the iterator cannot be restarted because it is threaded; SW_RDR_ERROR_SYNTAX if the iterator is not recognised.</dd></dl>
<p>This automatically unlocks the RDR returned by a call to SwLockNextRDR(). </p>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
