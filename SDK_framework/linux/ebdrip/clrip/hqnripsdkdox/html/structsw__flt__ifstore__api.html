<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sw_flt_ifstore_api Struct Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sw_flt_ifstore_api Struct Reference<br/>
<small>
[<a class="el" href="group__PLUGIN__swflt.html">Image filtering API</a>]</small>
</h1><!-- doxytag: class="sw_flt_ifstore_api" -->
<p>Callback API for image filter store.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;swflt.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a3d5cd5fb34f9b05913e5c79c42a74aa3">if_blockWidth</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a00d98874173563d48cac4e2f7113515e">if_blockHeight</a> )(void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a56626d064a8206e3388a5e0bc87f4b85">if_store_getblock_dims</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *np)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a2dd27d00635f3ddfc0bb997b6a4ffd6f">if_store_hasblock</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a9432757639c2558ed671af0e7a9fa780">if_store_getblock_plane</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a8aa92d90d86ed3fe3d509020eb2f7e67">if_store_block_alloc</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> reuse_blists)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#ad4a51d2664d35739bea7db076c0d1c52">if_store_block_alloc_and_get</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> reuse_blists)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a58a7133f84bee57351d84ff5f763e850">if_store_block_lock</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#afd0211fd4c9521e1ca1d59a0aadaaae2">if_store_block_unlock</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> disposable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#ac565d2f12358461412559a5ddab81c34">if_store_block_free</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *freed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a675df06cd7cf1a73ae2d2e80bafeecbf">if_storefree</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#ade4426164be4d851a47cb850f5b17840">if_have_complete_block</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a8ec2965aa7cb48d2fe085cf9e44937f2">if_have_complete_surrounding_blocks</a> )(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a39d926aa8271daab12453a59a4ed6b8b">if_global_blist_locate</a> )(<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> abytes, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> tbytes, <a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> **pblist, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#aae197a17b47e1010250bd99ddf738a6a">if_release_blist_to_global</a> )(<a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> *blist, <a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> **pblist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a0e9519ddd1977c4ac596b2917440311a">if_find_named_filter</a> )(const <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filter_name, size_t len, <a class="el" href="structsw__flt__api.html">sw_flt_api</a> **api)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a3aa9819898ba26649ce6ed6063d52979">if_allocimageblock</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *im_block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#acd54afeae9151ed3e1b16f20ba4afe09">if_allocplanes</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="structsw__flt__image__plane.html">sw_flt_image_plane</a> **plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a19b4d1a433051475df0ae2bbb8e4d577">if_freeplanes</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *filter_instance, <a class="el" href="structsw__flt__image__plane.html">sw_flt_image_plane</a> *plane)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#aff96f6e45bb372a6cf1c682e4945d39b">if_getblock_dims</a> )(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *filter, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *nx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *ny, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *np)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw__flt__ifstore__api.html#a7f53db78955cd33f0c5ef88513f0e706">if_steal_image_block</a> )(<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *from_filter, <a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *to_filter, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *from_block, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *to_block)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Callback API for image filter store. </p>
<p>The structure <a class="el" href="structsw__flt__ifstore__api.html" title="Callback API for image filter store.">sw_flt_ifstore_api</a> defines the RIP functions that an image filter can call. It's intended that this be fairly static, and changes that are needed be made in a compatible manner. There are more call-backs here than is common with other plug-ins types.</p>
<p>Versioning of this structure is tied to the <a class="el" href="structsw__flt__api.html" title="The definition of an implementation of the image filtering interface.">sw_flt_api</a> version. The RIP expects only callbacks present in the implementation registered to be called. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a3aa9819898ba26649ce6ed6063d52979"></a><!-- doxytag: member="sw_flt_ifstore_api::if_allocimageblock" ref="a3aa9819898ba26649ce6ed6063d52979" args=")(sw_flt_instance *idata, int32 x, int32 y, int32 plane, sw_flt_image_block *im_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a3aa9819898ba26649ce6ed6063d52979">if_allocimageblock</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *im_block)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make sure that we have space allocated for an image block. </p>

</div>
</div>
<a class="anchor" id="acd54afeae9151ed3e1b16f20ba4afe09"></a><!-- doxytag: member="sw_flt_ifstore_api::if_allocplanes" ref="acd54afeae9151ed3e1b16f20ba4afe09" args=")(sw_flt_instance *idata, sw_flt_image_plane **plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__ifstore__api.html#acd54afeae9151ed3e1b16f20ba4afe09">if_allocplanes</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *idata, <a class="el" href="structsw__flt__image__plane.html">sw_flt_image_plane</a> **plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make sure that we have space allocated for the planes in an image block. </p>

</div>
</div>
<a class="anchor" id="a00d98874173563d48cac4e2f7113515e"></a><!-- doxytag: member="sw_flt_ifstore_api::if_blockHeight" ref="a00d98874173563d48cac4e2f7113515e" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a00d98874173563d48cac4e2f7113515e">if_blockHeight</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The standard block height of a block. Individual blocks may be smaller but not larger than this. Normally 128. </p>

</div>
</div>
<a class="anchor" id="a3d5cd5fb34f9b05913e5c79c42a74aa3"></a><!-- doxytag: member="sw_flt_ifstore_api::if_blockWidth" ref="a3d5cd5fb34f9b05913e5c79c42a74aa3" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a3d5cd5fb34f9b05913e5c79c42a74aa3">if_blockWidth</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The standard block width (in bytes not pixels) of a block. Individual blocks may be smaller but not larger than this. Normally 128 bytes. </p>

</div>
</div>
<a class="anchor" id="a0e9519ddd1977c4ac596b2917440311a"></a><!-- doxytag: member="sw_flt_ifstore_api::if_find_named_filter" ref="a0e9519ddd1977c4ac596b2917440311a" args=")(const uint8 *filter_name, size_t len, sw_flt_api **api)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a0e9519ddd1977c4ac596b2917440311a">if_find_named_filter</a>)(const <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> *filter_name, size_t len, <a class="el" href="structsw__flt__api.html">sw_flt_api</a> **api)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a filter, given its name. </p>

</div>
</div>
<a class="anchor" id="a19b4d1a433051475df0ae2bbb8e4d577"></a><!-- doxytag: member="sw_flt_ifstore_api::if_freeplanes" ref="a19b4d1a433051475df0ae2bbb8e4d577" args=")(sw_flt_instance *filter_instance, sw_flt_image_plane *plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__ifstore__api.html#a19b4d1a433051475df0ae2bbb8e4d577">if_freeplanes</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *filter_instance, <a class="el" href="structsw__flt__image__plane.html">sw_flt_image_plane</a> *plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees the data allocated above, the plane may end up on the filter_instance's free_plane list. </p>

</div>
</div>
<a class="anchor" id="aff96f6e45bb372a6cf1c682e4945d39b"></a><!-- doxytag: member="sw_flt_ifstore_api::if_getblock_dims" ref="aff96f6e45bb372a6cf1c682e4945d39b" args=")(sw_flt_instance *filter, int32 *nx, int32 *ny, int32 *np)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__ifstore__api.html#aff96f6e45bb372a6cf1c682e4945d39b">if_getblock_dims</a>)(<a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *filter, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *nx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *ny, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *np)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deterimine the size (in blocks) of the image, and the number of planes. </p>

</div>
</div>
<a class="anchor" id="a39d926aa8271daab12453a59a4ed6b8b"></a><!-- doxytag: member="sw_flt_ifstore_api::if_global_blist_locate" ref="a39d926aa8271daab12453a59a4ed6b8b" args=")(uint32 abytes, uint32 tbytes, sw_flt_blist **pblist, uint8 **rbuf, uint32 *rbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a39d926aa8271daab12453a59a4ed6b8b">if_global_blist_locate</a>)(<a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> abytes, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> tbytes, <a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> **pblist, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locates memory for a block, from the global blist list, or it alloates one if necessary. </p>

</div>
</div>
<a class="anchor" id="ade4426164be4d851a47cb850f5b17840"></a><!-- doxytag: member="sw_flt_ifstore_api::if_have_complete_block" ref="ade4426164be4d851a47cb850f5b17840" args=")(sw_flt_store *ims, int32 x, int32 y, int32 plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#ade4426164be4d851a47cb850f5b17840">if_have_complete_block</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns TRUE/FALSE depending upon us having all the planes of the specified block </p>

</div>
</div>
<a class="anchor" id="a8ec2965aa7cb48d2fe085cf9e44937f2"></a><!-- doxytag: member="sw_flt_ifstore_api::if_have_complete_surrounding_blocks" ref="a8ec2965aa7cb48d2fe085cf9e44937f2" args=")(sw_flt_store *ims, int32 x, int32 y, int32 plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a8ec2965aa7cb48d2fe085cf9e44937f2">if_have_complete_surrounding_blocks</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns TRUE/FALSE depending upon us having all the planes of the specified block AND all the planes of all the blocks touching </p>

</div>
</div>
<a class="anchor" id="aae197a17b47e1010250bd99ddf738a6a"></a><!-- doxytag: member="sw_flt_ifstore_api::if_release_blist_to_global" ref="aae197a17b47e1010250bd99ddf738a6a" args=")(sw_flt_blist *blist, sw_flt_blist **pblist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__ifstore__api.html#aae197a17b47e1010250bd99ddf738a6a">if_release_blist_to_global</a>)(<a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> *blist, <a class="el" href="group__PLUGIN__swflt.html#gaf5d2a08ad22793256b89784ea93e0a1b">sw_flt_blist</a> **pblist)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases a blist back to the global blist list, it also gets removed from pblist. </p>

</div>
</div>
<a class="anchor" id="a7f53db78955cd33f0c5ef88513f0e706"></a><!-- doxytag: member="sw_flt_ifstore_api::if_steal_image_block" ref="a7f53db78955cd33f0c5ef88513f0e706" args=")(int32 x, int32 y, int32 plane, sw_flt_instance *from_filter, sw_flt_instance *to_filter, sw_flt_image_block *from_block, sw_flt_image_block *to_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PLUGIN__swflt.html#ga7a883b0d4ee75974951e13eb1a2f820d">sw_flt_result</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a7f53db78955cd33f0c5ef88513f0e706">if_steal_image_block</a>)(<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *from_filter, <a class="el" href="structsw__flt__instance.html">sw_flt_instance</a> *to_filter, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *from_block, <a class="el" href="structsw__flt__image__block.html">sw_flt_image_block</a> *to_block)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a routine that's intended to be used by filters that don't modify image data. </p>

</div>
</div>
<a class="anchor" id="a8aa92d90d86ed3fe3d509020eb2f7e67"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_block_alloc" ref="a8aa92d90d86ed3fe3d509020eb2f7e67" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane, HqBool reuse_blists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a8aa92d90d86ed3fe3d509020eb2f7e67">if_store_block_alloc</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> reuse_blists)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes sure that memory is allocated for the specified block/plane. </p>

</div>
</div>
<a class="anchor" id="ad4a51d2664d35739bea7db076c0d1c52"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_block_alloc_and_get" ref="ad4a51d2664d35739bea7db076c0d1c52" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane, uint8 **rbuf, uint32 *rbytes, HqBool reuse_blists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#ad4a51d2664d35739bea7db076c0d1c52">if_store_block_alloc_and_get</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> reuse_blists)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes sure that memory is allocated for the specified block/plane, and then returns the data in rbuf/rbytes. You would use this method for creating a new block, and use <a class="el" href="structsw__flt__ifstore__api.html#a9432757639c2558ed671af0e7a9fa780">if_store_getblock_plane()</a> to get the data from an existing block. </p>

</div>
</div>
<a class="anchor" id="ac565d2f12358461412559a5ddab81c34"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_block_free" ref="ac565d2f12358461412559a5ddab81c34" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane, HqBool *freed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#ac565d2f12358461412559a5ddab81c34">if_store_block_free</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> *freed)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees the memory allocated for the block/plane </p>

</div>
</div>
<a class="anchor" id="a58a7133f84bee57351d84ff5f763e850"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_block_lock" ref="a58a7133f84bee57351d84ff5f763e850" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a58a7133f84bee57351d84ff5f763e850">if_store_block_lock</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks the block (so it won't get disposed of or moved). It also increments a reference count on the block. </p>

</div>
</div>
<a class="anchor" id="afd0211fd4c9521e1ca1d59a0aadaaae2"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_block_unlock" ref="afd0211fd4c9521e1ca1d59a0aadaaae2" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane, HqBool disposable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#afd0211fd4c9521e1ca1d59a0aadaaae2">if_store_block_unlock</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> disposable)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrements the reference count on the block/plane and if the ref count goes to zero it then unlocks the block. </p>

</div>
</div>
<a class="anchor" id="a56626d064a8206e3388a5e0bc87f4b85"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_getblock_dims" ref="a56626d064a8206e3388a5e0bc87f4b85" args=")(sw_flt_store *ims, int32 *x, int32 *y, int32 *np)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__ifstore__api.html#a56626d064a8206e3388a5e0bc87f4b85">if_store_getblock_dims</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> *np)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of the image store (in blocks x by y), and the number of planes (colorants) in the image. </p>

</div>
</div>
<a class="anchor" id="a9432757639c2558ed671af0e7a9fa780"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_getblock_plane" ref="a9432757639c2558ed671af0e7a9fa780" args=")(sw_flt_store *ims, int32 bx, int32 by, int32 plane, uint8 **rbuf, uint32 *rbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a9432757639c2558ed671af0e7a9fa780">if_store_getblock_plane</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> bx, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> by, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane, <a class="el" href="group__stdtypes.html#ga3c77e3a247345b581bdb6939ffe95a94">uint8</a> **rbuf, <a class="el" href="group__stdtypes.html#ga8ad23e2333787a214e20a58a284a5a60">uint32</a> *rbytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the data for a single plane of an image block. rbuf will point to the data, and it'll be rbytes long. Note, make sure that the store has the data (use <a class="el" href="structsw__flt__ifstore__api.html#a2dd27d00635f3ddfc0bb997b6a4ffd6f">if_store_hasblock()</a> above) before calling this method. </p>

</div>
</div>
<a class="anchor" id="a2dd27d00635f3ddfc0bb997b6a4ffd6f"></a><!-- doxytag: member="sw_flt_ifstore_api::if_store_hasblock" ref="a2dd27d00635f3ddfc0bb997b6a4ffd6f" args=")(sw_flt_store *ims, int32 x, int32 y, int32 plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>( * <a class="el" href="structsw__flt__ifstore__api.html#a2dd27d00635f3ddfc0bb997b6a4ffd6f">if_store_hasblock</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> x, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> y, <a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> plane)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns TRUE/FALSE depending on if the store has all the specified planes for the specified block. </p>

</div>
</div>
<a class="anchor" id="a675df06cd7cf1a73ae2d2e80bafeecbf"></a><!-- doxytag: member="sw_flt_ifstore_api::if_storefree" ref="a675df06cd7cf1a73ae2d2e80bafeecbf" args=")(sw_flt_store *ims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void( * <a class="el" href="structsw__flt__ifstore__api.html#a675df06cd7cf1a73ae2d2e80bafeecbf">if_storefree</a>)(<a class="el" href="group__PLUGIN__swflt.html#ga92f1aa6492063d80eb92503cd36e1a7a">sw_flt_store</a> *ims)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees the memory allocated for the image store </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="swflt_8h.html">swflt.h</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
