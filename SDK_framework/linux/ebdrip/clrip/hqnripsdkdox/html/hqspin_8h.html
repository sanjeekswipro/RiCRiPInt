<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: hqspin.h File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_9f69e5f1ce79f527fb07efef95800849.html">standard</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_e271fd8159723d90b7e0fb7f56e944fe.html">export</a>
  </div>
</div>
<div class="contents">
<h1>hqspin.h File Reference</h1>
<p>Spinlocks implemented using operations.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="platform_8h.html">platform.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hqatomic_8h.html">hqatomic.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6de15a66b906777dcd89a447a6309f0b"></a><!-- doxytag: member="hqspin.h::yield_processor" ref="a6de15a66b906777dcd89a447a6309f0b" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a6de15a66b906777dcd89a447a6309f0b">yield_processor</a>()&nbsp;&nbsp;&nbsp;EMPTY_STATEMENT()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the processor to another thread, if there is one runnable. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a07386be361e59f4a57cc384293fc12c3">spinlock_pointer</a>(addr_, locked_, count_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a pointer using atomic operations.  <a href="#a07386be361e59f4a57cc384293fc12c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a61d3f563493b39594d08fd340801dfcc">spintrylock_pointer</a>(addr_, locked_, didlock_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock a pointer using atomic operations.  <a href="#a61d3f563493b39594d08fd340801dfcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a2124381fd48995a91d451f4ef4fbf457">spinunlock_pointer</a>(addr_, unlocked_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a pointer using atomic operations.  <a href="#a2124381fd48995a91d451f4ef4fbf457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#ad18548a0bfdf818d8544f77b7ea7d9d9">spinlock_counter</a>(addr_, count_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a counter semaphore using atomic operations.  <a href="#ad18548a0bfdf818d8544f77b7ea7d9d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a4d689d9c88021f68fc13ddf5fac2e304">spinunlock_counter</a>(addr_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a semaphore counter using atomic operations.  <a href="#a4d689d9c88021f68fc13ddf5fac2e304"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a845fa586addd78d8f810641ef8453b40"></a><!-- doxytag: member="hqspin.h::spinlock_void_ptr" ref="a845fa586addd78d8f810641ef8453b40" args="" -->
typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40">spinlock_void_ptr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="hqspin_8h.html#a68c01102755fc7d1c810bb0b0635fa90af57844805cc93244c8230766965cf030">HQSPIN_YIELD_NEVER</a> =  0, 
<a class="el" href="hqspin_8h.html#a68c01102755fc7d1c810bb0b0635fa90a1a6d064a992e80adba200ebce672bb42">HQSPIN_YIELD_ALWAYS</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for yields per spinlock cycle. </p>
 <a href="hqspin_8h.html#a68c01102755fc7d1c810bb0b0635fa90">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Spinlocks implemented using operations. </p>
<dl class="rcs"><dt><b>HopeName</b></dt><dd>HQNc-standard!export:<a class="el" href="hqspin_8h.html" title="Spinlocks implemented using operations.">hqspin.h</a>(EBDSDK_P.1) </dd></dl>
<p>Copyright (C) 2011-2012 Global Graphics Software Ltd. All rights reserved. This source code contains the confidential and trade secret information of Global Graphics Software Ltd. It may not be used, copied or distributed for any reason except as set forth in the applicable Global Graphics license agreement.</p>
<p>These spinlocks are implemented in a separate file because they include platform-specific header files to yield the processor in the event of a contended spinlock </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ad18548a0bfdf818d8544f77b7ea7d9d9"></a><!-- doxytag: member="hqspin.h::spinlock_counter" ref="ad18548a0bfdf818d8544f77b7ea7d9d9" args="(addr_, count_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define spinlock_counter</td>
          <td>(</td>
          <td class="paramtype">addr_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START                     \
  <span class="keywordflow">for</span> (;;) {                                                            \
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _count_ = (count_) ;                                   \
    <a class="code" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7" title="Hqn standard boolean type.">HqBool</a> _didcas_ ;                                                   \
    <span class="keywordflow">do</span> {                                                                \
      HqAtomicCAS((addr_), 0, 1, _didcas_) ;                            \
    } <span class="keywordflow">while</span> ( !_didcas_ &amp;&amp; --_count_ != 0 ) ;                           \
    <span class="keywordflow">if</span> ( _didcas_ )                                                     \
      break ;                                                           \
    <a class="code" href="hqspin_8h.html#a6de15a66b906777dcd89a447a6309f0b" title="Yield the processor to another thread, if there is one runnable.">yield_processor</a>() ;                                                 \
  }                                                                     \
MACRO_END
</pre></div>
<p>Lock a counter semaphore using atomic operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>addr_</em>&nbsp;</td><td>The address of the counter to lock. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count_</em>&nbsp;</td><td>Number of spin cycles before each processor yield.</td></tr>
  </table>
  </dd>
</dl>
<p>Semaphore counters are locked when non-zero, unlocked when zero. <code>spinlock_counter</code> will wait until a counter is zero, and lock it using the value 1. The semaphore counter may be test-locked by using an atomic increment, testing if the value before increment was zero, and decrementing the semaphore to release it. </p>

</div>
</div>
<a class="anchor" id="a07386be361e59f4a57cc384293fc12c3"></a><!-- doxytag: member="hqspin.h::spinlock_pointer" ref="a07386be361e59f4a57cc384293fc12c3" args="(addr_, locked_, count_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define spinlock_pointer</td>
          <td>(</td>
          <td class="paramtype">addr_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">locked_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START            \
  <a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a> *_addr_ = (<a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a> *)(addr_) ;            \
  <span class="keywordtype">void</span> *_result_, *_swapfor_ ;                                          \
  HQASSERT(<span class="keyword">sizeof</span>(**(addr_)) &gt; 1 &amp;&amp; <span class="keyword">sizeof</span>(**(addr_)) == <span class="keyword">sizeof</span>(*(locked_)), \
           <span class="stringliteral">&quot;Spinlock pointer type alignment invalid&quot;</span>) ;                 \
  <span class="keywordflow">for</span> (;;) {                                                            \
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _count_ = (count_) ;                                   \
    <a class="code" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7" title="Hqn standard boolean type.">HqBool</a> _didcas_ ;                                                   \
    <span class="keywordflow">do</span> {                                                                \
      _result_ = (<span class="keywordtype">void</span> *)((intptr_t)*(_addr_) &amp; ~(intptr_t)1) ;         \
      _swapfor_ = (<span class="keywordtype">void</span> *)((intptr_t)_result_ | 1) ;                    \
      HqAtomicCASPointer(_addr_, _result_, _swapfor_, _didcas_, <a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a>) ; \
    } <span class="keywordflow">while</span> ( !_didcas_ &amp;&amp; --_count_ != 0 ) ;                           \
    <span class="keywordflow">if</span> ( _didcas_ )                                                     \
      break ;                                                           \
    <a class="code" href="hqspin_8h.html#a6de15a66b906777dcd89a447a6309f0b" title="Yield the processor to another thread, if there is one runnable.">yield_processor</a>() ;                                                 \
  }                                                                     \
  locked_ = _result_ ;                                                  \
MACRO_END
</pre></div>
<p>Lock a pointer using atomic operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>addr_</em>&nbsp;</td><td>The address of the pointer to lock. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locked_</em>&nbsp;</td><td>The pointer value to dereference in the locked section. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count_</em>&nbsp;</td><td>Number of spin cycles before each processor yield.</td></tr>
  </table>
  </dd>
</dl>
<p><code>spinlock_pointer</code> uses the lowest bit as lock mark, so is only valid for halfword or greater aligned pointers. It modifies the stored value of the pointer in memory, and loads a dereferencable version of the pointer into a variable. Within the locked section, code must use the dereferencable version of the pointer, and not re-load the original pointer from memory. </p>

</div>
</div>
<a class="anchor" id="a61d3f563493b39594d08fd340801dfcc"></a><!-- doxytag: member="hqspin.h::spintrylock_pointer" ref="a61d3f563493b39594d08fd340801dfcc" args="(addr_, locked_, didlock_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define spintrylock_pointer</td>
          <td>(</td>
          <td class="paramtype">addr_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">locked_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">didlock_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START       \
  <a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a> *_addr_ = (<a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a> *)(addr_) ;            \
  <span class="keywordtype">void</span> *_result_, *_swapfor_ ;                                          \
  HQASSERT(<span class="keyword">sizeof</span>(**(addr_)) &gt; 1 &amp;&amp; <span class="keyword">sizeof</span>(**(addr_)) == <span class="keyword">sizeof</span>(*(locked_)), \
           <span class="stringliteral">&quot;Spinlock pointer type alignment invalid&quot;</span>) ;                 \
  _result_ = (<span class="keywordtype">void</span> *)((intptr_t)*(_addr_) &amp; ~(intptr_t)1) ;             \
  _swapfor_ = (<span class="keywordtype">void</span> *)((intptr_t)_result_ | 1) ;                        \
  HqAtomicCASPointer(_addr_, _result_, _swapfor_, didlock_, <a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a>) ; \
  <span class="keywordflow">if</span> ( didlock_ )                                                       \
    locked_ = _result_;                                                 \
MACRO_END
</pre></div>
<p>Try to lock a pointer using atomic operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>addr_</em>&nbsp;</td><td>The address of the pointer to lock. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locked_</em>&nbsp;</td><td>The pointer value to dereference in the locked section, only set if <code>didlock_</code> is <code>TRUE</code>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>didlock_</em>&nbsp;</td><td>A Boolean to indicate if managed to lock.</td></tr>
  </table>
  </dd>
</dl>
<p>This is like <code>spinlock_pointer</code>, except that it doesn't spin if it can't get the lock, it just returns. </p>

</div>
</div>
<a class="anchor" id="a4d689d9c88021f68fc13ddf5fac2e304"></a><!-- doxytag: member="hqspin.h::spinunlock_counter" ref="a4d689d9c88021f68fc13ddf5fac2e304" args="(addr_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define spinunlock_counter</td>
          <td>(</td>
          <td class="paramtype">addr_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START                           \
  hq_atomic_counter_t _after_ ;                                         \
  HqAtomicDecrement((addr_), _after_) ;                                 \
  HQASSERT(_after_ &gt;= 0, <span class="stringliteral">&quot;Counter semaphore was not locked&quot;</span>) ;          \
MACRO_END
</pre></div>
<p>Unlock a semaphore counter using atomic operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addr_</em>&nbsp;</td><td>The address of the counter to unlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2124381fd48995a91d451f4ef4fbf457"></a><!-- doxytag: member="hqspin.h::spinunlock_pointer" ref="a2124381fd48995a91d451f4ef4fbf457" args="(addr_, unlocked_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define spinunlock_pointer</td>
          <td>(</td>
          <td class="paramtype">addr_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unlocked_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">MACRO_START                \
  Bool _didcas_ ;                                                       \
  HQASSERT(<span class="keyword">sizeof</span>(**(addr_)) &gt; 1, <span class="stringliteral">&quot;Spinlock pointer type alignment invalid&quot;</span>) ; \
  HQASSERT(((intptr_t)*(addr_) &amp; 1) != 0, <span class="stringliteral">&quot;Pointer is not currently locked&quot;</span>) ; \
  <span class="comment">/* Need a release barrier to prevent compiler optimising over the unlock. */</span> \
  HqAtomicCASPointer(addr_, *(addr_), unlocked_, _didcas_, <a class="code" href="hqspin_8h.html#a845fa586addd78d8f810641ef8453b40" title="Aliased void pointer, to quieten GCC warnings and prevent harmful optimisations.">spinlock_void_ptr</a>) ; \
  HQASSERT(_didcas_, <span class="stringliteral">&quot;Failed to unlock spinlock&quot;</span>) ;                     \
MACRO_END
</pre></div>
<p>Unlock a pointer using atomic operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addr_</em>&nbsp;</td><td>The address of the pointer to unlock. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unlocked_</em>&nbsp;</td><td>The new value of the unlocked pointer.</td></tr>
  </table>
  </dd>
</dl>
<p><code>spinunlock_pointer</code> unlocks a pointer that was locked using <code>spinlock_pointer</code>. The lowest bit of the pointer is used as lock mark, so this is only valid for halfword or greater aligned pointers. The new value of the unlocked pointer will usually be the dereferencable pointer value saved by <code>spinlock_pointer</code>, but it may also be a different pointer of the correct type. This can be used to safely replace objects, by locking the only pointer reference to the object, but unlocking with NULL or a different object pointer. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a68c01102755fc7d1c810bb0b0635fa90"></a><!-- doxytag: member="hqspin.h::@72" ref="a68c01102755fc7d1c810bb0b0635fa90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constants for yields per spinlock cycle. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a68c01102755fc7d1c810bb0b0635fa90af57844805cc93244c8230766965cf030"></a><!-- doxytag: member="HQSPIN_YIELD_NEVER" ref="a68c01102755fc7d1c810bb0b0635fa90af57844805cc93244c8230766965cf030" args="" -->HQSPIN_YIELD_NEVER</em>&nbsp;</td><td>
<p>Practically never yield processor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a68c01102755fc7d1c810bb0b0635fa90a1a6d064a992e80adba200ebce672bb42"></a><!-- doxytag: member="HQSPIN_YIELD_ALWAYS" ref="a68c01102755fc7d1c810bb0b0635fa90a1a6d064a992e80adba200ebce672bb42" args="" -->HQSPIN_YIELD_ALWAYS</em>&nbsp;</td><td>
<p>Yield processor every spinlock cycle. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
