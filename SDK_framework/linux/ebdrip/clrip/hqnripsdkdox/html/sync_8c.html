<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->
<!-- $HopeName: SWprod_hqnrip!clrip:branding:lekit-header.html(EBDSDK_P.1) $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"> <title>Harlequin RIP SDK: sync.c File Reference</title> <h5 style="align: right;"><a href="http://www.globalgraphics.com" target="_blank"><img src="./gg_logo.gif" alt="Global Graphics logo" align="middle" border=0></a><img src="./spacer.gif">Harlequin RIP SDK Documentation</h5> <link href="doxygen.css" rel="stylesheet" type="text/css"> </head> </html> 
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_19043388fc15ddb67e28f7a33621a223.html">skinkit</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_1a92abee00141eb4bc1b55dcfd46ed15.html">src</a>
  </div>
</div>
<div class="contents">
<h1>sync.c File Reference</h1>
<p>Synchronization between the application calling thread and the thread that is running the RIP. Having this synchronization simplifies the application code because it doesn't need to worry about callbacks on the monitor or raster functions happening asynchronously - they will only happen when the application has called into one of the SwLe functions and is blocked waiting for the result.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="sync_8h.html">sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem_8h.html">mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ripthread_8h.html">ripthread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="threadapi_8h.html">threadapi.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7deb51b3632f37291001c7ed3c53ad95"></a><!-- doxytag: member="sync.c::StartRipWrapper" ref="a7deb51b3632f37291001c7ed3c53ad95" args="(void *unused)" -->
static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#a7deb51b3632f37291001c7ed3c53ad95">StartRipWrapper</a> (void *unused)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to call <a class="el" href="ripthread_8c.html#ac3b6fa6a5883ff25afb6ccbab0f5c326" title="Sets up the environment for SwDllStart() and then calls it.">StartRip()</a> so we have the correct prototype for the thread starting functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#a2abf324729c7a1c7a544100edc00a8f6">StartRIPOnNewThread</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread and then call the function StartRip (defined in <a class="el" href="ripthread_8c.html" title="Example implementation of corerip integration: Starting the RIP.">ripthread.c</a>).  <a href="#a2abf324729c7a1c7a544100edc00a8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf30117e0a5bba5dd71f5816ed32f9a1"></a><!-- doxytag: member="sync.c::WaitForRIPThreadToExit" ref="adf30117e0a5bba5dd71f5816ed32f9a1" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#adf30117e0a5bba5dd71f5816ed32f9a1">WaitForRIPThreadToExit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the RIP thread to exit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#a7bb09f01c8d00913e77d74e8c4d03e8d">PKCreateSemaphore</a> (<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a> initialValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a semaphore with an initial value.  <a href="#a7bb09f01c8d00913e77d74e8c4d03e8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63c7b20a55126ae33e90a1f036cda8c9"></a><!-- doxytag: member="sync.c::PKSignalSemaphore" ref="a63c7b20a55126ae33e90a1f036cda8c9" args="(void *semaHandle)" -->
<a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#a63c7b20a55126ae33e90a1f036cda8c9">PKSignalSemaphore</a> (void *semaHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If any threads are blocked on PKWaitOnSemaphore, then wake them up. Otherwise increment the value of the semaphore. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e14c1074a81a7f2b549be2261808aa7"></a><!-- doxytag: member="sync.c::PKDestroySemaphore" ref="a4e14c1074a81a7f2b549be2261808aa7" args="(void *semaHandle)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#a4e14c1074a81a7f2b549be2261808aa7">PKDestroySemaphore</a> (void *semaHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free up the resources associated with the semaphore. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e3d16e82af5f170d84033b0d11e5e3"></a><!-- doxytag: member="sync.c::PKSemaFinish" ref="af8e3d16e82af5f170d84033b0d11e5e3" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync_8c.html#af8e3d16e82af5f170d84033b0d11e5e3">PKSemaFinish</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish semaphore module, free up resources for remaining semaphores. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Synchronization between the application calling thread and the thread that is running the RIP. Having this synchronization simplifies the application code because it doesn't need to worry about callbacks on the monitor or raster functions happening asynchronously - they will only happen when the application has called into one of the SwLe functions and is blocked waiting for the result. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7bb09f01c8d00913e77d74e8c4d03e8d"></a><!-- doxytag: member="sync.c::PKCreateSemaphore" ref="a7bb09f01c8d00913e77d74e8c4d03e8d" args="(int32 initialValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PKCreateSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__stdtypes.html#gada104807b93ac7cd59dac80d98ba857b">int32</a>&nbsp;</td>
          <td class="paramname"> <em>initialValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a semaphore with an initial value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL if this failed, otherwise a platform-dependent handle to the semaphore. </dd></dl>

</div>
</div>
<a class="anchor" id="a2abf324729c7a1c7a544100edc00a8f6"></a><!-- doxytag: member="sync.c::StartRIPOnNewThread" ref="a2abf324729c7a1c7a544100edc00a8f6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stdtypes.html#ga647554e4db926121141b7e831337adf7">HqBool</a> StartRIPOnNewThread </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a thread and then call the function StartRip (defined in <a class="el" href="ripthread_8c.html" title="Example implementation of corerip integration: Starting the RIP.">ripthread.c</a>). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the thread was created successfully. </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;">
<!-- $HopeName: SWprod_hqnrip!clrip:branding:footer.html(EBDSDK_P.1) $ -->
<!-- Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. -->
<!-- Global Graphics Software Ltd. Confidential Information. -->

<i><small>For information on other products from Global Graphics, visit <a href="http://www.globalgraphics.com" target="_blank">www.globalgraphics.com</a></small></i></address>
</body>
</html>
