# Copyright (C) 1999-2011 Global Graphics Software Ltd. All rights reserved.
# Global Graphics Software Ltd. Confidential Information.
#
# Java compilation rules.
#
# $HopeName: HQNjambits!comprule:java.jam(EBDSDK_P.1) $
#

#
# The jar file contents targets are somewhat complicated.  This is
# because we have to delete the entire contents of the jar file before
# recreating them, but the deletion in the first place depends on
# whether the contents need updating.
#
# In order to get around this, we separate the normal dependency of
# source <- target by inserting the "start the jar file contents" target
# between the two.  If we regard "source" and "target" as being two such
# targets that require building as part of the jar file contents,
# "foo.jar.cont", then we introduce three additional targets,
# "foo.jar.cont.ts", "foo.jar.cont.start" and "foo.jar.cont.finish",
# with the following dependencies:
#
# source* <- foo.jar.cont.ts <- foo.jar.cont.start <- target* <- foo.jar.cont.finish
#
# foo.jar.cont.ts is a file that is actually created by
# foo.jar.cont.finish, and is used as a timestamp for jam to determine
# when the contents need updating (due to the dependency between the
# first two targets in the chain).  It's actual updating actions are
# empty, since the timestamp isn't created at this point.  The .start
# target is responsible for deleting the .cont directory, and recreating
# it.  After all the "target"s have been updated, foo.jar.cont.finish is
# built, which actually produces the .ts file.
#
# As far as the contributing rules are concerned, they just call
# "Java-JarContents", which sets up the dependency framework and the
# additional targets.
#

##############################
# Low-level updating actions #
##############################

# Note that $(Manifest) usually is not set
actions quietly together _Java-Jar bind Manifest {
echo ...MAKING $(<)...
$(SetEnv)$(ENV)$(NewLine)
$(ChDir) $(contents)
$(Jj) $(BUILDROOT)$/$(<) $(Manifest) .
$(ChDir) $(BUILDROOT)
}

actions quietly together _Java-Jar.cont.start {
echo ...BUILDING CONTENTS OF $(jar:BS)...
$(Erase) $(contents) $(DiscardStdErr)
$(MkDir) $(contents)
}
actions quietly together _Java-Jar.cont.finish bind ts {
echo This is a timestamp file autogenerated by the Jam Doughnut >$(ts)
}

# Bind the jars we need to compile, instead of guessing the paths when
# we encounter the rule to compile.  This means that we need to join
# them together with SPLITPATH in the actions.  For UNIX we can do this
# with a bit of shell hackery:
if $(UNIX) || $(MACOSX) {
    actions quietly together _Java-Javac bind ResponseFile Java-UsesJar {
$(SetEnv)$(ENV)$(NewLine)
$(javac) -classpath `$(Perl) -e '{print join("$(SPLITPATH)",@ARGV)}' $(Java-UsesJar) $(fixedcp) ` -d $(dir) @$(ResponseFile)
    }
}
# But not for NT.  Instead, use a sequence of echo
# commands that accumulate into a batch file
if $(NT) {
    actions quietly together _Java-Javac bind ResponseFile Java-UsesJar {
$(SetEnv)$(ENV)$(NewLine)
echo %CLASSPATH% > buildclasslist.tmp
echo $(SPLITPATH)$(Java-UsesJar) >> buildclasslist.tmp
echo $(SPLITPATH)$(fixedcp) >> buildclasslist.tmp
$(Perl) -ne "chop;s/\s//g;print;" buildclasslist.tmp > buildclasspath.tmp
$(javac) -d $(dir) @$(ResponseFile) -classpath @buildclasspath.tmp && $(Erase) buildclasspath.tmp buildclasslist.tmp
    }
}

actions quietly _Java-CopyJavacOut bind ts {
$(Copy) "$(ts:S=)" "$(dest)"
}

actions quietly _Java-UnJar {
echo ..... Un-jar $(>)
$(SetEnv)$(ENV)$(NewLine)
$(ChDir) $(dest)
$(unjar) $(BUILDROOT)$/$(>)
$(ChDir) $(BUILDROOT)
}
actions quietly _Java-UnJar-Absolute {
echo ..... Un-jar $(>)
$(SetEnv)$(ENV)$(NewLine)
$(ChDir) $(dest)
$(unjar) $(>)
$(ChDir) $(BUILDROOT)
}

actions quietly _Java-UnJar-Unwanted {
echo ..... Un-jar $(>)
$(SetEnv)$(ENV)$(NewLine)
$(ChDir) $(dest)
$(unjar) $(BUILDROOT)$/$(>)
echo ..... Erase unwanted files $(unwanted)
$(Erase) $(unwanted)
$(ChDir) $(BUILDROOT)
}
actions quietly _Java-UnJar-Absolute-Unwanted {
echo ..... Un-jar $(>)
$(SetEnv)$(ENV)$(NewLine)
$(ChDir) $(dest)
$(unjar) $(>)
echo ..... Erase unwanted files $(unwanted)
$(Erase) $(unwanted)
$(ChDir) $(BUILDROOT)
}

actions quietly together _Jar-AddFile {
$(Copy) "$(>)" "$(dest)"
}


#####################


actions quietly _searchClassFiles
{
  echo ... Searching for $(searchFor) in $(classFileDir:BS) ...
  $(Perl) $(HQNbuildtools)$/searchClassFiles.pl $(searchFor) $(classFileDir)
}

# $(1) jar file whose contents are to be searched
# $(2) target that will depend on the search (no extra grist will be added)
# $(3) text to search for
rule SearchClassFiles
{
  local jar ; MakeGristed jar : $(1) : $(CurrentPath) ;
  local dir ; MakePath dir : $(CurrentPath) $(JavacOutput-Directory) ;
  local cont = $(dir)$/$(jar:BS).cont ;

  local SearchTarget ;
  MakeGristed SearchTarget : $(1) : $(CurrentPath)-SearchClassFiles ;
  NOTFILE $(SearchTarget) ;
  FloatingDepends $(SearchTarget) ;

  DEPENDS $(SearchTarget) : $(jar) ;
  DEPENDS $(2) : $(SearchTarget) ;

  searchFor on $(SearchTarget) = $(3) ;
  classFileDir on $(SearchTarget) = $(cont) ;

  _searchClassFiles $(SearchTarget) ;
}

# $(1) jar file or files whose contents are to be searched
# $(2) target that will depend on the search (no extra grist will be added)
rule CheckHQNdebugMisuse
{
  if ( $(RELEASE) = 1 )
  {
    for i in $(1)
    {
      SearchClassFiles $(i) : $(2) : com/harlequin/HQNdebug ;
    }
  }
}

######################
# Intermediate rules #
######################

#* Create Java Jar archive from directory.
#*
#* $(1) jar-file
#* $(2) contents-directory
#* $(3) optional manifest file gristed target
#*
#*eg.  Java-Jar <jar> : <contentsdirectory> [ : <manifesttarget> ] ;
#*
#*section Java
    rule Java-Jar {
        local jar ; MakeGristed jar : $(1) : $(CurrentPath) ;
        local contents = $(2) ;

        # Since the .jar file is going at the top-level directory, make the
        # target equally accessible from there.
        local RootTarget = $(jar:G=$(Dot)) ;
        TargetFile-$(RootTarget) = $(jar) ;
        TargetFile-$(jar) = $(jar) ;
        if $(RootTarget) != $(jar) {
            DEPENDS $(RootTarget) : $(jar) ;
            NOTFILE $(RootTarget) ;
        }

        # Set the platform this is for
        TargetPlatform-$(RootTarget) = all all ;
        TargetPlatform-$(jar)        = all all ;
 
        DirectoryFor $(jar) : $(Dot) $(JarOutput-Directory) ;
        $(jar:B)-Jar-Output-Directory =  $(JarOutput-Directory) ;

        ENV on $(jar) = $(Java-Compiler_Environment) ;
        if $(3) {
          Jj on $(jar) = $(Java-Jar:B) $(Java-JarManifest_Arguments) ;
          Manifest on $(jar) = $(3) ;
        } else {
          Jj on $(jar) = $(Java-Jar:B) $(Java-Jar_Arguments) ;
        }
        contents on $(jar) = $(contents) ;

        _Java-Jar $(jar) ;
    }

#* In the above description of jar file contents, add <em>source</em> and
#* corresponding <em>target</em>.  If contdirvarname is supplied, the directory
#* to place jar file contents in is assigned to that variable.
#*
#* $(1) jar-file
#* $(2) gristed source
#* $(3) gristed target
#* [$(4)] contdirvarname
#* [$(5)] optional manifest file gristed target
#*
#*eg. Java-JarContents <jar> : <gristedsource> : <gristedtarget> [ : <contdirvarname> ] : [ <manifesttarget> ] ;
#*
#*section Java
    rule Java-JarContents {
        local jar ; MakeGristed jar : $(1) : $(CurrentPath) ;
        local source = $(2) ; local target = $(3) ;
        local ts = $(jar).cont.ts ;
        local start = $(jar).cont.start ; local finish = $(jar).cont.finish ;

        local dir ; MakePath dir : $(CurrentPath) $(JavacOutput-Directory) ;
        local cont = $(dir)$/$(jar:BS).cont ;
        if $(4) { $(4) = $(cont) ; }

        DirectoryFor $(ts) : $(dir) ;

        contents on $(start) = $(cont) ; jar on $(start) = $(jar) ;
        ts on $(finish) = $(ts) ;

        NOTFILE $(start) $(finish) ;

        DEPENDS $(ts) : $(source) ;     no-op $(ts) ;
        DEPENDS $(start) : $(ts) ;      _Java-Jar.cont.start  $(start) ;
        DEPENDS $(target) : $(start) ;
        DEPENDS $(finish) : $(target) ; _Java-Jar.cont.finish $(finish) ;
        DEPENDS $(jar) : $(finish) ;    Java-Jar $(jar) : $(cont) : $(5) ;

        # "Pretend" top-level jar targets:
        if $(finish:G=$(Dot)) != $(finish) {
          DEPENDS $(finish:G=$(Dot)) : $(finish) ; NOTFILE $(finish:G=$(Dot)) ;
        }
    }


# See Java-Document
actions quietly together _Java-Document bind ResponseFile {
echo ...BUILDING JAVA DOCUMENTATION...
$(SetEnv)$(ENV)$(NewLine)
$(Erase) $(targetdir) $(DiscardStdErr)
$(MkDir) $(targetdir)
$(Jd) -d $(targetdir) @$(ResponseFile) && echo This is a timestamp file autogenerated by the Jam Doughnut >$(<)
}

# See Java-CheckStyle
#
# TODO : This is done with "ignore" so that errors reported by the checker do not
# abort the build. Unfortunately, this also means that the build will carry on happily
# if the CheckStyle process fails. Maybe do something better later.
#
actions quietly ignore _Java-CheckStyle
{
echo ...CHECKING JAVA CODE STYLE IN $(scanDir)...
$(Erase) $(targetDir) $(DiscardStdErr)
$(MkDir) $(targetDir)
$(JCS) -o $(logFile) -r $(scanDir)
}

####
#* A rule for executing the javadoc compiler on gristed source and target.
#*
#* $(1) target
#* $(2) gristed source
#* $(3) directory
#*
#*section Java
    rule Java-Javadoc {
        CheckGristed $(>) ; FloatingDepends $(<) ; DEPENDS $(<) : $(>) ;
        NOTFILE $(<) ;
        ALWAYS $(<) ;

        Dir on $(<) = $(3) ;
        ENV on $(<) = $(Java-Compiler_Environment) ;
        Jd  on $(<) = $(Javadoc-Compiler:B) $(Javadoc-Compiler_Arguments) ;

        local SourcePath ; Join SourcePath : $(SPLITPATH) : $(>) ;
        SourcePath on $(<) = "-sourcepath "$(SourcePath) ;
    }
if $(SWIGVERSION) = 2.2.5.1 { PackageNames = $(HQNbuildtools)$(FS)PackageNames.pl ; }
else                        { PackageNames = $(HQNbuildtools)$/PackageNames.pl ;    }
    actions quietly together Java-Javadoc {
echo ...BUILDING DOCUMENTATION $(Dir)...
$(SetEnv)$(ENV)$(NewLine)
$(Erase) $(Dir) $(DiscardStdErr)
$(MkDir) $(Dir)
$(HqmakePerl) $(PackageNames) $(>) > $(Dir)$(FS)javapacks.src && $(Jd) $(Javadoc-ExtraArgs) -d $(Dir) $(SourcePath) @$(Dir)$(FS)javapacks.src && $(Erase) $(Dir)$(FS)javapacks.src
    }

#############
# Interface #
#############

#*  Rule for saying that a particular target requires the presence of
#*  a particular Java extension in the extensions directory of the JDK being
#*  used. If the extension is not present, a warning message is produced.
#
#*  Note that the target is assumed to be gristed already, if it needs to be.
#*  This means that you can specify <em>all</em> as the target, for instance. But it
#*  is likely to be better to specify the target that really uses the extension.
#*
#* $(1) target
#* $(2) extension filename
#*
#*eg.      Java-Require-Extension <target> : <extension file name> ;
#*
#*section Java

    rule Java-Require-Extension
    {
        if ! $(Java-Jdk-Extensions) {
          Error Java extension(s) are required but JDK extensions directory is
                not known (extensions are unavailable on JDK 1.1) ;
        }

        local curExt extTarget ;
        for curExt in $(2)
        {
          MakeGristed extTarget : $(curExt) : $(Java-Jdk-Extensions) ;
          Message $(extTarget) : WARNING - required Java extension $(curExt)
                                 not found in $(Java-Jdk-Extensions) ;
          NOUPDATE $(extTarget) ;
          DEPENDS $(1) : $(extTarget) ;
          LOCATE on $(extTarget) = $(Java-Jdk-Extensions) ;
        }
    }

#* A rule for compiling a number of .java files together at once, under a
#* specified target, which is used to name a timestamp file for use with
#* dependency calculations.
#*
#* You can optionally specify one or more extension JARs that need to be present
#* in the JDK extension directory, for this compilation to succeed.
#*
#* $(1) target
#* $(2) source ...
#* $(3) [ path ... ]
#* $(4) [ extension ... ]
#* $(5) [ optional manifest file gristed target ]
#*
#*eg. Java-Compile <target> : <source> ... [ : <path> ... ] [ : <extension> ... ] [ : <manifesttarget> ] ;
#*
#*section Java
#
    rule Java-Compile {
        if Java in $(EnabledCompilers) {

            local Target ; MakeGristed Target : $(1).javac : $(CurrentPath) ;
            NOTFILE $(Target) ;

#           Check for required JDK extensions, if requested
            if $(4) {
              Java-Require-Extension $(Target) : $(4) ;
            }

            local R = $(Target).src ;
            DirectoryFor $(R) : $(CurrentPath) $(JavacOutput-Directory) ;

            local SourcePath ; MakePath SourcePath : $(CurrentPath) $(3) ;
            local Source ; MakeGristed Source : $(2) : $(SourcePath) ;
            SEARCH on $(Source) += $(SourcePath) ;
            AddUnique jde-source-directories : $(SourcePath) ;

            for i in $(Source) {
                switch $(i:S) {
                case .src  : ResponseAppend $(Target) : $(R) : $(i) ;
                case .java : ResponseFile   $(Target) : $(R) : $(i) ;
                }
            }

            Java-JarContents $(1) : $(R) : $(Target) : Path : $(5) ;
            _Java-Javac $(Target) ;

            dir on $(Target) = $(Path) ;
            ENV on $(Target) = $(Java-Compiler_Environment) ;
            javac on $(Target) = $(Java-Compiler:B) $(Java-Compiler_Arguments) ;
            Join Path : $(SPLITPATH) : $(Java-Compiler_Pre_ClassPath)
                                       $(Java-System-ClassPath)
                                       $(Java-Compiler_ClassPath-$(Target))
                                       $(Java-Compiler_Post_ClassPath) ;
            fixedcp on $(Target) = $(Path) ;

            # Produce a tags file
            Tags-Java $(1) : $(R) ;
        }
    }


#* A rule for invoking the javadoc documentation tool.  The default
#* <target> is <em>javadoc</em>, and the default destination directory is
#* $(CurrentPath)$/obj$/<target>, and either may be overriden.  You may
#* specify individual .java source files or .jar files as appropriate.
#*
#* <subdir>s for .jar files can be determined automatically, but you must
#* specify the <subdir> containing individual .java files if they do not
#* <em>belong</em> to the current compound.
#*
#* $(1) sources ...
#* $(2) [ subdir ... ]
#* $(3) [ target ]
#* $(4) [ destination ]
#* $(5) [ options ... ]
#*
#*eg. Java-Document <sources> ... [ : <subdir> ... [ : <target> [ : <destination> [ : <options> ... ] ] ] ] ;
#*
#*section Java
    rule Java-Document {
        if Java in $(EnabledCompilers) {
            local rawtarget = $(3) ; rawtarget ?= javadoc ;
            local targetdir = $(4) ; targetdir ?= $(CurrentPath)$/obj$/$(rawtarget) ;
            local target ; MakeGristed target : $(rawtarget).time : $(CurrentPath) ;
            if $(4) { targetdir on $(target) = $(targetdir) ; }
            else   { targetdir on $(target) ?= $(targetdir) ; }

            DependsOn $(rawtarget) : $(target) ;

            local respfile = $(target:S=.src) ;
            LOCATE on $(target) $(respfile) ?= $(targetdir:D) ;

            local sources subdir source ;
            MakePath subdir : $(CurrentPath) $(2) ;
            local i ; for i in $(1) {
                if $(2) || $(i:S) != .jar {
                    MakeGristed sources : $(i) : $(subdir) ;
                }
                else {
                    MakeGristed sources : $(i) : $(Dot) ;
                    sources = $(TargetFile-$(sources)).javac.src ;

                    for j in $(JarIncludesJar-$(i)) {
                        MakeGristed source : $(j) : $(Dot) ;
                        sources += $(TargetFile-$(source)).javac.src ;                    
                    }
                }
                for source in $(sources) {
                    switch $(source:S) {
                        case .src :
                            ResponseAppend $(target) : $(respfile) : $(source) ;
                        case .java :
                            ResponseFile $(target) : $(respfile) : $(source) ;
                            SEARCH on $(source) += $(subdir) ;
                    }
                }
            }

            ENV on $(target) = $(Java-Compiler_Environment) ;
            Jd on $(target) = $(Javadoc-Compiler) $(Javadoc-Compiler_Arguments) $(5) ;
            _Java-Document $(target) ;

            CleanDir $(targetdir) ;
        }
    }

#* $(1) sourcesubdirectories
#* $(2) [ sourcedir ]
#* $(3) [ target ]
#* $(4) [ destdir ]
#*
#*eg. Java-CheckStyle <sourcesubdirectories> [ : <sourcedir> [ : <target> [ : <destdir> ] ]
#*
#*section Java
    rule Java-CheckStyle 
    {
        if $(Java-CheckStyle)
        {
            local sourceDir = $(2) ; sourceDir ?= $(CurrentPath) ;
            local rawTarget = $(3) ; rawTarget ?= javacheckstyle ;
            local targetDir = $(4) ; targetDir ?= $(CurrentPath)$/obj$/$(rawTarget) ;

            CleanDir $(targetDir) ;
            FloatingDepends $(rawTarget) ;
            NOTFILE $(rawTarget) ;

            # This makes a command-line-friendly target for all the checkstyle
            # targets of a single invocation of the Java-CheckStyle rule
            local smallTarget = $(rawTarget)-$(CurrentPath:B) ;
            DEPENDS $(rawTarget) : $(smallTarget) ;

            local d ;
            for d in $(1)
            {
                local curTarget ;
                MakeGristed curTarget : $(rawTarget)$(d) : $(CurrentPath) ;
                NOTFILE curTarget ;

                DEPENDS $(smallTarget) : $(curTarget) ;

                targetDir on $(curTarget) = $(targetDir) ;
                scanDir on $(curTarget) = $(sourceDir)$/$(d) ;
                JCS on $(curTarget) = $(Java-CheckStyle) ;
                logFile on $(curTarget) = $(targetDir)$/$(d:S=.log) ;

                _Java-CheckStyle $(curTarget) ;
            }
        }
    }

##### 
#* javadoc compile rule
#*
#* $(1) output dir
#* $(2) source dir ...
#* $(3) access specifier (public|protected)
#* $(4) maximum JVM memory (Mb)
#* $(5) initial JVM memory (Mb)
#*
#*eg. Javadoc-Compile <output dir> : <source directories> .. [ : access specifer ( eg protected, public ) [ : maximum JVM memory (Mb) [ : initial JVM memory (Mb) ] ;
#*
#*section Java
#

    rule Javadoc-Compile {
         if Java in $(EnabledCompilers) {
             local Target ; MakeGristed Target : $(1) : $(CurrentPath) ;

             Java-Javadoc $(Target) : $(CurrentPath)$(FS)$(2) : $(CurrentPath)$(FS)$(1) ;

             Javadoc-ExtraArgs on $(Target) += -$(3) -J-Xms$(5)m -J-Xmx$(4)m ;
          
             CleanDir $(CurrentPath)$(FS)$(1) ;
             CleanDir $(CurrentPath)$(FS)$(1)-full ;
         }
    }


#* Unjars a .jar file for embedding in another jar target.  The
#* unpacked jar is put into the .javac.out directory along with the class
#* files output from a javac process.  This avoids having to copy the
#* java source when in the majority of cases, the target jar isn't going
#* to have any other jars embedded in it.
#*
#* ABSOLUTE is to make it possible to unjar a library outside of this build
#*
#* A list of relative paths of unwanted files from the jar may be specified. These
#* will be removed before the files are put into the target jar.
#*
#* $(1) for-target
#* $(2) jar ...
#* [$(3)] path ...
#* [$(4)] ABSOLUTE
#* [$(5)] unwantedfiles
#* [$(6)] optional manifest file gristed target
#*
#*eg. Java-UnJar <fortarget> : <thejar> ... [ : <path> ... ] [ : ABSOLUTE ] [ : <unwantedfiles> ] [ : manifest ] ;
#*
#*section Java
    rule Java-UnJar {
        if Java in $(EnabledCompilers) {

            local SourcePath ;
            if $(4) = ABSOLUTE { 
              MakePath SourcePath : $(3) ;
            } else {
              MakePath SourcePath : $(CurrentPath) $(3) ;
            }
            local jar ; MakeGristed jar : $(1) : $(CurrentPath) ;
            local Sources ; MakeGristed Sources : $(2) : $(SourcePath) ;

            local i ; for i in $(Sources) {
                local T = $(jar)-unjar-$(i) ;
                NOTFILE $(T) ;

                local S ;
                if $(TargetFile-$(i)) {
                    ts on $(T) = $(TargetFile-$(i)).cont.ts ;
                    _Java-CopyJavacOut $(T) ;

                    S = $(TargetFile-$(i)).cont.finish ;
                }
                else {
                    SEARCH on $(i) += $(SourcePath) ;
                    ENV on $(T) = $(Java-Compiler_Environment) ;
                    unjar on $(T) = $(Java-Jar:B) -xf ;

                    if $(4) = ABSOLUTE { 
                      if $(5) {
                        unwanted on $(T) = $(5) ;
                        _Java-UnJar-Absolute-Unwanted $(T) : $(i) ;
                      } else {
                        _Java-UnJar-Absolute $(T) : $(i) ;
                      }
                    } else {
                      if $(5) {
                        unwanted on $(T) = $(5) ;
                        _Java-UnJar-Unwanted $(T) : $(i) ;
                      } else {
                        _Java-UnJar $(T) : $(i) ;
                      }
                    }

                    S = $(i) ;
                }

                local T.contents ;
                Java-JarContents $(jar) : $(S) : $(T) : T.contents : $(6) ;
                dest on $(T) = $(T.contents) ;
            }
        }
    }

#* A rule to allow the user to add arbitary files to a jar
#*
#* $(1) jar
#* $(2) destination ...
#* $(3) file ...
#* [$(4)] subdir ...
#*
#*eg. Jar-AddFile <jar> : <destination> ... : <file> ... [ : <subdir> ... ] ;
#*
#*section Java
    rule Jar-AddFile {
        local Dest ; MakePath Dest : $(2) ;
        local SourcePath ; MakePath SourcePath : $(CurrentPath) $(4) ;
        local Sources ; MakeGristed Sources : $(3) : $(SourcePath) ;
        SEARCH on $(Sources) += $(SourcePath) ; # In case it isn't a target.

        if $(Sources[2-]) && $(Dest:B) != * {
            Error Must use '*' specifier when using more than one source with Jar-AddFile ;
        }

        local Source ; for Source in $(Sources) {
            local leaf ;
            if $(Dest:B) = * { leaf = $(Source:BS) ; }
            else             { leaf = $(Dest:BS)   ; }
            local Grist = $(Dest:P) ;
            if ! $(Grist) { Grist = Jar-AddFile ; }
            Grist = $(CurrentPath)-$(Grist) ;
            local Target ; MakeGristed Target : $(leaf) : $(Grist) ;

            # Just using CopyFile results in the target depending on the
            # timestamp file, which in turn gets updated after the
            # target itself.  This means that these targets would always
            # get updated.  Instead, we make $(Target) a NOTFILE, and
            # set the destination on the target separately.
            _Jar-AddFile $(Target) : $(Source) ;
            NOTFILE $(Target) ;

            local JarRoot ;
            Java-JarContents $(1) : $(Source) : $(Target) : JarRoot ;
            local dir ; MakePath dir : $(JarRoot) $(Dest:P) ;
            MakeDirectory $(dir) ; DEPENDS $(Target) : $(dir) ;
            dest on $(Target) = $(dir)$/$(leaf) ;
        }
    }

#* A rule for creating a .jar file from a number of sources
#*
#* You can optionally specify one or more extension JARs that need to be present
#* in the JDK extension directory, for this compilation to succeed.
#*
#* ABSOLUTE is to make it possible to unjar a library outside of this build
#*
#* The optional manifest file can be used when it is necessary to include specific
#* information in the Jar manifest. There is currently no automatic gristing of
#* the manifest file target, so a gristed target should typically be supplied. No
#* automatic LOCATE is done, either, so one must set LOCATE on the given target.
#* Only one manifest can be used for a particular Jar, so if there are multiple
#* invocations of Jar rule for a Jar, programmer must avoid conflicts.
#*
#* $(1) target
#* $(2) source ...
#* [$(3)] path ...
#* [$(4)] extension ...
#* [$(5)] ABSOLUTE
#* [$(6)] removefiles
#* [$(7)] optional manifest file gristed target
#*
#*eg. Jar <target> : <source> ... [ : <path> ... ] [ : <extension> ... ] [: ABSOLUTE ] [ : <removefiles> ] [ : <manifesttarget> ] ;
#*
#*section Java
    rule Jar {
        local Target = $(1) ;
        if $(Target:S) != .jar { Target = $(Target).jar ; }

        # Ensure we have the response file, even if no Java sources are actually compiled
        local JTarget = $(1).javac ;
        local STarget = $(JTarget:G=$(CurrentPath)).src ;
        DirectoryFor $(STarget) : $(CurrentPath) $(JavacOutput-Directory) ;
        ResponseFile $(Target) : $(STarget) ;

        local Source ; for Source in $(2) {
            switch $(Source:S) {
                case .idl :
                    Idl-Idl2Java-Compile $(Source) : $(3) ;
                    Jar $(Target) : $(Source:S=.src) ;
                case .java :
                    Java-Compile $(Target) : $(Source) : $(3) : $(4) : $(7) ;
                case .src :
                    Java-Compile $(Target) : $(Source) : $(3) : $(4) : $(7) ;
                case .jar :
                    Java-UnJar $(Target) : $(Source) : $(3) : $(5) : $(6) : $(7) ;
                    if $(5) != ABSOLUTE && ! $(Source) in $(JarIncludesJar-$(Target)) {
                        JarIncludesJar-$(Target) += $(Source) ;
                    }
            }
        }
    }

#* A rule that creates a dependency on a given .jar file, and adds it to the
#* compilation class path.
#*
#* $(1) target
#* $(2) jarfiles
#* [$(3)] path
#* [$(4)] JAVAH
#*
#*eg. Java-UsesJar <target> : <jarfiles> [ : <path> ... ] [ : JAVAH ] ;
#*
#*section Java
    rule Java-UsesJar {
        local Target ; MakeGristed Target : $(1) : $(CurrentPath) ;

        local Path ;
        if $(3) { Path = $(CurrentPath) $(3) ; }
        else    { Path = $(Dot) ; }
        MakePath Path : $(Path) ;

        local Jars ; MakeGristed Jars : $(2) : $(Path) ;

        if JAVAH != $(4) {
          local T1 = $(Target).javac ;
          local T2 = $(TargetFile-$(Target)).javac ;
          Target = $(T1) ;
          if $(T1) != $(T2) {
            Target += $(T2) ;
          }
        }
        DEPENDS $(Target) : $(Jars) ;

        Java-UsesJar on $(Target) += $(TargetFile-$(Jars):&) ;
    }

##############################
#           JNI              #
##############################

if $(NT)
{
  actions quietly together _Java-Javah bind Java-UsesJar
  {
    echo ...JNI FOR $(<:B)...
    $(SetEnv)$(ENV)$(NewLine)
    echo $(SPLITPATH)$(Java-UsesJar) > buildclasslist.tmp
    echo $(SPLITPATH)$(fixedcp) >> buildclasslist.tmp
    echo $(HeaderFileName) | $(Perl) -ne "s/\.h//g;s/_/./g;print" > NativeClass.tmp
    $(Perl) -ne "chop;s/\s//g;print;" buildclasslist.tmp > buildclasspath.tmp
    $(javah) -force -classpath @buildclasspath.tmp -d $(Dir) @NativeClass.tmp
    $(Erase) buildclasslist.tmp
    $(Erase) buildclasspath.tmp
    $(Erase) NativeClass.tmp
  }
}
else if $(UNIX) || $(MACOSX) 
{
  actions quietly together _Java-Javah bind Java-UsesJar 
  {
    echo ...JNI FOR $(<:B)...
    $(SetEnv)$(ENV)$(NewLine)
    $(javah) -force -classpath `$(Perl) -e '{print join("$(SPLITPATH)",@ARGV)}' $(Java-UsesJar) $(fixedcp) ` -d $(Dir) `echo $(HeaderFileName) | $(Perl) -ne 's/\.h//g;s/_/./g;print' `
  }
}

#*  Rule that runs javah to get generated headers. Use this if you do not
#*  then immediately want to make an implementation library.
#*
#* $(1) headerfilename ...
#* [$(2)] outputdir
#*
#*eg. Java-Javah <headerfilename> ... [ : <outputdir> ] ;
#*
#*section Java
rule Java-Javah
{
  local HeaderFileName = $(1) ;
  local Target ;
  MakeGristed Target : $(HeaderFileName) : $(CurrentPath) ;
  local OutputDir ;
  if $(2) {
    OutputDir = $(2) ;
  } else {
    OutputDir = $(CurrentPath)$/$(GeneratedC-Directory) ;
  }
  AddToVar Inherited Local : C-IncludeDirectories : $(OutputDir) : : Unique ;
  DirectoryFor $(Target) : $(OutputDir) ;
  Dir on $(Target) = $(OutputDir) ;
  ENV on $(Target) = $(Java-Compiler_Environment) ;
  javah on $(Target) = $(Java-Javah:B) ;
  local Path ;
  Join Path : $(SPLITPATH) : $(Java-Compiler_Pre_ClassPath)
                             $(Java-Compiler_SourcePath-$(Target))
                             $(Java-System-ClassPath)
                             $(Java-Compiler_ClassPath-$(Target))
                             $(Java-Compiler_Post_ClassPath) ;
  fixedcp on $(Target) = $(Path) ;
  HeaderFileName on $(Target) = $(HeaderFileName) ;
  _Java-Javah $(Target) ;
  CleanFile $(Target) ;
}

#*  Generate headers then use them to create an implementation dynamic library.
#*
#* $(1) LibraryName
#* [$(2)] implsrc ...
#* [$(3)] headerfilename ...
#* [$(4)] usedjar ...
#*
#*eg. Java-JNILibrary <LibraryName> [ : <implsrc> ... ] [ : <headerfilename> ... ] [ : <usedjar> ... ] ;
#*
#*section Java
rule Java-JNILibrary
{
  local JNILibraryName = $(1) ;
  local Sources = $(2) ;
  local Headers = $(3) ;
  local UsedJars = $(4) ;

  local DynLibTarget ;
  local SourcesTarget ;
  local HeadersTarget ;

  local DynLibName = $(JNILibrary-Prefix)$(JNILibraryName)$(JNILibrary-Suffix) ;
  MakeGristed DynLibTarget : $(DynLibName) : $(CurrentPath) ;

  if $(Headers) {
    MakeGristed HeadersTarget : $(Headers) : $(CurrentPath) ;
  }

  if $(Sources) {
    MakeGristed SourcesTarget : $(Sources) : $(CurrentPath) ;

    if $(Headers) {    
      INCLUDES $(SourcesTarget) : $(HeadersTarget) ;
    }
  }

  if $(Headers) { 
    Java-Javah $(Headers) ;

    if $(UsedJars) {
      Java-UsesJar $(Headers) : $(UsedJars) : : JAVAH ;
    }
  }

  DynamicLibrary $(DynLibTarget) : $(SourcesTarget) ;
  if $(MACOSX) || $(UNIX)
  {
    local Target = $(DynLibTarget) ;
    if $(TargetFile-$(Target)) { Target = $(TargetFile-$(Target)) ; }

    GenerateExports_ on PostLink-$(Target) = $(Java-JNI-Exports-1) ;
    Source on PostLink-$(Target)           = $(Target) ;
    GenerateExports2 on PostLink-$(Target) = $(Java-JNI-Exports-2) ;

    RemoveExportsFile_ on PostLink-$(Target) = $(C-Dll-Post_Linker_RemoveExportsFile) ;
  }
  
  local LibDir = $(CurrentPath)$/$(C-Dll-Directory) ;
  if ! $(LibDir) in $(JNILibrary-Dirs) {
    JNILibrary-Dirs += $(LibDir) ;
  }

  $(JNILibraryName)-JNILibrary-Directory = $(LibDir) ;

  # If we are using a specialised dynamic library name, we have to hook up the
  # given target name to the one which will be generated by DynamicLibrary rule.
  local Target ;
  if $(DynLibName) = $(JNILibraryName) {
    Target = $(DynLibTarget) ;
  } else {
    MakeGristed Target : $(JNILibraryName) : $(CurrentPath) ;
    DEPENDS $(Target) : $(DynLibTarget) ;
    NOTFILE $(Target) ;
    FloatingDepends $(Target) ;
    TargetFile-$(Target) = $(TargetFile-$(DynLibTarget)) ;
  }

  ## Windows manifest files required in DLLs
  if $(NT)
  {
    EmbedManifest $(JNILibraryName) : $(LibDir) :  $(LibDir)$/$(DynLibName)$(C-Dll-Suffix)$(C-Manifest-Suffix) : : ;
  }

  ## Convenience target for building all JNI libraries, without other stuff
  DEPENDS jni : $(Target) ;
}

#* $(1) LibraryName
#* [$(2)] clibrary ...
#* [$(3)] subdir ...
#*
#*eg. Java-JNILibrary-LinkWithLibraries <LibraryName> [ : <clibrary> ... ] [ : <subdir> ... ] ;
#*
#*section Java
rule Java-JNILibrary-LinkWithLibraries
{
  local JNILibraryName = $(1) ;
  local C-Libraries = $(2) ;
  local Subdir = $(3) ;

  local DynLibTarget ;

  local DynLibName = $(JNILibrary-Prefix)$(JNILibraryName)$(JNILibrary-Suffix) ;
  MakeGristed DynLibTarget : $(DynLibName) : $(CurrentPath) ;

  C-LinkWithLibraries $(DynLibTarget) : $(C-Libraries) : $(Subdir) ;
}

#* Rule for creating empty generated list of JUnit test classes. Should be
#* run exactly once in a product, towards the start of the product makefile.
#*
#* Does nothing if variant <code>junit</code> is not in force. This variant is declared
#* by this rule.
#*
#* [$(1)] generated file
#*
#* The $(1) name defaults to <code>JUnitTests.txt</code>.
#*
#*section Java
if $(NT)
{
  actions quietly together _JUnitStart bind SubLists
  {
    echo ...Generating $(<)...
    echo // list of classes for JUnit test suite > $(<)
    type $(SubLists) >> $(<)  2>nul
  }
} else {
  actions quietly together _JUnitStart bind SubLists
  {
    echo ...Generating $(<)...
    echo // list of classes for JUnit test suite > $(<)
    cat $(SubLists) >> $(<)
  }
}

rule JUnitStart
{
  ImplementsVariant junit : Inherited Local ;
  AddToVar Local : Suffix : junit : Variant junit ;
  if ( $(Variant_junit) )
  {
    local FileName = $(1) ;
    FileName ?= JUnitTests.txt ;

    local Target ;
    MakeGristed Target : $(FileName) : $(BUILDROOT) ;
    DirectoryFor $(Target) : $(BUILDROOT) ;
    CleanFile $(Target) ;
    FloatingDepends $(Target) ;
    DEPENDS all : $(Target) ;

    _JUnitStart $(Target) ;
  }
}

#* Rule for appending to generated list of JUnit test classes. Should be
#* run typically once per makefile per Java compound.
#*
#* Does nothing if variant <code>junit</code> is not in force.
#*
#* $(1) test class file ...
#* [$(2)] package directory
#* [$(3)] generated file name
#*
#* If specified, $(2) is prepended to each entry of $(1)
#* The default value of $(3) is <code>JUnitTests.txt</code>.
#*
#*section Java
actions quietly together _JUnitRegisterTests
{
  echo ...Generating $(<) $(Bar)...
  echo $(TestFiles) > $(<)
}

rule JUnitRegisterTests
{
  if ( $(Variant_junit) )
  {
    local FileName = $(3) ;
    FileName ?= JUnitTests.txt ;

    local OverallTarget ;
    MakeGristed OverallTarget : $(FileName) : $(BUILDROOT) ;

    local Target ;
    MakeGristed Target : $(FileName) : $(CurrentPath) ;
    DirectoryFor $(Target) : $(CurrentPath)$/obj ;
    FloatingDepends $(Target) ;
    CleanFile $(Target) ;
    DependsOn $(OverallTarget) : $(Target) ;

    local TestFiles ;
    local Bar = "" ;
    for i in $(1)
    {
      Bar = $(Bar)* ;
      if $(2) {
        TestFiles += $(2)$/$(i) ;
      } else {
        TestFiles += $(i) ;
      }
    }

    TestFiles on $(Target) = $(TestFiles) ;
    TestPath on $(Target) = $(CurrentPath) ;
    Bar on $(Target) = $(Bar) ;
    SubLists on $(OverallTarget) += $(Target) ;

    _JUnitRegisterTests $(Target) ;
  }
}

actions quietly _GenerateCompileOptions 
{
  echo ...Generating $(<)
  echo package $(Package) $(EscapeTerminator); > $(<)
  echo public final class $(Class) { >> $(<)
  echo public static final boolean DEBUG = $(DebugValue) $(EscapeTerminator); >> $(<)
  echo public static final boolean ASSERT = $(AssertValue) $(EscapeTerminator); >> $(<)
  echo } >> $(<)
}

actions quietly _GenerateVersionClass
{
  echo ...Generating $(<)
  echo package $(Package) $(EscapeTerminator); > $(<)
  echo public final class $(Class) { >> $(<)
  echo public static final int MAJOR = $(Major) $(EscapeTerminator); >> $(<)
  echo public static final int MINOR = $(Minor) $(EscapeTerminator); >> $(<)
  echo public static final int REVISION = $(Revision) $(EscapeTerminator); >> $(<)
  echo public static final int STATUS = $(Status) $(EscapeTerminator); >> $(<)
  echo } >> $(<)
}

#* Rule for generating a compile options class to simulate conditional compilation
#* in Java code. This class will contain DEBUG and ASSERT constants that can be
#* used to surround code that should only be run in certain build environments.
#*
#* $(1) Name of the class (e.g. CompileOptions)
#* $(2) Package path (e.g. com$/harlequin)
#* $(3) Package name (e.g. com.harlequin)
#* $(4) Debug flag
#* $(5) Assert flag
#*
#* A value of 1 for $(4) means debug is on. Anything else means off.
#* A value of 1 for $(5) means assert is on. Anything else means off.
#*
#*section Java
rule GenerateCompileOptions 
{
  local i;
  local FileName = $(1).java ;

  local Target ;
  MakeGristed Target : $(FileName) : $(CurrentPath)$/$(2) ;
  DirectoryFor $(Target) : $(CurrentPath)$/obj$/java_src$/$(Suffix)-$(JavaVirtualMachine) ;

  Package on $(Target) = $(3) ;
  Class on $(Target) = $(1) ;

  if $(4) = 1 {
    DebugValue on $(Target) = true ;
  } else {
    DebugValue on $(Target) = false ;
  }

  if $(5) = 1 {
    AssertValue on $(Target) = true ;
  } else {
    AssertValue on $(Target) = false ;
  }

  if $(MACOSX) || $(UNIX) {
    EscapeTerminator on $(Target) = \\ ;
  } else {
    EscapeTerminator on $(Target) = " " ;
  }

  FloatingDepends $(Target) ;
  CleanFile $(Target) ;

  _GenerateCompileOptions $(Target) ;
}

#* Rule for generating a Java class containing version information from
#* Jam variables.
#*
#* $(1) Name of the class (e.g. CompileOptions)
#* $(2) Package path (e.g. com$/harlequin)
#* $(3) Package name (e.g. com.harlequin)
#* $(4) Major version (integer)
#* $(5) Minor version (integer)
#* $(6) Revision (integer)
#* $(7) Release status (integer). Optional, defaults to zero.
#*
#* Java symbolic constants or expressions can be used for the
#* values, providing they resolve to an integer and do not contain
#* punctuation that will confuse Jam.
#*
#*section Java
rule GenerateVersionClass
{
  local i;
  local FileName = $(1).java ;

  local Target ;
  MakeGristed Target : $(FileName) : $(CurrentPath)$/$(2) ;
  DirectoryFor $(Target) : $(CurrentPath)$/obj$/java_src$/$(Suffix)-$(JavaVirtualMachine) ;

  Package on $(Target) = $(3) ;
  Class on $(Target) = $(1) ;

  Major on $(Target) = $(4) ;
  Minor on $(Target) = $(5) ;
  Revision on $(Target) = $(6) ;

  if $(7) {
    Status on $(Target) = $(7) ;
  } else {
    Status on $(Target) = 0 ;
  }

  if $(MACOSX) || $(UNIX) {
    EscapeTerminator on $(Target) = \\ ;
  } else {
    EscapeTerminator on $(Target) = " " ;
  }

  FloatingDepends $(Target) ;
  CleanFile $(Target) ;

  _GenerateVersionClass $(Target) ;
}

#* Creates a list, in a Jam variable, of paths to the named Jars.
#*
#* $(1) Name of Jam variable in which to store the list. If this variable
#*      already contains value(s), the list will be appended after those.
#* $(2) Names of Jar files to include in the list. Do not include paths.
#* $(3) Optional. Unless this value is given and is "NOWILDCARD", Jar
#*      wildcards will be included on platforms where the latest Java
#*      supports them. One use for NOWILDCARD would be if using an
#*      old version of Java.
#* $(4) Optional. Unless this value is given and is "NOJUNIT", then Jars
#*      for JUnit support will be added when "junit" variant is being built.
#*
#*section Java
rule ListJarsInObjDirs
{
  local c, d ;
  for c in $(2) 
  {
    if mac-all in $(JamTargetPlat) || $(3) = NOWILDCARD
    {
      # Current Apple Mac OS X JREs do not support Jar wildcards
      d = $($(c:B)-Jar-Output-Directory)$/$(c) ;
    }
    else
    {
      # Current Sun JREs for Windows, Linux and Solaris support Jar wildcards
      d = $($(c:B)-Jar-Output-Directory)$/* ;
    }
    # Add iff unique
    if ! $(d) in $($(1)) {
      $(1) += $(d) ;
    }
  }

  if $(Variant_junit) && $(4) != NOJUNIT 
  {
    local jj = $(JUnitJar) $(JavaMailJar) $(JAFJar) ;
    for c in $(jj)
    {
      if ! $(c) in $($(1)) {
        $(1) += $(c) ;
      }
    }
  }
}

# Log stripped
