%!PS-Adobe-3.0
%%Title: HqnImpose2
%%Creator: Global Graphics Software Limited
%%CreationDate: August 1994
%{HqnImpose2 version #1 0
% Copyright (C) 1992-2012 Global Graphics Software Ltd. All rights reserved.
%%EndComments
% $Revision: 1.76.1.1.1.1 $
%%BeginProcSet: (HqnImpose2) 1 0

% This procset provides a set of routines to enable combinations of
% imposition, crop marks and other features best obtained using the
% Beginpage/EndPage/SensePageDevice/Imposition entires in the page
% device to be produced as easily as possible.
%
% This file replaces the HqnImpose procset used in earlier versions of
% the Harlequin RIP. While the formal API is the same, the two procsets
% differ in the location of most variables as part of a move from
% local to global VM.
%
% For more details please see Harlequin's Extensions documentation.

% NOTES
% initialize must be called at save level 2 or lower
% customimpose needs to allocate keys to global or local.

% NOTE: Multiple separations may not be imposed if Recombine Separations
%       is turned on.

<< /UVPS {} >> 1183615869 internaldict /defineop get exec

% $HopeName: SWv20!swf:procsets:impose2(EBDSDK_P.1) $
%
% Global Graphics Software Ltd. Confidential Information.
%

currentglobal

false setglobal

userdict /HqnImpose2Dict 2 copy known {
  get begin
}  {
  120 dict dup begin put
} ifelse

/ImposeDebug false def

/ProcSetVersion ($Revision: 1.76.1.1.1.1 $) 11 1 index length 13 sub getinterval def

save
% UVM (Loading in-RIP imposition support v%s - Copyright (c) 1992-%d Global Graphics Software Ltd. All Rights Reserved.\n)
(%stderr)(w) file
dup (Loading in-RIP imposition support v) writestring
dup ProcSetVersion writestring
( - Copyright (c) 1992-2006 Global Graphics Software Ltd. All Rights Reserved.\n) writestring
restore

/globalness exch def end

true setglobal
globaldict /HqnImpose2GlobalDict 2 copy known {
  get begin
}  {
  240 dict dup begin put
} ifelse

/PageCount 0 def
/FilmCount 0 def
/PagesExposed 0 def
/PendingPageWidth 0 def
/PendingPageHeight 0 def

/MaxLeftMargin 0 def
/MaxTopMargin 0 def
/MaxRightMargin 0 def
/MaxBottomMargin 0 def

/ObjectOnPage false def

/AbortingJob false def

% Flag for how much has been done so far -
% 0 = HqnInitImpose has not been run
% 1 = HqnInitImpose has been run outside the job context (e.g. in a page feature,
%       and setpagedevice has not been called by setrealdevice yet.
% 2 = Everything initialized and in the job context.
/ImpositionInitialised 0 def

/AbortOversize false def

/Objective /OneUp def  % default Objective

% FillSpace et al use MaxHeight and MaxWidth to define the area to pack
/MaxHeight 0 def
/MaxWidth 0 def
/SheetSlop 35 def  % Don't report sheets as oversize if within this number of device pixels from the requested maximum.

% The FixedSizeSheet Suffix uses MinWidth and MinHeight to increase sheet size as required.
/MinHeight 0 def
/MinWidth 0 def

% set LimitPageCount to non-zero if you want no more than that
% number of pages.
/LimitPageCount 65535 def

/PagesUp null def
/PagesAcross null def
/PagesPerFilm null def
/Rotate 0 def
/FilmWidth 0 def
/FilmHeight 0 def
/ClippedHeight 0 def
/ClippedWidth 0 def

% media dimension for the unlimited direction of an unlimited device
/UnlimitedMediaWidth 0 def
/UnlimitedMediaHeight 0 def

% Several Objectives use Strategy to determine packing details.
% It's value is usually a key (used as a reasonably mnemonic way of
% passing a state - the key has no associated value).
/Strategy null def
% StrategyList allows a series of Strategies to be defined as HqnInitImpose is
% called multiple times with different Objectives.
/StrategyList 3 dict def
/TacticList 3 dict def

% The other main switch is Aspect which defines whether pages should
% be portrait etc. Values are:
%    /Portrait, /Landscape, /Original, /Rotated and /BestFit
% null for default.
/Aspect null def

% If the job page size should not be acted upon then use the
% Page Setup size as default, but it may be redefined by the
% supplied dict to InitImpose
/IgnoreJobPageSize false def

/PageWidth null def
/PageHeight null def
/RequestPageWidth 0 def
/RequestPageHeight 0 def

/OffsetX 0 def
/OffsetY 0 def
% Shouldn't be used unless there are very strange save/restore contexts.
/BasePageSize [ 8.5 72. mul 11. 72. mul ] def
/BaseValues 6 dict def

% Size and offset of the 'window' within which the the page size is positioned
% Objectives may set it to null if not used
% see /Paneled Objective and /RespondPanel Response.
/PanelWidth null def
/PanelHeight null def
/PanelOffsetX 0 def
/PanelOffsetY 0 def
/ClipOffset null def    % null means 'undefined'. See JDF spec.

/ClipPath null def
/GutterClip null def
/SrcClipPath null def

% these move the whole set of pages across or up. Used in centering the page set
% by FixedSizeSheet.
/AdjustX 0 def
/AdjustY 0 def

% Extra fiddling with page rotation & position
% value is array of [ rot xtrans ytrans ]
/AdjustRotation null def

% Set default scaling to 100% - it's read from the pagedevice in InitImpose
/ScaleY  1. def
/ScaleX  1. def
/BaseScaleX 1. def
/BaseScaleY 1. def
% Scaling in some places can be snapped down to round numbers to allow measurement
% from the proof. ScaleSnap should be an array of acceptable scale factors,
% e.g.  [ .05 .1 .2 .25 .4 .5 ]
% null means don't snap.
/ScaleSnap null def

/AAlias 1 def

/ScaleMode  /None def  % None - don't scale,
            % ScaleFit - Scale to fill page,
      % ScaleStretch - as ScaleFit but distort if required.
/ScaleAspect  /BestFit def  % BestFit or Original - rotate to match aspect ratios or not.
/ScaleWidth  null def  % Width and height of size to fit to. If null the use BasePageSize
/ScaleHeight null def
/PageScaleX  1. def
/PageScaleY  1. def
/PageClipped false def

% The PageList will be defined as a dictionary in the SensePageDevice
% call.
% Each entry is a sub-dictionary, keyed by integer and containing
% ListPageSize, ListPanelSize, ListPageOffset, ListPanelOffset, ListScale,
% ListRotation, ListFilmNo, ListPosition
/PageList null  def
/PageOrder null def

/PagePosition /Origin def

% variable for internal use only.
/FlushingPage false def
/LastPage false def

% Tactic procedures fill in the page position array
/Tactic null def

/CancellingPage false def

% If a call to setpagedevice includes a /PageSize definition and the size doesn't match
% the existing page size (within PageSizeMatch units) then the dictionary is passed to the
% Response procedure which must return either "dict true" or "false".
/AlwaysRespond false def
/PageSizeMatch  5 def
/Response null def

/ControlStrategy /Default def
/ControlDepth 0 def

/RequestedOrientation 0 def
/RequestedExtraOrientation 0 def

/Prefix null def

% Used by FixedSizeSheet Suffix.
/OversizeCallback {} def
/OversizeStrategy null def
/Suffix null def

% DrumCircumference is used by pack drum. In 3.3 it may be
% calculated in that Objective. Define in points.
/DrumCircumference null def

% Gutters between pages. If possible the optimal gutter will be used,
% but it would be silly to throw pages off if they wouldn't quite fit
% if that gutter is used. Reduce towards MinGutter if needed. If using
% crop marks you can often reduce further, so use MinCropGutter then.
% THESE ARE NO LONGER DEFINED HERE, BUT MAY STILL BE PROVIDED IN CONFIG
% DICTIONARIES, IN WHICH CASE THEY ARE REPLICATED TO BOTH h AND v
% /OptimalGutter  22.7 def  % 8 mm
% /MinGutter  8.5 def    % 3 mm
% /MinCropGutter  1.4 def    % 0.5 mm

% Later additions, used as an alternative to Optimal gutter to allow separate
% setting of vertical and horizontal gutters
/OptHGutter 22.7 def  % 8 mm
/MinHGutter 8.5 def    % 3 mm
/MinHCropGutter 1.4 def    % 0.5 mm
/OptVGutter 22.7 def  % 8 mm
/MinVGutter 8.5 def    % 3 mm
/MinVCropGutter 1.4 def    % 0.5 mm

% Film Margins may be used by underlay or overlay procedures to add
% labels etc.
/FilmLeft  0 def
/FilmRight  0 def
/FilmTop  0 def
/FilmBottom  0 def

% These procedures can be overridden with another procedure, or a simple boolean
/HorAlign {
  //HqnImpose2GlobalDict /HorCenter 2 copy known {
    get exec
  }  {
    pop pop
  currentpagedevice
  DeviceType dup /deviceTypePartDrum eq exch /deviceTypeDrum eq or {
    /MediaCenterPageLength
  }  {
    /MediaCenterPageWidth
  } ifelse
  get
  } ifelse { /AlignCenter }{ /AlignLeft } ifelse
} bind def
/VertAlign {
  //HqnImpose2GlobalDict /VertCenter 2 copy known {
    get exec
  }  {
    pop pop
  currentpagedevice
  DeviceType dup /deviceTypePartDrum eq exch /deviceTypeDrum eq or {
    /MediaCenterPageWidth
  }  {
    /MediaCenterPageLength
  } ifelse
  get
  } ifelse { /AlignCenter }{ /AlignBottom } ifelse
} bind def

% Must be in the range 0-360. -90 does NOT work.
/RotatedAngle 90 def
% If true, ExtraFlip means to add a 180 degree rotation to all pages
/ExtraFlip false def

% Procedures to be called before or after all pages on a film
% have been drawn.
/Marks [] def
/X 0 def
/Y 0 def
/Angle 0 def
/TextFont /Helvetica def
/TextSize 12 def
/OEMTextX () def
/OEMTextY () def
/OEMTextZ () def
/FontStyle -1 def
/ClipMarksToMargins false def

% default to no crops
/CropMarks false def
/CropMarkInitialised false def
/CropMarkSetup {} def

% Default to 'old-style' where all crop marks are within the page size that's
% used to calculate page layout, gutters etc. HqnLayout sets this to false, which
% means that crops extend into margins & gutters.
/CropsInside true def

% default to not centering halftone phase. Compositing
% (used for overprints and transparency) in 7.0 uses the
% default screen for the background, so changing the phase
% introduces artifacts even when the job does not set its
% own screen
/HalftonePhase false def

/ProgressReport false def
/DebugReport  false def
/DebugFilm  false def

/HqnStopImpose false def

% These two match page device keys by the same name
/Duplex false def
/Tumble false def
% Follow red book or real world?
/RedBookTumble false def

/TextEncodings 4 dict def
/TextFonts 4 dict def

/MirrorMarks true def
/AllowNegativeMarkOffset false def  % Can be overriden in individual Marks dicts.

% DeviceType is used for selection of default Tactic - set as a key
/DeviceType null def

% *************************
% CROP MARK STUFF:
/CropSpace  30 def  % Space round page in points
/CropClearance    6 def  % Distance from page edge to inner end of crops etc.
/Bleed    12 def  % Clip path is this far out from edge of page.

/CropRule    0.15 def  % Weight of crop-marks, rules in register marks etc.

/LabelSize 10.  def  % size of file name & date text etc.
/LabelFont /Courier def  % font used for such text.
/ProgressiveFont /Helvetica-Bold def
/ProgressiveFontSize 4.75 def

/ShowCropMarks    true def
/ShowRegisterMarks   true def
/ShowProgressives   true def
/ShowSepNames     true def
/ShowWedges    true def
/ShowJobName    true def

/sepChosen 3 def

/RegWidth null def

/LookingForPageSize 0 def
/ParseBoundingBox false def
/BoundingSaveLevel 2 def

% A safe way of accessing internaldict PageSetup values in
% the absence of PageSetup!
% defaultvalue /PageSetupKey GetPageSetup -> validvalue
/GetPageSetup{
  1183615869 internaldict /PageSetup 2 copy known{
    get exch 2 copy known{
      get
      dup type /nulltype ne { exch } if
    }{pop}ifelse
  }{pop pop}ifelse pop
}bind def

% end of global defines ================================================================

false setglobal

HqnImpose2Dict begin

% All messages apart from debugging emitted by the procset are defined here to allow for easy
%   internationalization.
% Translation takes place on a line-by-line basis
% Simple strings are marked for translation with UVS
% Messages which form part of an error require a UVM template in a comment
% The Messages dictionary may be easily extended or replaced by entries in SW/Usr/CustomImpose2
/Messages <<
                                % UVM(%%%%[ Error: %t)
  /Error       (%%[ Error: )
                                % UVM(%%%%[ Warning: %t)
  /Warning     (%%[ Warning: )
  /CloseError    ( ]%%\n)

  /UnknownFillStrategy   (Unknown Strategy specified for FillSpace: )
  /NxNnone_zero     UVS (PagesUp and PagesAcross must be > 0 when using NxN Objective ]%%\n)
  /NxNnot_BestFit    (BestFit is not a valid Aspect when using NxN Objective.\n)
  /BestN_limits    UVS (One and only one of MaxWidth and MaxHeight should be zero for BestN ]%%\n)
  /BestN_count    UVS (LimitPageCount must be > 0 when using BestN Objective ]%%\n)
  /PaneledMaxSize    UVS (MaxWidth and MaxHeight must be defined when using Paneled Objective ]%%\n)
  /OneUpMaxSize    (MaxWidth and MaxHeight must be defined when using OneUpWithAspect.\n)
  /missingPosition  UVS (/ListPosition or ListCTM must be defined for all pages when using the PassThrough Tactic ]%%\n)
            % UVM (Unknown PagePosition specified: %s ]%%\n)
  /missingPagePosition (Unknown PagePosition specified: )
  /Imposition    (while running imposition procedure: )
  /Aspect      (unknown imposition Aspect: )
  /UnknownPrefix    (unknown imposition Prefix: )
  /RunPrefix    UVS (while running imposition Prefix procedure ]%%\n)
  /UnknownSuffix    (unknown imposition Suffix: )
  /RunSuffix    UVS (while running imposition Suffix procedure ]%%\n)
  /Objective    (unknown imposition Objective: )
  /RunObjective    UVS (while running imposition Objective procedure ]%%\n)
  /runOversizeStrategy UVS (while running imposition OversizeStrategy procedure ]%%\n)
  /runOversizeCallback UVS (while running imposition OversizeCallback procedure ]%%\n)
  /Response    (unknown imposition Response: )
  /runResponse    UVS (while running imposition Response procedure ]%%\n)
  /StopRespond    UVS (Incorrect page size used for these imposition settings ]%%\n)
  /ObjectiveStack1  (Imposition Objective procedure left invalid items on stack:\n     )
  /ObjectiveStack2  ( item\(s\) left \(should have been 5\) ]%%\n)
  /Tactic    UVS (while running imposition Tactic procedure ]%%\n)

                               % UVM(>  Interpreted page %d)
  /PlateProgress    (>  Interpreted page )
  /FilmFlushed    UVS(>  Flushing flat ... \n)
                                % UVM(>> Finished flat %d)
  /FilmProgress    (>> Finished flat )
  /BlankSuppressed  UVS(>> Output of blank flat has been suppressed.\n)

  /BadCustom    UVS (Usr/CustomImpose2 must return a dictionary and nothing else ]%%\n)

                                % UVM(setpagedevice call including illegal procedure when used with HqnImpose2 ProcSet: %s)
  /IllegalCall    (setpagedevice call including illegal procedure when used with HqnImpose2 ProcSet: )
  /IgnorePageSize    UVS(setpagedevice call attempting to alter PageSize within imposition. New page size will be ignored ]%%\n)
  /copypageWarn    UVS(copypage called. While imposing copypage will be interpreted as showpage ]%%\n)
  /Halved_limits    UVS (Both MaxWidth and MaxHeight must be non-zero for the Halved Objective ]%%\n)
  /Halved_Aspect    (The Halved Objective only supports /BestFit Aspect ]%%\n)
  /ImposeOutsideServerLoop  UVS(The HqnInitImpose procedure cannot usefully be run outside the server loop ]%%\n)
  /UnknownOversize   (Unknown OversizeStrategy specified: )
  /InvalidControlText    (Unknown command character in ControlText: )
  /ControlPostScript    UVS (Control text PostScript failed ]%%\n)
  /UnterminatedComand  UVS (Command in control text was unterminated ]%%\n)
  /InvalidCommandNumber UVS (Number in control text was invalid ]%%\n)
  /MissingControlFile    (Control file not found: )
  /UnknownControlStrategy  (ControlStrategy not known: )
  /NoFurtherCalls    UVS (Previously applied settings in HqnImpose2 prohibit further calls ]%%\n)
  /NoControlFile    (Control files are not supported in JAC or core RIP ]%%\n)
  /InvalidHashText  UVS (Invalid number in <# text command ]%%\n)
  /NoEndif      UVS (No endif in ControlText string ]%%\n)
  /ExtraEndif      (Extra endif in ControlText string\n)

  /UnknownControlFileFit (Unknown Fit for ControlFile mark: )
  /UnknownControlFileAlignX (Unknown AlignX for ControlFile mark: )
  /UnknownControlFileAlignY (Unknown AlignY for ControlFile mark: )
  /ControlSizeMissing  (MarkHeight or Width missing - control file will not be scaled ]%%\n)
  /BadGLOBAL UVS (GLOBAL entry in config is not a global dictionary ]%%\n)
  /NonGlobal UVS (Config item to be stored in global dict is not in global VM ]%%\n)
  /ImposeNotAtTop UVS (HqnInitImpose called below top job save level ]%%\n)
  /UnknownPathOp (Unknown operator in SrcClipPath: )
  /PathOpStack (SrcClipPath or ClipPath left items on op stack ]%%\n)
  /AbortedOversize UVS (Page is too large for the media - Aborting job ]%%\n)
  /InvalidFontStyle (<#s font style out of range ]%%\n)

  /Recombining UVS(Multiple pages cannot be imposed when Recombine Separations is selected ]%%\n)

  /ControlTextOver (Invalid string supplied to </ in ControlText mark ]%%\n)

  % default text to use instead of name from /PageSetup in internaldict
  /NoPageSetup  (Undefined)

  % Used by crop marks code for labelling films:
  % Can't translate these - they only appear in bitmaps - so don't mark
  /PlateLabel  UVPS (Plate)
  /Cyan    UVPS (Cyan)
  /Magenta  UVPS (Magenta)
  /Yellow    UVPS (Yellow)
  /Black    UVPS (Black)

  /Clipped  UVPS (Clipped)
  /Scale    UVPS (Scale)
  /dpi    UVPS (dpi)
  /dpmm    UVPS (dpmm)
  /None    UVPS (None)
  /Untitled  UVPS (Untitled)
  /Unknown  UVPS (Unknown)
>> def
/ShowMessage {
  //HqnImpose2GlobalDict /HqnStopImpose get {
    pop
  }  {
    //Messages exch 2 copy known {
      get print
    }  {
      UVS(%%[ Error: Missing Message in HqnImpose2 procset: )print
      =print
      ( ]%%)=
      pop
    } ifelse
  } ifelse
} bind def

/MaxInt 16#7FFFFFFF def
/onespace ( ) def
/ImpoString 4096 string def
/NoneString (\(None\)) def

mark /HqnLocal /ProcSet resourcestatus {
  null /HqnLocal /ProcSet findresource /Initialize_1 get exec
    {
    /Translate /Transform_1 /TranslateString_1
    /TranslateChars_1 /TransformGUI_1 /TransformFileName_1
    /TransformJobName_1 /TransformJobString_1
    /PDFDate_1 /CurrentDate_1
    /StripFileName_1
  }  {
    /HqnLocal /ProcSet findresource 1 index get def
  } forall
}
{
  % Stub implementations, provided for use when the HqnLocal procset is not
  % available.
  /Translate { } bind def  % Return string unchanged.
  /Transform_1 { pop exch pop currentfont } bind def
  /TranslateString_1 { exch pop currentfont } bind def
  /TranslateChars_1 { exch pop currentfont } bind def
  /TransformGUI_1 { exch pop currentfont } bind def
  /TransformFileName_1 { exch pop currentfont } bind def
  /TransformJobName_1 { pop currentpagedevice /JobName get currentfont } bind def
  /TransformJobString_1 { exch pop currentfont } bind def
  /PDFDate_1 { pop exch pop currentfont } bind def
  /CurrentDate_1 { pop pop daytime currentfont } bind def
  /StripFileName_1 { } bind def  % Not implemented. Return original.
} ifelse
cleartomark

/garray {
  currentglobal true setglobal exch array exch setglobal
} bind def

/GlobalizeArray {
  dup gcheck not {
    dup length //garray exec copy
  } if
} bind def

% If PriorEndPage returns false then EndPage will act as if in response to
% device deactivation.
/PriorEndPage null def
/BeginPageExtra  {} def
/BeginPageExtras << >> def
/PriorBeginPage null def
/PriorScaling [1 1] def
/PriorImposition false def

/InExecBounding false def

/DefaultPageList <<
  /ListPanelSize { [ PanelWidth PanelHeight ] }
  /ListPageSize { [ PageWidth PageHeight ] }
  /ListPageOffset { [ OffsetX OffsetY ] }
  /ListPanelOffset { [ PanelOffsetX PanelOffsetY ] }
  /ListScale { [ PageScaleX PageScaleY ] }
  /ListRotation {
    Rotate
    dup type /booleantype eq {
      { RotatedAngle } { 0 } ifelse
    } if
  }
  /ListExtraRotation { 0 }
  /ListCTM { null }
  /ListFilmNo { 1 }
  % No real default for position!
  /ListPosition { [ 0 0 ] }
  /ListClip  { null }    % default - means no orthogonal clipping
  /ListSrcClipPath { null }
  /ListSheetClipPath { null }
  /ListSheetClipPathOffsets { [ 0 0 ] }
>> def

/recombinestatus 1183615869 internaldict /recombinestatus get def
/currentsystemparam 1183615869 internaldict /currentsystemparam get def
/superexec 1183615869 internaldict /superexec get def
/fpparams << /ForcePositive true >> def

/stopcheck {
  stopped
  dup {
    $error /errorname get /interrupt eq {
      serverdict /terminatejobnow get exec
    } if
  } if
} bind def

/by90 {
  Rotate type /booleantype eq { Rotate }{
    Rotate 45 add 90 div cvi 1 and 1 eq
  } ifelse
} bind def

/StandardBackstop true def    % Used for simple coercion of single pages to fit.

/ScaleAPage {
  % Used by OneScaled, RespondScale and ScaleToPanel to scale a page into the panel
  % Fit without distortion, but rotate for best fit if Rotate is null
  PageWidth PageHeight
  Rotate null eq {
    % BestFit etc
    PanelHeight PanelWidth ge
        PageHeight PageWidth ge ne dup
      { RotatedAngle } { 0 } ifelse
    /Rotate exch store
      {
      exch
    } if
  }  {
    //by90 exec {
      exch
    } if
  } ifelse
  PanelHeight exch div exch
  PanelWidth exch div
  2 copy gt { exch } if pop
  /PageScaleX 1 index store
  /PageScaleY exch store
  //by90 exec {
    /PanelWidth PanelHeight /PanelHeight PanelWidth store store
  } if
  /PanelOffsetX PanelWidth PageScaleX div PageWidth sub 2. div store
  /PanelOffsetY PanelHeight PageScaleY div PageHeight sub 2. div store
} bind def

/passthoughcurrent {
    pagedevicePassBack begin
    currentpagedevice
    exch {
      2 copy known {
        2 copy get def
      }  {
        pop
      } ifelse
    } forall
    end  % passback
    pop  % currentpagedevice
} bind def

% devpixels dimension(0,1) -> PixelPoints -> points
/PixelPoints {
  currentpagedevice /HWResolution get exch get
  div 72 mul
} bind def

% Objective procedures must return leaving five items on the stack:
% filmX, filmY, pagesX, pagesY, rotated

/Objectives 9 dict def
//Objectives begin

  % Default and entry used for crops only
  /OneUp <<
  /Default {
    % Aspect is ignored for this Strategy
    % Keep original Orientation and ExtraOrientation
      [ /Orientation /ExtraOrientation /FilmSaving /TimeSaving ]
    //passthoughcurrent exec

    /PanelWidth null store    % To trigger recalculation if required

    % Remember that Film~ keys are meant to be physical dimensions, and should therefore be
    % 'reverse scaled' at this point so that the real scaling gets back to the correct size.
    currentpagedevice dup /Orientation get exch /ExtraOrientation get add
    2 mod 0 eq
      PageHeight FilmTop FilmBottom add 2 index { ScaleY }{ ScaleX } ifelse div add
      PageWidth FilmLeft FilmRight add 4 -1 roll { ScaleX }{ ScaleY } ifelse div add
    exch
      1 1 false
      /Tactic /OneUp store
  } bind
  /OneUpWithAspect {
    % Requires MaxHeight and MaxWidth to be defined already
    % Uses Aspect switch to determine packing form
      DebugReport {
        (   Aspect: )print Aspect =
      } if
    /Rotate <<
        /Portrait { PageHeight PageWidth lt }
        /Landscape { PageHeight PageWidth gt }
        /Original { false }
        /Rotated { true }
      /BestFit {
        MaxHeight 0 le {
          MaxWidth 0 le {
            % Unlimited
            false
          }  {
            % Capstan
            MaxWidth FilmLeft sub FilmRight sub ScaleX div
            PageWidth PageHeight 2 copy lt
            % space pw ph port
            dup 5 1 roll
              { exch } if pop
            % port space larger
            lt { not } if
          } ifelse
        }  {
          MaxWidth 0 le {
            % unlimited sideways
            MaxHeight FilmTop sub FilmBottom sub ScaleY div
            PageHeight PageWidth 2 copy lt
            dup 5 1 roll
              { exch } if pop
            lt { not } if
          }  {
            % bounded
        MaxHeight FilmTop sub FilmBottom sub ScaleY div
        MaxWidth FilmLeft sub FilmRight sub ScaleX div div 1. gt
        PageHeight PageWidth div 1. gt
        ne
          } ifelse
        } ifelse
        PageHeight PageWidth eq { pop false } if
      }
      >> Aspect dup null eq { pop /BestFit } if get exec store
    /PanelWidth null store    % To trigger recalculation if required
    PageHeight  PageWidth
    Rotate { exch } if
    FilmLeft FilmRight add ScaleX div add
    exch
    FilmTop FilmBottom add ScaleY div add
    1 1 Rotate
    /Tactic /OneUp store
  } bind
  >> def
  /OneUp {    % Objective                -------------------------------------------------------
  //OneUp Strategy dup null eq { pop /Default } if
  2 copy known {
    get exec
  }  {
    /Error ShowMessage /UnknownFillStrategy ShowMessage
      =print
      /CloseError ShowMessage flush
    pop
      stop
  } ifelse
  } def    % OneUp

  /OneScaled {    % Objective                -------------------------------------------------------
    % Scale the page into the base page size

  % Keep original Orientation and ExtraOrientation
    [ /Orientation /ExtraOrientation /FilmSaving /TimeSaving ]
    //passthoughcurrent exec

    /PanelWidth
  BasePageSize aload pop
  FilmTop sub FilmBottom sub /PanelHeight exch store
  FilmLeft sub FilmRight sub store
  /Rotate <<
      /Portrait { PageHeight PageWidth lt }
      /Landscape { PageHeight PageWidth gt }
      /Original { false }
      /Rotated { true }
    /BestFit { null }     % for now, as a flag to ScaleAPage
    >> Aspect dup null eq { pop /BestFit } if get exec store
  ScaleAPage

  % Return values.
  BasePageSize aload pop 1 1 Rotate
  } def    % OneScaled

  /FillSpace <<
    /MaxPages /BestFit
    /OneRow /Portrait
    /OneColumn /Landscape
  >> def
  /FillSpace {    % Objective                -------------------------------------------------------
% (>>FS)= pstack (_______)=
  % Requires MaxHeight and MaxWidth to be defined already
  % Uses Strategy and Aspect switches to determine packing form
  % Strategies: MaxPages, OneRow, OneColumn

  % Set default Strategy
  % Check valid Strategy and set default Aspect

  //FillSpace Strategy dup null eq {
    pop /MaxPages
    /Strategy /MaxPages store
  } if
  2 copy known {
    get
  }  {
    /Error ShowMessage /UnknownFillStrategy ShowMessage
      =print
      /CloseError ShowMessage flush
    pop
      stop
  } ifelse

  Aspect null eq {
    /Aspect exch store
  }  {
    pop
  } ifelse
  BaseAspect null eq {
    /BaseAspect Aspect def
  } if

  % We are doing FillFilm: If we are unlimited in one direction,
  % the << /PageSize PageSize >> setpagedevice in HqnLayout, will have resulted
  % in setting the Media dimension to the Page dimension in the corerip.
  % This has the side effect of only allowing one row (or column) to be filled
  % rather than considering filling the whole film from the Page Size
  % in Page Layout. In HqnLayout, we now squirrel away the original Page Size
  % and we reset it here.

  UnlimitedMediaHeight 0 ne {
    /MaxHeight UnlimitedMediaHeight store
  } if

  UnlimitedMediaWidth 0 ne {
    /MaxWidth UnlimitedMediaWidth store
  } if

  /LocMaxWidth MaxWidth dup 0.001 lt { pop 0 } {
    FilmLeft sub FilmRight sub ScaleX div 0 PadDevice
    SheetSlop 0 //PixelPoints exec add
  } ifelse def
  /LocMaxHeight MaxHeight dup 0.001 lt { pop 0 } {
    FilmTop sub FilmBottom sub ScaleY div 1 PadDevice
    SheetSlop 1 //PixelPoints exec add
  } ifelse def

    Aspect /BestFit eq {
      % Recursive call - we'll return here
      /Aspect /Portrait store
      //Objectives /FillSpace get exec
       /Aspect /Landscape store
    }   {
      DebugReport {
        (   MaxPageWidth: )print LocMaxWidth =print
        (, MaxPageHeight: )print LocMaxHeight =print
        (, Strategy: )print Strategy dup null eq { pop /MaxPages } if =print
        (, Aspect: )print BaseAspect =
      } if
    } ifelse

    % Do we need to rotate?
    /Rotate <<
      /Portrait { PageHeight PageWidth lt }
      /Landscape { PageHeight PageWidth gt }
      /Original { false }
      /Rotated { true }
    >> Aspect get exec store

     % Now - is the page too big as it stands?
  PageWidth PageHeight Rotate { exch } if

  StandardBackstop BaseAspect /BestFit ne and {
       dup LocMaxHeight gt LocMaxHeight 0 ne and
    2 index LocMaxWidth gt LocMaxWidth 0 ne and
    or  {
        % Page is too large in at least one dimension
        2 copy gt LocMaxWidth LocMaxHeight gt ne {
          % And aspect ratio of page doesn't match film
          /Rotate Rotate not store
          exch
        } if
      } if
  } if

    % stack:- PageWidth PageHeight
    % Note that MaxHeight or MaxWidth may be 0 for
    % arbitrary length - OK for OneRow or OneColumn.

    % Calculate film size and page counts
  2 copy
    LocMaxHeight MinHGutter ScaleY div add
    exch MinHGutter ScaleY div add div truncate cvi  % -> pages high
    dup 1 gt Strategy /OneRow eq and {
      pop 1
    } if
    dup 1 lt BaseAspect /BestFit ne LocMaxHeight 0 eq or and { pop 1 } if
    exch

  LocMaxWidth MinVGutter ScaleX div add
  exch MinVGutter ScaleX div add div truncate cvi  % -> pages across
    dup 1 gt Strategy /OneColumn eq and {
      pop 1
    } if
    dup 1 lt BaseAspect /BestFit ne LocMaxWidth 0 eq or and { pop 1 } if
  exch

  % stack: pageX pageY countX countY
  2 copy
  5 -1 roll OptHGutter ScaleY div add mul OptHGutter ScaleY div sub
  dup LocMaxHeight gt LocMaxHeight 0 ne and { pop LocMaxHeight } if
  FilmBottom FilmTop add ScaleY div add
  % stack: pageX countX countY countX filmY
  5 1 roll 4 -1 roll
  OptVGutter ScaleX div add mul OptVGutter ScaleX div sub
  dup LocMaxWidth gt LocMaxWidth 0 ne and { pop LocMaxWidth } if
  FilmLeft FilmRight add ScaleX div add
  % stack: filmY countX countY filmX
  4 1 roll
  Rotate

    Aspect /Landscape eq BaseAspect /BestFit eq and {
      % Second pass for BestFit
      % Select the best fill - selection varies by Strategy
      % 2 sets of 5 vals on stack.
      % Maybe roll bottom set to top then pop one set
      % filmX filmY countX countY rotate filmX filmY countX countY rotate

      <<
      /MaxPages {
        7 index 7 index mul
        3 index 3 index mul
        2 copy eq {
        pop pop
        LocMaxHeight FilmTop sub FilmBottom sub
        LocMaxWidth FilmLeft sub FilmRight sub gt
        PageHeight PageWidth gt ne
      }  {
        lt
      } ifelse
      }
      /OneColumn {
        % if portrait is fewer pages than landscape then roll
        6 index 2 index lt
        % and landscape does fit across film
        LocMaxWidth dup 0 eq exch 7 index ge or
        and
      }
      /OneRow {
         % if land is equal pages to port then roll
        7 index 3 index le
        % or portrait doesn't fit down film
        LocMaxHeight dup 0 ne exch 11 index lt and
        or
      }
      >> Strategy dup null eq { pop /MaxPages } if
    get exec { 10 5 roll } if

      5 { pop } repeat

    % Now set any zero page counts up to 1. We retain the zero earlier
    % to allow layouts where no pages fit to be detected.
    1 index 0 eq {
      exch pop 1 exch
      4 -1 roll pop dup
      { PageWidth }{ PageHeight } ifelse FilmBottom add FilmTop add
      4 1 roll
    } if
    2 index 0 eq {
      3 -1 roll pop 1 3 1 roll
      5 -1 roll pop dup
      { PageHeight }{ PageWidth } ifelse FilmLeft add FilmRight add
      5 1 roll
    } if
    } if

    % Now trim filmsizes as necessary
    Aspect /Landscape eq BaseAspect /BestFit ne or StandardBackstop and {
      % don't call this on 1st pass through for BestFit
      LocMaxWidth 0 ne {
        4 index LocMaxWidth gt {
          5 -1 roll pop LocMaxWidth 5 1 roll
        } if
      } if
     LocMaxHeight 0 ne {
        3 index LocMaxHeight gt {
          4 -1 roll pop LocMaxHeight 4 1 roll
        } if
      } if
    } if
  /PanelWidth null store    % To trigger recalculation if required
% (FS>>)= pstack (%%%%%%%%%%%%)=
 } bind def

  /PackDrum {    % Objective                -------------------------------------------------------
  % Intended largely for part drum devices.
    % Strategy will default to Maxpages inside FillSpace if left null here
  pagedevicePassBack /Margins [ 0 0 0 0 ] put
    /MaxHeight MediaHeight store
    DrumCircumference null eq {
    /DrumCircumference
      currentpagedevice begin
      % get the cassette dimensions in use
      InputAttributes Private /InputAttributes get get begin
      PageSize 0 get dup 0 le {
        % we may be limited by MaxPageSize
        pop
        currentdict /MaxPageSize known {
          MaxPageSize 0 get
        }  {
    % *************************************************************************************
    %     A default drum circumference may be entered here, but it is very unlikely
    %    that this case will be reached on a drum device. The value is set in points.
    % *************************************************************************************
          500. 25.4 div 72. mul % DEFAULT to 500 mm
        } ifelse
      } if
      end end    % InputAttributes, currentpagedevice
    store
    } if
    /MaxWidth DrumCircumference store
    //Objectives /FillSpace get exec
    % Suppress media width warnings
    statusdict /mediawidth 6 index put
   } bind def

  /FillWidth {  % objective                -------------------------------------------------------
     % Intended for Capstan devices.

   /Strategy /OneRow store
     Aspect null eq { /Aspect /BestFit store } if

  % set left and right margins to zero for pass back
  pagedevicePassBack /Margins
  currentpagedevice /Margins get
  dup length array copy
  dup 0 0 put
  dup length 2 gt {
    dup 2 0 put
  } if
  put

     /MaxWidth MediaWidth FilmLeft sub FilmRight sub ScaleX mul store
     % arbitrarily long - 0.
     /MaxHeight FilmTop FilmBottom add ScaleY mul store

     //Objectives /FillSpace get exec

     /MaxHeight 0 store
    } bind def

  /FillFilm {    % objective                -------------------------------------------------------
      ImpositionInitialised 0 eq {
        /PageWidth BasePageSize aload pop
        /PageHeight exch store store
      } if

  pagedevicePassBack /Margins [ 0 0 0 0 ] put
  /MaxHeight MediaHeight store
  /MaxWidth MediaWidth store

     //Objectives /FillSpace get exec
    } bind def

  /BestN {    % objective                      -------------------------------------------------------------
      % Fit N pages in the 'best way'
      % MaxWidth *or* MaxHeight should be zero  and will be
      % treated as unlimited. Best fit is defined as minimum
      % size in that direction.
      % No strategies.

      MaxWidth 0.00001 gt MaxHeight 0.00001 gt eq
      MaxWidth 0 lt or MaxHeight 0 lt or {
     /Error ShowMessage /BestN_limits ShowMessage
    stop
     } if
     LimitPageCount 1 lt {
     /Error ShowMessage /BestN_count ShowMessage
    stop
     } if

  % Set default Aspect and calculate rotation.
  % Leave width height on stack
  Aspect null eq { /Aspect /BestFit store } if
  <<
    /Portrait   {
      PageWidth PageHeight 2 copy gt { exch true }{ false } ifelse
    }
    /Landscape  {
      PageWidth PageHeight 2 copy lt { exch true }{ false } ifelse
    }
    /Original   { PageWidth PageHeight false }
    /Rotated   { PageHeight PageWidth true }
    /BestFit  { PageWidth PageHeight false }  % for now
  >> Aspect get exec

   /Rotate exch store
  /LocHeight exch def
  /LocWidth exch def

  /LocMaxWidth MaxWidth dup 0.001 lt { pop 0 }{
    FilmLeft sub FilmRight sub ScaleX div
    SheetSlop 0 //PixelPoints exec add
  } ifelse def

  /LocMaxHeight MaxHeight dup 0.001 lt { pop 0 }{
    FilmTop sub FilmBottom sub ScaleY div
    SheetSlop 1 //PixelPoints exec add
  } ifelse def

   DebugReport {
      (   MaxWidth: )print LocMaxWidth ScaleX div =print
      (, MaxHeight: )print LocMaxHeight ScaleY div =print
      (, Aspect: )print Aspect =
    } if

  Aspect /BestFit eq { 2 } { 1 } ifelse {
     DebugReport {
        (   TryWidth: )print LocWidth ScaleX div =print
        (, TryHeight: )print LocHeight ScaleY div ==
      } if

    MaxHeight 0.001 lt MaxWidth 0.001 gt or {
      % Fill across
    LocMaxWidth MinVGutter add
      LocWidth MinVGutter add div cvi
    dup 1 gt {
      dup LocWidth mul LocMaxWidth exch sub
      1 index 1 sub div
        dup OptVGutter gt {
          pop OptVGutter
        } if
    }  {
        pop 1 OptVGutter
    } ifelse
    /VerticalGutter exch store
    /PagesAcross exch store
    /PagesUp LimitPageCount PagesAcross 1 sub add
      PagesAcross idiv store

      % And a boolean to say whether it fitted at all
      LocMaxWidth LocWidth gt

      % Check hor gutter
      LocMaxHeight 0.001 lt {
        OptHGutter
      }  {
        LocHeight PagesUp mul sub
          PagesUp 1 sub div
        dup OptHGutter gt {
          pop OptHGutter
        }  {
          dup MinHGutter lt {
            pop MinHGutter
            % didn't fit
            exch pop false exch
          } if
        } ifelse
      } ifelse
      /HorizontalGutter exch store

    % leave the bottom four return values on the stack
    % calculate filmwidth
    LocWidth VerticalGutter add PagesAcross mul VerticalGutter sub
    % calculate filmheight
      LocHeight HorizontalGutter add PagesUp mul OptHGutter sub
    PagesAcross PagesUp

      % Grab the boolean that says whether it fitted or not
      5 -1 roll
    }  {
      % Fill up
      LocMaxHeight MinHGutter add
        LocHeight MinHGutter add div cvi
      dup 1 gt {
        dup LocHeight mul LocMaxHeight exch sub
        1 index 1 sub div
        dup OptHGutter gt {
          pop OptHGutter
        } if
      }  {
        pop 1 OptHGutter
      } ifelse
      /HorizontalGutter exch store

      /PagesUp exch store
      /PagesAcross LimitPageCount PagesUp 1 sub add
        PagesUp idiv store
      % leave the bottom four return values on the stack
      % calculate filmwidth
      LocWidth OptVGutter add PagesAcross mul VerticalGutter sub
      % calculate filmheight
      LocHeight HorizontalGutter add PagesUp mul OptHGutter sub
      PagesAcross PagesUp
      HorizontalGutter OptVGutter
      % And a boolean to say whether it fitted at all
      LocMaxWidth LocWidth gt
    } ifelse

    Aspect /BestFit eq {
      /LocWidth LocHeight /LocHeight LocWidth def def
    } if
  } repeat

  Aspect /BestFit eq {
    % We have two sets of five data items on the stack -
    % pick the best
    % best means least 'locmaxwidth', where the width fits at all
    5 index 1 index ne {
      % Only one fitted, use that
      dup
    }  {
      % Both fitted or both failed, choose best
      LocMaxHeight 0.001 lt LocMaxWidth 0.001 gt or {
        % fw fh pa pu fit fw fh pa pu fit
        8 index 4 index gt
      }  {
        9 index 5 index gt
      } ifelse
    } ifelse {
      10 5 roll
      /Rotate Rotate not store
    } if
    5 { pop } repeat
  } if
  pop  % did it fit?

  MaxWidth 0.00001 lt {
    exch
    4 2 roll exch 4 2 roll
  } if

  4 2 roll
  FilmTop add FilmBottom add
  4 1 roll
  FilmLeft add FilmRight add
  4 1 roll

  Rotate
  /PanelWidth null store    % To trigger recalculation if required
    } bind def

    /NxN {    % objective          -------------------------------------------------------------
      % No Strategies for NxN.

      [ /ExtraOrientation /FilmSaving /TimeSaving ]
    //passthoughcurrent exec

    % Default page counts
    PagesUp null eq { /PagesUp 1 store } if
    PagesAcross null eq { /PagesAcross 1 store } if

    PagesUp 0 le PagesAcross 0 le or {
      /Error ShowMessage /NxNnone_zero ShowMessage
      stop
    } if

    Aspect /BestFit eq {
      MaxWidth 0 gt MaxHeight 0 gt or {
        StandardBackstop
        /StandardBackstop true store

        /Aspect /Rotated store
        //Objectives /NxN get exec

        /Aspect /Original store
        //Objectives /NxN get exec

        /Aspect /BestFit store
        /StandardBackstop 12 -1 roll store

        /Slop SheetSlop 1 //PixelPoints exec def

        % FilmWidth FilmHeight PagesAcross PagesUp Rotate FilmWidth FilmHeight PagesAcross PagesUp Rotate
        % Now choose one set
        MaxWidth 0 gt MaxHeight 0 gt and {
          % Look at both dimensions
          4 index MaxWidth Slop add le 4 index MaxHeight Slop add le and { true } {
            9 index MaxWidth Slop add le 9 index MaxHeight Slop add le and { false }{
              % Neither set fits, choose the one that most nearly fits
              MaxWidth 10 index div MaxHeight 10 index div
              2 copy lt { exch } if pop
              MaxWidth 6 index div MaxHeight 6 index div
              2 copy lt { exch } if pop
              gt
            } ifelse
          } ifelse
        }  {
          MaxWidth 0 gt {
            % Unlimited height
            % If both fit on, choose the shortest, else the narrowest
            9 index MaxWidth Slop add le
            5 index MaxWidth Slop add le
            and {
              8 index 4 index gt
            }  {
              9 index 5 index gt
            } ifelse
          }  {
            % Unlimited width
            % If both fit on, choose the narrowest, else the shortest
            8 index MaxHeight Slop add le
            4 index MaxHeight Slop add le
            and {
              9 index 5 index gt
            }  {
              8 index 4 index gt
            } ifelse
          } ifelse
        } ifelse
          {
          10 5 roll
        } if
        pop pop pop pop pop
      }  {
        /Aspect /Original store
        //Objectives /NxN get exec
        /Aspect /BestFit store
      } ifelse
    }  {
      % Set default Aspect and calculate rotation
      Aspect null eq { /Aspect /Original store } if
      /Rotate <<
        /Portrait   PageWidth PageHeight gt
        /Landscape   PageHeight PageWidth gt
        currentpagedevice /Orientation 2 copy known {
          get 2 mod 0 ne
        } { pop pop false } ifelse {
          /Original   true
          /Rotated   false
        }  {
          /Original   false
          /Rotated   true
        } ifelse
      >> Aspect get store

      /FilmUpPerPage Rotate { PageWidth }{ PageHeight } ifelse def
      /FilmAcrossPerPage Rotate { PageHeight }{ PageWidth } ifelse def

      % Remember that Film~ keys are meant to be physical dimensions, and should therefore be
      % 'reverse scaled' at this point so that the real scaling gets back to the correct size.
      /FilmHeight PagesUp FilmUpPerPage mul PagesUp 1 sub OptHGutter mul add
        FilmTop FilmBottom add
        currentpagedevice /ExtraOrientation get 2 mod 0 eq { ScaleY }{ ScaleX } ifelse div
        add store
      /FilmWidth PagesAcross FilmAcrossPerPage mul PagesAcross 1 sub OptVGutter mul add
        FilmLeft FilmRight add
        currentpagedevice /ExtraOrientation get 2 mod 1 eq { ScaleY }{ ScaleX } ifelse div
        add store

      % Trim size to MaxWidth/MaxHeight if defined. No warning if it won't fit
        MaxWidth 0 gt {
          /LocMaxWidth MaxWidth ScaleX div def
          FilmWidth LocMaxWidth gt LocMaxWidth 0 ne and {
          /FilmWidth
            PagesAcross FilmAcrossPerPage mul
            PagesAcross 1 sub MinVGutter mul add
            FilmLeft FilmRight add ScaleX div add
            store
            FilmWidth LocMaxWidth lt {
              /FilmWidth LocMaxWidth store
            } if
          } if
        } if
        MaxHeight 0 gt {
          /LocMaxHeight MaxHeight ScaleY div def
          FilmHeight LocMaxHeight gt LocMaxHeight 0 ne and {
          /FilmHeight
            PagesUp FilmUpPerPage mul
            PagesUp 1 sub MinHGutter mul add
            FilmTop FilmBottom add ScaleY div add
            store
            FilmHeight LocMaxHeight lt {
              /FilmHeight LocMaxHeight store
            } if
          } if
        } if

      /PanelWidth null store    % To trigger recalculation if required

      % return values:
      FilmWidth FilmHeight PagesAcross PagesUp Rotate
    } ifelse
    } bind def

    /PassThrough {  % objective            -------------------------------------------------
      % intended for imposition schemes totally devised by
      % front end applications or written by hand.
      % all the real work will be done in the tactic.
      /Tactic /PassThrough store
    /Response load null eq {
      /Response /RespondStop store
    } if
      1 1 1 1 false
    } bind def

/Paneled {    % objective                -------------------------------------------------
      % All Aspects supported, no Strategies (yet!)
  /LocMaxWidth MaxWidth dup 0.001 lt { pop 0 } {
    FilmLeft sub FilmRight sub ScaleX div
    SheetSlop 0 //PixelPoints exec add
  } ifelse def
  /LocMaxHeight MaxHeight dup 0.001 lt { pop 0 } {
    FilmTop sub FilmBottom sub ScaleY div
    SheetSlop 1 //PixelPoints exec add
  } ifelse def

  LocMaxWidth LocMaxHeight  % -> FilmWidth, FilmHeight
  2 copy 0 eq exch 0 eq or {
     /Error ShowMessage /PaneledMaxSize ShowMessage
    stop
  } if

    Aspect null eq {
    /Aspect /BestFit store
  } if
  /Rotate <<
      /Portrait { PageHeight PageWidth lt }
      /Landscape { PageHeight PageWidth gt }
      /Original { false }
      /Rotated { true }
    /BestFit { false }     % for now
    >> Aspect get exec store

  DebugReport {
    (   MaxWidth: )print LocMaxWidth =print
    (, MaxHeight: )print LocMaxHeight =print
    (, Aspect: )print Aspect =
  } if

  PageHeight PageWidth Rotate { exch } if

  LocMaxWidth MinVGutter add exch MinVGutter add div cvi
  exch
  LocMaxHeight MinHGutter add exch MinHGutter add div cvi

  Aspect /BestFit eq {
    LocMaxWidth PageHeight div cvi
    LocMaxHeight PageWidth div cvi
    4 copy
    mul 3 1 roll mul
    gt {
      4 2 roll
      /Rotate true store
    } if
    pop pop
  } if

  /PagesUp exch dup 1 lt { pop 1 } if store
  /PagesAcross exch dup 1 lt { pop 1 } if store
  /PanelWidth LocMaxWidth PagesAcross div
    LocMaxHeight PagesUp div
    Rotate { exch } if
      /PanelHeight exch store store
  /PanelOffsetX PanelWidth PageWidth sub 2. div store
  /PanelOffsetY PanelHeight PageHeight sub 2. div store

  PagesAcross PagesUp Rotate
  /Response load null eq {
    /Response /RespondPanel store
  } if
} bind def

/Halved {    % objective                    ------------------------------------------------
    MaxWidth 0.001 lt MaxHeight 0.001 lt or {
     /Error ShowMessage /Halved_limits ShowMessage
    stop
  } if

      % BestFit Aspect only supported, no Strategies (yet!)
  Aspect dup null ne exch /BestFit ne and {
     /Warning ShowMessage /Halved_Aspect ShowMessage
  } if
  /Aspect /BestFit store

  /LocMaxWidth MaxWidth FilmLeft sub FilmRight sub ScaleX div
    SheetSlop 0 //PixelPoints exec add def
  /LocMaxHeight MaxHeight FilmTop sub FilmBottom sub ScaleY div
    SheetSlop 1 //PixelPoints exec add def

    /Rotate false store

  DebugReport {
    (   MaxWidth: )print LocMaxWidth =print
    (, MaxHeight: )print LocMaxHeight =
  } if

  PageOrder null eq {
    currentglobal true setglobal
    /PageOrder 8 dict def
    PageOrder 0 [ 0 0 ] put
    setglobal
  } if
  /PagesPerFilm 1 store

  LocMaxWidth LocMaxHeight  % -> FilmWidth, FilmHeight

  /PageShort PageWidth PageHeight 2 copy gt
    { exch /Rotate Rotate not store } if
    /PageLong exch def def

  % -> FilmWidth, FilmHeight
  /Axis 1 def
  2 copy
  2 copy gt {
    exch
    /Rotate Rotate not store
    /Axis 0 def
  } if

  % max short, max long, max short, max long
  Rotate 3 1 roll
    {
    % filmshort, filmlong, Rotate, maxshort, maxlong
    Axis 2 ge { /Axis 3 Axis sub def } if
    2 copy MinHGutter sub 2. div
    2 copy gt {
      exch /Rotate Rotate not store
      /Axis Axis 2 add def
    } if
    % filmshort, filmlong, Rotate, maxshort, maxlong  narrowspace widespace
    2 copy
    PageLong lt exch PageShort lt or {
      % Won't fit any more
      pop pop
      % Undo last rotate if necessary
      /Rotate 4 -1 roll store
      exit
    }  {
      % still fits
      % filmshort, filmlong, Rotate, maxshort, maxlong  narrowspace widespace
      % Update PageOrder

      PagesPerFilm 1 sub -1 0 {
        PageOrder 1 index get aload pop
        Axis 2 mod 0 eq { exch } if
        2 mul 3 copy
        1 add
        1 -1 0 {
          3 1 roll
          Axis 2 mod 0 eq { exch } if
          PageOrder 4 -1 roll 5 -1 roll 2 mul add
          2 copy known {
            get astore pop
          }  {
            4 2 roll
            2 garray astore
            put
          } ifelse
        } for
      } for
      /PagesPerFilm PagesPerFilm 2 mul store

      4 2 roll pop pop
      3 -1 roll pop Rotate 3 1 roll  % save away in case!
    } ifelse
  } loop

  % max short, max long, panel short, panel long

  Rotate not { exch } if

  LocMaxWidth exch div round cvi exch
  LocMaxHeight exch div round cvi

  /PagesUp exch store
  /PagesAcross exch store

  /PanelWidth LocMaxWidth PagesAcross div
  LocMaxHeight PagesUp div
  Rotate { exch } if
  /PanelHeight exch store store
  /PanelOffsetX PanelWidth PageWidth sub 2. div store
  /PanelOffsetY PanelHeight PageHeight sub 2. div store

  PagesAcross PagesUp Rotate

  /Response load null eq {
    /Response /RespondHalved store
  } if
  Tactic null eq {
    /Tactic /FromList store
  } if
} bind def      % Halved

end  % Objectives

% Called by many Tactics to position pages
/XYpage [
  { exch } bind
  { FilmAcrossPerPage add exch } bind
  { FilmAcrossPerPage add exch FilmUpPerPage add } bind
  { exch FilmUpPerPage add } bind
] def
/XYpage {
  % stack: PageAcross, PageUp, PageNo
   PageList exch get begin

  % stack: PageAcross, PageUp

  % Save data to clip to gutter centres
  currentglobal true setglobal
  /ListGutterClip [
    4 index 0 eq {
      CropsInside CropMarks not or { 0 }{ FilmLeft ScaleX mul neg } ifelse
    }  {
      FilmAcrossPerPage VerticalGutter add 5 index mul
      VerticalGutter 2 div sub
    } ifelse
    4 index 0 eq {
      CropsInside CropMarks not or { 0 }{ FilmBottom ScaleY mul neg } ifelse
    }  {
      FilmUpPerPage HorizontalGutter add 5 index mul
      HorizontalGutter 2 div sub
    } ifelse
    6 index 1 add PagesAcross eq { FilmWidth }{
      FilmAcrossPerPage VerticalGutter add 7 index 1 add mul
      VerticalGutter 2 div sub
    } ifelse
    6 index 1 add PagesUp eq { FilmHeight }{
      FilmUpPerPage HorizontalGutter add 7 index 1 add mul
      HorizontalGutter 2 div sub
    } ifelse
  ] def
  setglobal

  % stack: PageAcross, PageUp

  /ListRow 1 index def
  /ListCol 2 index def

  FilmUpPerPage HorizontalGutter add mul exch
  FilmAcrossPerPage VerticalGutter add mul
  //XYpage Rotate 45 add 90 div cvi 4 mod get exec

  ListPosition astore pop
  /ListRotation Rotate def
  /ListExtraRotation 0 def
  /ListCTM null def

  end  % dict for this page in PageList
} bind def

/TacticCore {
  % PageNo, PageUp, PageAcross
  1 index 3 index //XYpage exec
  exch 1 add
  dup LimitPageCount ge
  LimitPageCount 0 ne and {
    pop -1
    exit
  } if
  exch
} bind def

/L2R { 0 1 PagesAcross 1 sub } def
/R2L { PagesAcross 1 sub -1 0 } def
/T2B { PagesUp 1 sub -1 0 } def
/B2T { 0 1 PagesUp 1 sub } def

/StandardTactic {
  /doexch exch def
  /InnerLoop exch def
  0 exch
  exec {
    % pageno up/across
    InnerLoop exec {
      % pageno up/across across/up
      1 index doexch { exch } if
      % pageno up/across pageacross pageup
      3 index //XYpage exec
      % pageno up/across
      exch 1 add
      dup LimitPageCount ge
      LimitPageCount 0 ne and {
        pop -1
        exit
      } if
      exch
    } for
    -1 eq { exit } if
  } for
  pop
} bind def

% Tactic procedures fill in the page position array
% The origin for these is at FilmLeft FilmBottom
% Rotation is taken care of later
/Tactics 18 dict begin

  /OneUp [
    { 0. 0. 0. } bind
    { 90 FilmAcrossPerPage 0. } bind
    { 180 FilmAcrossPerPage FilmUpPerPage } bind
    { 270 0. FilmUpPerPage } bind
  ] def
  /OneUp {
      % Always one page and always at the base origin
      PageList 0 get begin
    //OneUp Rotate 45 add 90 div cvi 4 mod get exec
    ListPosition astore pop
    /ListRotation exch def
    /ListExtraRotation 0 def
    /ListCTM null def
    /ListCol 0 def
    /ListRow 0 def
    end
   } bind def

   /L2RT2B { //T2B //L2R false //StandardTactic exec } bind def
   /L2RB2T { //B2T //L2R false //StandardTactic exec } bind def
   /R2LT2B { //T2B //R2L false //StandardTactic exec } bind def
   /R2LB2T { //B2T //R2L false //StandardTactic exec } bind def
   /T2BL2R { //L2R //T2B true //StandardTactic exec } bind def
   /B2TL2R { //L2R //B2T true //StandardTactic exec } bind def
   /T2BR2L { //R2L //T2B true //StandardTactic exec } bind def
   /B2TR2L { //R2L //B2T true //StandardTactic exec } bind def

   /TopDown /R2LT2B load def
   /BottomUp /R2LB2T load def
  /RightToLeft /T2BR2L load def
  /LeftToRight /T2BL2R load def
  /BookWise /L2RT2B load def

   /PassThrough 8 dict def
   /PassThrough {
     % data is passed by a sub-dictionary called PassThroughData
     % within the variable data dictionary given to InitImpose.

     currentglobal true setglobal
     //HqnImpose2GlobalDict begin
     PassThroughData {
       1 index /PageList eq {
        dup length dict begin
          {
          dup type /dicttype eq {
            dup length dict begin
            {
              dup type /arraytype eq {
                dup length array copy
              } if
              def
            } forall
            currentdict end
          } if
          def
        } forall
        currentdict end
      } if
      def
     } forall
     /FilmWidth FilmWidth FilmLeft FilmRight add ScaleX div add def
     /FilmHeight FilmHeight FilmBottom FilmTop add ScaleY div add def
    DebugReport {
      (   PassThrough: FilmWidth: )print FilmWidth =print
      (   FilmHeight: )print FilmHeight ==
    } if
     end

    0 1 PagesPerFilm 1 sub {
      PageList exch get begin
      currentdict /ListPosition known not {
        currentdict /ListCTM known {
          ListCTM null eq
        } { true } ifelse
          {
        /Error ShowMessage /missingPosition ShowMessage
        stop
      } if
      } if
      currentdict /ListCTM known not {
        /ListCTM null def
      }  {
        ListCTM null ne {
          % Approximate values for other fields to assist debugging

          //PassThrough begin
          % ListCTM Assumed to be of the form
          % [ Sx.Cos(theta)   Sx.Sin(theta)   0 ]
          % [ -Sy.Sin(theta)  Sy.Cos(theta)   0 ]
          % [ tx              ty              1 ]

          % Recover values of theta, Sx, Sy, tx and ty

          ListCTM aload pop
          { /ty /tx /d /c /b /a }{ exch def } forall

          /theta b a atan def
          /costheta theta cos def
          /sintheta theta sin def

          costheta 0 eq {
            /Sx b sintheta div def
            /Sy c sintheta div neg def
          }  {
            /Sx a costheta div def
            /Sy d costheta div def
          } ifelse

          /ListScale         [ Sx Sy ]
          /ListRotation      theta
          /ListPosition      [ tx ty ]
          end    % PassThrough
          def def def
        } if
      } ifelse

      currentdict /ListPageSize known not {
        /ListPageSize [ PageWidth PageHeight ] def } if
      currentdict /ListPanelOffset known not {
        /ListPanelOffset [ PanelOffsetX PanelOffsetY ] def } if
      currentdict /ListScale known not {
        /ListScale [ PageScaleX PageScaleY ] def } if
      currentdict /ListPageOffset known not {
        /ListPageOffset [ OffsetX OffsetY ] def } if
      currentdict /ListPanelSize known not {
        /ListPanelSize [
          PanelWidth null eq {
            ListPageSize 2 array copy
          }  {
            PanelWidth PanelHeight
          } ifelse
          ] def
      } if
      currentdict /ListRotation known not {
        /ListRotation Rotate
        dup type /booleantype eq {
          { RotatedAngle } { 0 } ifelse
        } if def
      } if
      currentdict /ListClip known not {
        /ListClip null def } if
      currentdict /ListSrcClipPath known not {
        /ListSrcClipPath null def } if
      currentdict /ListSheetClipPath known not {
        /ListSheetClipPath null def } if
      currentdict /ListSheetClipPathOffsets known not {
        /ListSheetClipPathOffsets [ 0 0 ] def } if
      end
    } for

    setglobal
   } bind def

  /FromList {
    % The Objective (or something else) has created a dictionary of 2 element arrays, keyed
    % by page number (integer). Each array is [ row column ]
    0 1 PagesPerFilm 1 sub {
      PageOrder 1 index get aload pop
      PagesUp exch sub 1 sub
      3 -1 roll
      XYpage
    } for
    PropagateSizes
  } bind  def

currentdict end def

/RepeatableTactics <<
  Tactics {
    pop
    dup /PassThrough eq { pop } { null } ifelse
  } forall
>> def

/CancelCurrentPage {
  erasepage
  /CancellingPage true store
  showpage
} bind def

/Responses <<

  /RespondFlush {
    % Flush the current page then set the size.
    //HqnImpose2GlobalDict /FlushingPage true put
    showpage
    true
  } bind

  /RespondClip {
    % Keep the existing page size, warn in case of clipping.
    /Warning ShowMessage /IgnorePageSize ShowMessage
    % (Warning: setpagedevice call attempting to alter PageSize within imposition.)=
    % (         New page size will be ignored.)=
    /PageSize get aload pop
    CropMarks CropsInside and { 2 { CropSpace 2. mul add exch } repeat } if
    /PageHeight exch store
    /PageWidth exch store
    /PanelOffsetX PanelWidth PageWidth sub 2. div store
    /PanelOffsetY PanelHeight PageHeight sub 2. div store
    PropagateSizes
    false  % don't call setpagedevice
  } bind

  /RespondStop {
    % Probably the wrong feature selected for this job.
    /Error ShowMessage /StopRespond ShowMessage
    stop
  } bind

  /RespondPanel {
    % Will the new size fit within the current paneling settings?
    dup
    /PageSize get aload pop
    CropMarks CropsInside and { 2 { CropSpace 2. mul add exch } repeat } if
    2 copy
    PanelHeight gt exch PanelWidth gt
    or  {
      % Won't fit in current panelling system
      pop pop    %  Width and Height
      Responses /RespondFlush get exec
    }  {
      % fits fine - set new page size within panel & offset
      /PageHeight exch store
      /PageWidth exch store
      pop  % dictionary
      /PanelOffsetX PanelWidth PageWidth sub 2. div store
      /PanelOffsetY PanelHeight PageHeight sub 2. div store
      PropagateSizes
      false  % don't call setpagedevice

      DebugReport {
        ( Response:)=
        /Response load dup type /nametype ne { pop (*Procedure*) } if ==
        (   PanelWidth: )print PanelWidth =print
        (, PanelHeight: )print PanelHeight =print
        (, Hor offset: )print PanelOffsetX =print
        (, Vert offset: )print PanelOffsetY ==
        (   Panel PageWidth: )print PageWidth =print
        (, Panel PageHeight: )print PageHeight ==
      } if
    } ifelse
  } bind

  /RespondPending {
    % If the new page is larger than the existing then flush, else wait
    % till end of film.
    dup
    Responses /RespondPanel get exec
    dup not {
      % save new page size for the start of the next film
      exch /PageSize get aload pop
      CropMarks CropsInside and { 2 { CropSpace 2. mul add exch } repeat } if

      //HqnImpose2GlobalDict begin
      /PendingPageHeight exch def
      /PendingPageWidth exch def
      end  % //HqnImpose2GlobalDict
    } { exch pop } ifelse
  } bind

  /RespondScale {
    % Scale all new pages such that they fit within the existing panel
    /PageSize get aload pop
    CropMarks CropsInside and { 2 { CropSpace 2. mul add exch } repeat } if
    /PageHeight exch store
    /PageWidth exch store

    Aspect /BestFit eq { /Rotate null store } if
    ScaleAPage

    PropagateSizes
    DebugReport {
      ( /RespondScale Response:)=
      (   PanelWidth: )print PanelWidth =print
      (, PanelHeight: )print PanelHeight =print
      (, Hor offset: )print PanelOffsetX =print
      (, Vert offset: )print PanelOffsetY ==
      (   Panel PageWidth: )print PageWidth =print
      (, Panel PageHeight: )print PageHeight ==
      (   ScaleX: )print PageScaleX =print
      (, ScaleY: )print PageScaleY ==
    } if
    false
  } bind

  /RespondHalved {
    PagesPerFilm exch
    /BaseAspect Aspect def

    /RequestDict exch def
    mark SensePageDevice cleartomark

    % old PagesPerFilm
    PagesPerFilm exch
    div PageCount mul ceiling cvi /PageCount exch store  % set to point to a different? page

    false  % don't call setpagedevice

    % If we've been thrown on to next film then expose this one.
    PageCount PagesPerFilm ge { FlushFilm } if
  } bind      % RespondHalved

>> def

/SelectPageSize {
  3 index ge exch 4 index ge and {
    % Below min group size
    pop  % array
  }  {
      {
      aload pop
      2 copy 4 index ge exch 5 index ge and {
        % Found the group
        DebugReport {
          (    - SelectPageSize: Replacing )print
          3 index =print ( x )print 2 index =print
          ( with )print 2 copy exch =print
          ( x )print ==
        } if

        4 2 roll pop pop
        exit
      } if
      pop pop
    } forall
  } ifelse
} bind def

/ControlStrategies <<

  /ShortBottomLeft {
    LocFilmWidth LocFilmHeight gt {
      /FilmLeft
    }  {
      /FilmBottom
    } ifelse
  } bind

  /ShortBottomRight {
    LocFilmWidth LocFilmHeight gt {
      /FilmRight
    }  {
      /FilmBottom
    } ifelse
  } bind

  /LongBottomLeft {
    LocFilmHeight LocFilmWidth gt {
      /FilmLeft
    }  {
      /FilmBottom
    } ifelse
  } bind

  /LongBottomRight {
    LocFilmHeight LocFilmWidth gt {
      /FilmRight
    }  {
      /FilmBottom
    } ifelse
  } bind

  % Others could be added for ShortTopLeft etc, or to work out the most
  % efficient placement for a specific device/page size combination.

>> def

/Prefixes 4 dict begin

/PageSizeGroups {
  % to reduce flushing of films when a page size changes, design the
  % film around slightly larger than requested pages, e.g. to accommodate
  % changes between A4 and US letter paper.
  RequestPageWidth RequestPageHeight
  [
    [ 421 612 ]  % A5, statement, B6
    [ 495 685 ]  % " with crops
    [ 612 842 ]  % A4, letter, B5
    [ 685 915 ]  % " with crops
    [ 842 1224 ]  % A3, 11x17, B4
    [ 915 1300 ]  % " with crops
  ]
  360 500    % Ignore below this size
  SelectPageSize
  /PageHeight exch store /PageWidth exch store
  /Suffix load null eq {
    /Suffix /PanelFromOriginal store
  } if
} bind def

/AdjustMargins <<
  /None  {
    /Enabled false def
  } bind
  /FilmLeft {
    /Enabled true def
    /Y BaseX BaseY 0 ge { neg } if def
    /X BaseY BaseY 0 lt { neg } if def
    /Angle BaseAngle 90 BaseY 0 ge { neg } if add def
  } bind
  /FilmRight {
    /Enabled true def
    /Y BaseX BaseY 0 lt { neg } if def
    /X BaseY BaseY 0 ge { neg } if def
    /Angle BaseAngle 90 BaseY 0 lt { neg } if add def
  } bind
  /FilmTop {
    /Enabled true def
    /X BaseX neg def
    /Y BaseY neg def
    /Angle BaseAngle 180 add dup 360 gt { 360 sub } if def
  } bind
  /FilmBottom {
    /Enabled true def
    /X BaseX def
    /Y BaseY def
    /Angle BaseAngle def
  } bind
>> def
/AdjustMargins {
  % This Prefix allows a control strip to be automatically added along the long
  % or short edge of the sheet as desired. The required position is set using
  % ControlStrategy. The space required is set as ControlDepth. It is assumed that
  % all other margins should be set to 0. All marks which include the keys
  % /BaseX, BaseY and BaseAngle in the mark dictionary will be adjusted by this Prefix.
  ControlStrategy /Default ne {
    //ControlStrategies ControlStrategy 2 copy known {
      get

      { /FilmLeft /FilmRight /FilmTop /FilmBottom } { 0 store } forall

      /LocFilmHeight FilmHeight ScaleY mul def
      /LocFilmWidth FilmWidth ScaleX mul def

      exec
      dup /None ne { dup ControlDepth store } if
      //AdjustMargins exch get
      Marks {
        dup /BaseX known {
          begin
          dup exec
          end
        } { pop } ifelse
      } forall
      pop
    }  {
      /Error ShowMessage /UnknownControlStrategy ShowMessage
      =print /CloseError ShowMessage flush
      stop
    } ifelse
  } if
} bind def

/UseOrientation {    % Prefix procedure
  RequestDict /Orientation known {
    /RequestedOrientation RequestDict /Orientation get store
    DebugReport {
      (   RequestedOrientation: )print RequestedOrientation ==
    } if
  } if
  RequestDict /ExtraOrientation known {
    /RequestedExtraOrientation RequestDict /ExtraOrientation get store
    DebugReport {
      (   RequestedExtraOrientation: )print RequestedExtraOrientation ==
    } if
  } if
  RequestedOrientation RequestedExtraOrientation add 2 mod 1 eq {
    % switch page dimensions
    /PanelWidth /PanelHeight dup load exch 2 index load store store
    /PanelOffsetX /PanelOffsetY dup load exch 2 index load store store
    /PageScaleX /PageScaleY dup load exch 2 index load store store
    /PageWidth /PageHeight dup load exch 2 index load store store
  } if
  /Suffix load null eq {
    /Suffix /UseOrientation store
  } if
} bind def  % UseOrientation

currentdict end def

% Called by FixedSizeSheet Suffix procedures to find scale factor.
/GetReducedSize {
  /XDivider MaxWidth 0 gt {
    MaxWidth FilmLeft sub FilmRight sub ScaleX div

    FilmAcrossPerPage PagesAcross mul
    PagesAcross 1 gt {
      PagesAcross 1 sub
      CropMarks { MinVCropGutter } { MinVGutter } ifelse
      mul add
    } if
    div
%    dup 1 gt { pop 1 } if
  } { //MaxInt } ifelse def

  /YDivider MaxHeight 0 gt {
    MaxHeight FilmTop sub FilmBottom sub ScaleY div

    FilmUpPerPage PagesUp mul
    PagesUp 1 gt {
      PagesUp 1 sub
      CropMarks { MinHCropGutter } { MinHGutter } ifelse
      mul add
    } if
    div
%    dup 1 gt { pop 1 } if
  } { //MaxInt } ifelse def
  DebugReport {
    (   XDivider: )print XDivider =print
    (, YDivider: )print YDivider ==
  } if
} bind def

/UseScaleSnap {
  ScaleSnap null ne {
    ScaleSnap 0 get
    ScaleSnap {
      % calc last this
      2 index 1 index lt {
        pop exit
      } if
      exch pop
    } forall
    % calc replace
    exch pop
  } if
} bind def

/CropStrategy {
  XDivider 1 lt YDivider 1 lt or {
    /PageClipped true store

    dup 0 ne YDivider 1 lt and {
      /AdjustY
        MaxHeight FilmTop sub FilmBottom sub ScaleY div
        LocFilmHeight FilmTop sub FilmBottom sub
        sub
        3 -1 roll mul
        store
    } { pop } ifelse
    dup 0 ne XDivider 1 lt and {
      /AdjustX
        MaxWidth FilmLeft sub FilmRight sub ScaleX div
        LocFilmWidth FilmLeft sub FilmRight sub
        sub
        3 -1 roll mul
        store
    } { pop } ifelse
  } { pop pop } ifelse
} bind def

/CropPositions <<
  /AlignTop <<
    /AlignLeft  /TopLeft
    /AlignCenter /TopCenter
    /AlignRight /TopRight
  >>
  /AlignCenter <<
    /AlignLeft  /CenterLeft
    /AlignCenter /CropCenter
    /AlignRight /CenterRight
  >>
  /AlignBottom <<
    /AlignLeft  /BottomLeft
    /AlignCenter /BottomCenter
    /AlignRight /BottomRight
  >>
>> def

/OversizeStrategies 12 dict def
OversizeStrategies begin

  % Trim to show just the bottom left of the page
  /BottomLeft  {
    0 0 //CropStrategy exec
  } bind def

  % Trim to show just the top left of the page
  /TopLeft  {
    0 1 //CropStrategy exec
  } bind def

  % Trim to show just the top right of the page
  /TopRight  {
    1 1 //CropStrategy exec
  } bind def

  % Trim to show just the Bottom right of the page
  /BottomRight  {
    1 0 //CropStrategy exec
  } bind def

  % Trim all edges equally
  /CropCenter {
    .5 .5 //CropStrategy exec
  } bind def

  /TopCenter {
    .5 1 //CropStrategy exec
  } bind def

  /BottomCenter {
    .5 0 //CropStrategy exec
  } bind def

  /CenterLeft {
    0 .5 //CropStrategy exec
  } bind def

  /CenterRight {
    1 .5 //CropStrategy exec
  } bind def

  /Crop {
    //OversizeStrategies
    //CropPositions VertAlign get HorAlign get
    get exec
  } bind def

  % Trim according to ClipOffset (see JDF spec)
  /CropManual {
    ClipOffset type /nulltype eq {
      % Centered
      //CropCenter exec
    }  {
      /AdjustX ClipOffset 0 get neg store
      /AdjustY ClipOffset 1 get neg store
      /PageClipped AdjustX 0 lt AdjustY 0 lt or
    MaxWidth FilmLeft sub FilmRight sub ScaleX div
      LocFilmWidth FilmLeft sub FilmRight sub
          AdjustX ScaleX div lt or
    MaxHeight FilmTop sub FilmBottom sub ScaleY div
      LocFilmHeight FilmTop sub FilmBottom sub
          AdjustY ScaleY div lt or
        store
    } ifelse
  } bind def

  % Scaled in pro to fit.
  /ScaleToFit {
    XDivider YDivider 2 copy gt { exch } if pop
    UseScaleSnap

    dup 1 gt { pop 1 } if
    DebugReport {
      (  ScaleToFit: Scale factor: )print dup ==
    } if

    Tactic dup type /nametype eq {
      //RepeatableTactics exch known
    } { pop false } ifelse
      {
      % The tactic can be repeated, so the gutters can be re-calculated
      /ScaleX ScaleX 2 index mul store
      /ScaleY ScaleY 3 -1 roll mul store

      /FilmWidth
        FilmLeft FilmRight add ScaleX div
        PagesAcross FilmAcrossPerPage mul add
          PagesAcross 1 sub OptVGutter mul add
          dup MaxWidth ScaleX div gt MaxHeight 0 gt and {
            pop MaxWidth ScaleX div
          } if
        store
      PagesAcross 1 gt {
        /VerticalGutter
          FilmWidth
          FilmLeft FilmRight add ScaleX div sub
          PagesAcross FilmAcrossPerPage mul sub
          PagesAcross 1 sub div store
      } if
      /FilmHeight
        FilmTop FilmBottom add ScaleY div
        PagesUp FilmUpPerPage mul add
          PagesUp 1 sub OptHGutter mul add
          dup MaxHeight ScaleY div gt MaxHeight 0 gt and {
            pop MaxHeight ScaleY div
          } if
        store
      PagesUp 1 gt {
        /HorizontalGutter
          FilmHeight
          FilmTop FilmBottom add ScaleY div sub
          PagesUp FilmUpPerPage mul sub
          PagesUp 1 sub div store
      } if

      DebugReport {
        (   Hor Gutter:  )print HorizontalGutter =print (, Vert Gutter:  )print VerticalGutter ==
      } if

      % Have changed gutters, therefore need to recalculate page positions ##########################################
      RunTactic
    }  {
      % The tactic cannot be safely repeated, or does not depend on gutter calculations

      /ScaleX ScaleX 2 index mul store
      /ScaleY ScaleY 3 -1 roll mul store
    } ifelse

    pagedevicePassBack /Scaling [ ScaleX AAlias mul ScaleY AAlias mul ] put
    DebugReport {
      (   FilmWidth:  )print FilmWidth =print ( \( = )print FilmWidth ScaleX mul =print (\))=
      (   FilmHeight:  )print FilmHeight =print ( \( = )print FilmHeight ScaleY mul =print (\))=
    } if
  } bind def

  % Multiple names for backwards compatibility
  /SimpleScaleToFit //ScaleToFit def
  /SelectorScaleToFit //ScaleToFit def
  /ComplexScaleToFit //ScaleToFit def

  % This job's no good if we can't fit it on.
  % Issue any report in the system monitor etc in OversizeCallback if desired.
  /AbortJob {
    serverdict /terminatejobnow get exec
  } bind def

  % An improvement on AbortJob - this one will only abort when the first graphic object is drawn
  % on the page, because many jobs set the page size several times, and it's better not to abort
  % because one of those is too big if the 'real' size is not.
  /AbortOnGraphics {
    //HqnImpose2GlobalDict /AbortOversize true put
  } bind def

end   % OversizeStrategies

/Suffixes 5 dict begin

/PanelFromOriginal {
  % The original page size was adjusted from the requsted size,
  % probably in a Prefix procedure. The original size will now
  % be re-instated, if necessary by panelling within the calculated
  % size.
  /PageWidth
  RequestPageWidth RequestPageHeight
  2 copy
  PageHeight exch sub 2. div PanelOffsetY add /PanelOffsetY exch store
  PageWidth exch sub 2. div PanelOffsetX add /PanelOffsetX exch store
  /PageHeight exch store store
  DebugReport {
    ( /PanelFromOriginal Suffix:)=
    (   PanelWidth: )print PanelWidth =print
    (, PanelHeight: )print PanelHeight =print
    (, Hor offset: )print PanelOffsetX =print
    (, Vert offset: )print PanelOffsetY ==
    (   Panel PageWidth: )print PageWidth =print
    (, Panel PageHeight: )print PageHeight ==
  } if
  PropagateSizes
} bind def

/ScaleToPanel {
  % Scale the PageWidth and PageHeight to fit in the panel
  Aspect /BestFit eq { /Rotate null store } if
  ScaleAPage

  PropagateSizes
  DebugReport {
    ( /ScaleToPanel Suffix:)=
    (   PanelWidth: )print PanelWidth =print
    (, PanelHeight: )print PanelHeight =print
    (, Hor offset: )print PanelOffsetX =print
    (, Vert offset: )print PanelOffsetY ==
    (   Panel PageWidth: )print PageWidth =print
    (, Panel PageHeight: )print PageHeight ==
    (   ScaleX: )print PageScaleX =print
    (, ScaleY: )print PageScaleY ==
  } if
} bind def

/UseOrientation {
  % switch page dimensions
  /PanelWidth /PanelHeight dup load exch 2 index load store store
  /PanelOffsetX /PanelOffsetY dup load exch 2 index load store store
  /PageScaleX /PageScaleY dup load exch 2 index load store store
  /PageWidth /PageHeight dup load exch 2 index load store store
} bind def
/UseOrientation [
    {
    false
  }
    % 90 degrees, but if BestFit or whatever has already
    % spun by 90 then snap back to upright rather than
    % upside down, just for convenience.
    {
    //UseOrientation exec
    /Rotate Rotate 450 add 360 mod store
    true
  } bind
    {
    /Rotate Rotate 540 add 360 mod store
    true
  } bind
    {
    //UseOrientation exec
    /Rotate Rotate 630 add 360 mod store
    true
  } bind
] def
/UseOrientation {  % Suffix procedure
  % We've included any orientation we wanted already.
    {
    /Orientation /ExtraOrientation
  }  {
    pagedevicePassBack exch undef
  } forall
  DebugReport {
    (   Spin factor: )print
      RequestedOrientation RequestedExtraOrientation add 4 mod ==
  } if
  //UseOrientation RequestedOrientation RequestedExtraOrientation add 4 mod get exec

  { CoreInstallPageSizes } if
} bind def  % UseOrientation

/FixedSizeSheet {
  % MaxHeight and MaxWidth must be defined
  % MinHeight and MinWidth may be defined
  % If the page is larger than MaxWidth/MaxHeight then OversizeStrategy will be acted on.

  /XDivider 1 store /YDivider 1 store

  % We've included any orientation we wanted already.
    {
    /FilmSaving /TimeSaving
    % /Orientation /ExtraOrientation done in UseOrientation
  }  {
    pagedevicePassBack exch undef
  } forall

  //UseOrientation exec  % This is safe even if UseOrientation
              % Prefix was not used.

  DebugReport {
    (   MinWidth:  )print MinWidth =print
    (, MinHeight: )print MinHeight ==
    (   MaxWidth:  )print MaxWidth =print
    (, MaxHeight: )print MaxHeight ==
  } if

  /InitialFilmHeight FilmHeight def
  /InitialFilmWidth FilmWidth def

  % Now check if we're over the max size
  FilmHeight MaxHeight ScaleY div sub SheetSlop 1 //PixelPoints exec gt MaxHeight 0.1 gt and
  FilmWidth MaxWidth ScaleX div sub SheetSlop 0 //PixelPoints exec gt MaxWidth 0.1 gt and
  or {
    /LocFilmHeight FilmHeight def
    FilmHeight MaxHeight ScaleY div gt MaxHeight 0.1 gt and {
      /FilmHeight MaxHeight ScaleY div store
    } if
    /LocFilmWidth FilmWidth def
    FilmWidth MaxWidth ScaleX div gt MaxWidth 0.1 gt and {
      /FilmWidth MaxWidth ScaleX div store
    } if

    GetReducedSize

    /OversizeStrategy load dup null eq { pop /BottomLeft } if
    DebugReport {
      (   OversizeStrategy:  )print dup ==
    } if
    dup type /nametype eq {
      //OversizeStrategies exch { get } //stopcheck exec {
        /Error ShowMessage /UnknownOversize ShowMessage =print
        /CloseError ShowMessage flush
        serverdict /terminatejobnow get exec
      } if
    } if

    mark exch //stopcheck exec {
      /Error ShowMessage /runOversizeStrategy ShowMessage
      ReportError
      serverdict /terminatejobnow get exec
    } if
    cleartomark
    mark { OversizeCallback } //stopcheck exec {
      /Error ShowMessage /runOversizeCallback ShowMessage
      ReportError
      serverdict /terminatejobnow get exec
    } if
    cleartomark
  } if

  % Check we're up to the min size. If either of the CenterOnmedia~ keys are
  % set in the page device then center the page images on the flat.
  % Note that this does *NOT* move control marks.
  MinHeight MaxHeight gt MaxHeight 0.1 gt and { MaxHeight }{ MinHeight } ifelse
  dup 0.1 gt {
    ScaleY div
    FilmHeight
    2 copy gt {
        <<
        /AlignBottom {
        pop 0
        }
        /AlignCenter {
          1 index exch sub 2. div
        } bind
        /AlignTop {
          1 index exch sub
        } bind
      >> VertAlign get exec
      /AdjustY exch ScaleY mul 1 SnapDevice store
      /FilmHeight exch store
    }  {
      pop pop
    } ifelse
  } { pop } ifelse

  MinWidth MaxWidth gt MaxWidth 0.1 gt and { MaxWidth }{ MinWidth } ifelse
  dup 0.1 gt {
    ScaleX div
    FilmWidth
    2 copy gt {
        <<
        /AlignLeft {
          pop 0
        }
        /AlignCenter {
          1 index exch sub 2. div
        } bind
        /AlignRight {
          1 index exch sub
        } bind
      >> HorAlign get exec
      /AdjustX exch ScaleX mul 0 SnapDevice store
      /FilmWidth exch store
    }  {
      pop pop
    } ifelse
  } { pop } ifelse

  AdjustX AdjustY add 0 ne {
    DebugReport {
      (   AdjustX:  )print AdjustX =print
      (, AdjustY: )print AdjustY ==
    } if
  } if
  DebugReport {
    (   FilmWidth:  )print FilmWidth =print
    (, FilmHeight: )print FilmHeight ==
    (   FilmLeft:  )print FilmLeft =print
    (, FilmBottom: )print FilmBottom =print
    (, FilmTop: )print FilmTop =print
    (, FilmRight: )print FilmRight ==
  } if
} bind def

currentdict end def

% The trailer proc is called at the end of every film.
% The default proc sets top, left and bottom margins to
% minimize film wastage.
/Trailer {
% (TR>>)= flush
  mark
    {
    1183615869 internaldict begin
    pagebbox
    end  % internaldict
  } //stopcheck exec {
    % Don't show this last page - there's nothing on it.
    $error /newerror false put
    cleartomark
    end  % internaldict
    /runsafereturn false def
    DebugReport {
      (\nTrailer: BLANK PAGE)=
    } if

  }  {
    % sort. llx may be higher than urx etc.
    3 -1 roll 2 copy gt { exch } if
    /ury exch def /lly exch def
    2 copy gt { exch } if
    /urx exch def /llx exch def
    % Fill clipped-off areas with gray, debug use only.
    % clippath llx lly moveto urx lly lineto urx ury lineto llx ury lineto closepath .8 setgray fill

    currentpagedevice
    dup /Margins get /Margins exch def
    dup /HWResolution get aload pop
      /YResolution exch 72. div def
      /XResolution exch 72. div def

    % Account for rotation
    /Mirror 1 index /MirrorPrint get def
    /Orient 1 index dup /ExtraOrientation get exch /Orientation get add 4 mod def
    FilmWidth FilmHeight Orient 2 mod 0 ne { exch } if
    { /FilmVert /FilmHoriz } { exch def } forall
    pop    % currentpagedevice

% { /llx /lly /urx /ury /MaxLeftMargin /MaxBottomMargin /MaxRightMargin /MaxTopMargin } { dup =print (  )print load == } forall
     llx MaxLeftMargin gt { /llx MaxLeftMargin def } if
     lly MaxBottomMargin gt { /lly MaxBottomMargin def } if
     urx MaxRightMargin lt { /urx MaxRightMargin def } if
     ury MaxTopMargin lt { /ury MaxTopMargin def } if

    {   {
      llx lly urx ury
    }   {
      FilmHeight ury sub
      llx
      FilmHeight lly sub
      urx
    }  {
      FilmWidth urx sub
      FilmHeight ury sub
      FilmWidth llx sub
      FilmHeight lly sub
    }  {
      lly
      FilmWidth urx sub
      ury
      FilmWidth llx sub
    } }
    Orient get exec
    { /ury /urx /lly /llx } { exch def } forall

    % and for mirroring:
    Mirror {
      FilmHoriz
      /llx exch urx 1 index llx sub
      /urx exch def sub def
    } if

    (%pagebuffer%)
    <<
      /LeftMargin
        llx
        XResolution mul
        ScaleX mul
        Orient dup 1 eq exch 2 eq or Mirror xor {
          FilmHoriz ScaleX mul ClippedWidth sub dup 0 gt {
            % Page has been trimmed to device size
            XResolution mul sub
          } { pop } ifelse
        } if
        neg
        dup 0 gt { pop 0 } if
        Margins 0 get add
        round cvi

      /RightMargin
        urx FilmHoriz sub
        XResolution mul
        ScaleX mul

        Orient dup 0 eq exch 3 eq or Mirror xor  {
          FilmHoriz ScaleX mul ClippedWidth sub dup 0 gt {
            % Page has been trimmed to device size
            XResolution mul add
          } { pop } ifelse
        } if

        dup 0 gt { pop 0 } if
        DeviceType /deviceTypePartDrum eq Margins length 3 ge and {
          Margins 2 get add
        } if
        round cvi

      DebugReport {
        (\nTrailer:\n   )print flush
        3 index =print (: )print 2 index ==
        (   )print 2 copy exch =print (: )print ==
      } if

      % Don't set -ve top and bottom margins if we're already trimming
      currentpagedevice /TrimPage get not {
        /BottomMargin
          lly
          YResolution mul
          ScaleY mul
          Orient dup 2 eq exch 3 eq or {
            FilmVert ScaleY mul ClippedHeight
            sub dup 0 gt {
              % Page has been trimmed to device size
              YResolution mul
              sub
            } { pop } ifelse
          } if

          neg
          dup 0 gt { pop 0 } if
          DeviceType /deviceTypeCapstan eq Margins length 4 ge and {
            Margins 3 get add
          } if
          round cvi

        /TopMargin
          ury FilmVert sub
          YResolution mul
          ScaleY mul

          Orient 2 lt {  % 0 or 1
            FilmVert ScaleY mul ClippedHeight sub dup 0 gt {
              % Page has been trimmed to device size
              YResolution mul
              add
            } { pop } ifelse
          } if

          dup 0 gt { pop 0 } if
          Margins 1 get add
          round cvi

        DebugReport {
          (   )print 3 index =print (: )print 2 index ==
          (   )print 1 index =print (: )print dup ==
        } if
      } if

      /Password 0
    >> setdevparams
    cleartomark  % cleans up unused items from pagebbox
    /runsafereturn true def
  } ifelse
% (>>TR )print runsafereturn ==
} bind def

% ColorantList returns an array of dictionaries. All contain the keys Name
% and CMYK, and they are presented in the laydown order.
/ColorantList << /Name null /CMYK null /Omit null >> def
1183615869 internaldict begin  % to get at currentseparationorder
/ColorantList {
  mark
  //ColorantList //currentseparationorder {
    % Array of dictionaries on the stack
      {
      dup /Omit get {
        % Don't include a blank separation which will be omitted
        pop
      }  {
        dup /CMYK get
        false exch {
          0 lt { pop true exit } if
        } forall
          {
          pop
        }  {
          dup /Name get
          % [ dicts... thisdict name
          2 1 counttomark 4 sub {
            index /Name get 1 index eq {
              pop
              exit
            } if
          } for
          pop    % thisdict if name was seen before,
              % name if it was not
        } ifelse
      } ifelse
    } forall
  } forall
  ]
} bind
end def

/BasicTintTransform {
  % Called with "X [ C M Y K ]" on the stack
    {
    1 index mul exch
  } forall
  pop
} bind def

% Procedures to be called before or after all pages on a film
% have been drawn.
/FilmUnderlay  {  } def
/FilmOverlay  {  } def

% Procedures to be called before or after each page
% have been drawn. Called immediately after cropmark
% BeginPage and EndPage calls (if crops are being used as well).
/PageUnderlay  {  } def
/PageOverlay  {  } def

% In order to allow imposition features to be combined with
% other things requiring SensePageDevice (e.g. ignore job
% resolution etc), these procs may be defined. One's run during
% initialisation, the other during every SensePageDevice.
/InitExtra  {  } def
/SensePageDeviceExtra {  } def
/SensePageDeviceInit {} def
/PriorSensePage  null def
/EndPageExtra  {} def

% Objectives and Tactics can add pagedevice key/value pairs to this
% dictionary - they are then passed back to setpagedevice from
% the end of SensePageDevice
/pagedevicePassBack 1 dict def

/ReportError {
  % error handling inside pagedevice tends to loop a bit ...
  //HqnImpose2GlobalDict /HqnStopImpose get not {
    //HqnImpose2GlobalDict /HqnStopImpose true put
    userdict begin defaulthandleerror end
  } if
} bind def

/runsafereturn null def

/runsafe {
% (>>RS: )print dup ==
  % All crop mark and ..erlay procs are run through here.
  % NOTE: this does not call either gsave or save - procs are
  %  recommended to do this themselves.
  /safename 1 index def
  mark exch load
  //stopcheck exec {
    //HqnImpose2Dict begin
    /Error ShowMessage /Imposition ShowMessage
    safename =print /CloseError ShowMessage
    ReportError
    end % HqnImpose2Dict
  } if
  cleartomark
% (RS>>)=
} bind def

% Is this film potentially the back of a duplex set?
/IsBack {
  FilmCount 2 mod 1 eq
} bind def
% Would this sheet be tumbled by the printer hardware?
/HardwareTumble {
  FilmHeight FilmWidth gt
  currentpagedevice begin ExtraOrientation Orientation end add 2 mod 1 eq { not } if
} bind def

/InitGraphics {
  initgraphics
  IsBack Duplex and {
    % May need to rotate for duplex back.
    RedBookTumble {
      true
    }  {
      FilmWidth FilmHeight le
    } ifelse
    Tumble eq
    HardwareTumble ne {
      FilmWidth ScaleX div FilmHeight ScaleY div translate
      180. rotate
    } if
  } if
} bind def

/ScalePage {
  ScaleAspect /BestFit eq {
    FilmWidth FilmHeight gt ScaleWidth ScaleHeight gt ne {
      % rotate the page
      pagedevicePassBack /ExtraOrientation
      2 copy known {
        2 copy get 1 add
      }  {
        1
      } ifelse
      put
    } if
  } if

  ScaleWidth FilmWidth div
  ScaleHeight FilmHeight div
    dup 0 eq { pop dup } {
      1 index 0 eq {
        exch pop dup
      } {
         ScaleMode /ScaleFit eq {
          2 copy gt { exch } if
          pop dup
        } if
      } ifelse
    } ifelse

  % stack: X scaling, Y scaling
  % Adjust Scaling page device param
  pagedevicePassBack /Scaling [
    ScaleX 5 index mul AAlias mul
    ScaleY 5 index mul AAlias mul
    ] put

  % Adjust Film size to match aspect ratio and center scaled output if not stretched.
  ScaleHeight 0 gt {
      FilmHeight mul ScaleHeight exch sub
      /FilmHeight FilmHeight 2 index add store
      2. div /FilmBottom exch FilmBottom add store
    } { pop } ifelse

    ScaleWidth 0 gt {
      FilmWidth mul ScaleWidth exch sub
      /FilmWidth FilmWidth 2 index add store
      2. div /FilmLeft exch FilmLeft add store
    } { pop } ifelse
} bind def

/PropagateSizes  {
  0 1 PagesPerFilm 1 sub {
    PageList exch get begin
    [ PageWidth PageHeight ] ListPageSize copy pop
    [ PanelOffsetX PanelOffsetY ] ListPanelOffset copy pop
    [ PageScaleX PageScaleY ] ListScale copy pop
    [ OffsetX OffsetY ] ListPageOffset copy pop
    [ PanelWidth PanelHeight ] ListPanelSize copy pop
    /ListClip ClipPath def
    /ListGutterClip GutterClip def
    /ListSrcClipPath SrcClipPath def
    /ListSheetClipPath SheetClipPath def
    /ListSheetClipPathOffsets SheetClipPathOffsets def
    end
  } for
} bind def

/CoreInstallPageSizes {
  DebugReport {
    (   FilmWidth: )print FilmWidth =print
      (, PagesAcross: )print PagesAcross =print
      (, Vert Gutter: )print VerticalGutter ==
    (   FilmHeight: )print FilmHeight =print
      (, PagesUp: )print PagesUp =print
      (, Hor Gutter: )print HorizontalGutter ==
    (   PanelWidth: )print PanelWidth =print
      (, PanelHeight: )print PanelHeight =print
      (, Hor offset: )print PanelOffsetX =print
      (, Vert offset: )print PanelOffsetY ==
      (   Panel PageWidth: )print PageWidth =print
        (, Panel PageHeight: )print PageHeight ==
    ScaleX 1 ne ScaleY 1 ne or {
      (   ScaleX: )print ScaleX =print
      (, ScaleY: )print ScaleY ==
    } if
    PageScaleX 1 ne PageScaleY 1 ne or {
      (   PageScaleX: )print PageScaleX =print
      (, PageScaleY: )print PageScaleY ==
    } if
    LimitPageCount 0 ne {
      (   Page count limited to: )print LimitPageCount ==
    } if
    (   Rotate: )print Rotate ==
    flush
  } if

  % Now initialise PageList, based on results from Objective
  0 1 PagesPerFilm 1 sub {
    PageList exch 2 copy known {
      get begin
      DefaultPageList {
        exec
        dup type /arraytype eq {
          exch load copy pop
        }  {
          def
        } ifelse
      } forall
      end
    }  {
      currentglobal true setglobal
      DefaultPageList dup length dict begin
      { exec def } forall
      setglobal
      currentdict
      end
      put
    } ifelse
  } for

  % Tactic can be defined in the feature or an Objective
  % but most will leave as default - to be based on
  % the DeviceType.
  % It can be a procedure, a name of an entry in the Tactics
  % dictionary or null.
  /Tactic load null eq {
    /Tactic DeviceType /deviceTypePartDrum eq TimeSaving not and
      {
      currentpagedevice /MirrorPrint get { /LeftToRight }{ /RightToLeft } ifelse
    }  {
      /TopDown
    } ifelse
    store
  } if

  RunTactic
} bind def

/ReportPageArray {
  DebugReport {
    (\n Page Array:)=
    0 1 PagesPerFilm 1 sub {
      (    )print dup 1 add =print (:  )print
      PageList exch get begin
      (Pos [ )print ListPosition aload pop exch =print (  )print =print ( ], )print
%      (\tPage [ )print ListPageSize aload pop exch =print (  )print =print ( ], )print
%      (\tPanel [ )print ListPanelSize aload pop exch =print (  )print =print ( ], )print
      (\tScale [ )print ListScale aload pop exch =print (  )print =print ( ],)print
%      ( \tClip [ )print ListClip dup type /nulltype eq { pop (Null  )print }{ { =print (  )print } forall } ifelse (], )print
      (\tRot )print ListRotation =print
%      (\tCTM )print ListCTM =print
      currentdict /ListCol known { (\tCol )print ListCol =print (, Row )print ListRow =print } if          % ####################################
      ()=
      end
    } for
  } if
} bind def

/RunTactic {
  DebugReport { (   Tactic: )print /Tactic load
    dup type /nametype ne { pop (*Procedure*) } if ==} if

  /Tactic load dup type /nametype eq {
    //Tactics exch get
  } if

  //stopcheck exec {   % Tactic proc.
    /Error //ShowMessage exec /Tactic //ShowMessage exec
    % (Error: while running imposition Tactic procedure)=
    //ReportError exec
    serverdict /terminatejobnow get exec
  } if

  ReportPageArray
} bind def

/InstallPageSizes {
  % This sets up a few commonly used variables and calls the Tactic
  % procedure. It's split out to here because a few other oddments
  % may sometimes need it, like RespondHalved.
  /Aspect BaseAspect store

  ScaleMode /None ne {
    ScalePage
  }  {
    pagedevicePassBack /Scaling [ ScaleX AAlias mul ScaleY AAlias mul ] put
  } ifelse

  PagesUp 0 le { /PagesUp 1 store } if
  PagesAcross 0 le { /PagesAcross 1 store } if

  /PagesPerFilm PagesUp PagesAcross mul
    dup LimitPageCount gt LimitPageCount 0 ne and {
      pop LimitPageCount
    } if store

  % Gutters etc. are likely to be uniform and required
  % by tactics.
  PanelWidth null eq {
    /PanelWidth PageWidth store
    /PanelHeight PageHeight store
    /PanelOffsetX 0 store
    /PanelOffsetY 0 store
    /PageScaleX 1. store
    /PageScaleY 1. store
  } if

  /FilmUpPerPage //by90 exec { PanelWidth }{ PanelHeight } ifelse def
  /FilmAcrossPerPage //by90 exec { PanelHeight }{ PanelWidth } ifelse def

  % Backstop for big pages
  StandardBackstop PagesPerFilm 1 eq and Aspect /BestFit eq and {
    FilmUpPerPage FilmHeight ScaleY div FilmTop sub FilmBottom sub gt
    FilmAcrossPerPage FilmWidth ScaleX div FilmLeft sub FilmRight sub gt
    or {
      FilmUpPerPage FilmAcrossPerPage ge
      FilmHeight FilmWidth ge ne {
        /Rotate Rotate 90. sub dup 0 lt { 180 add } if store
        /FilmUpPerPage FilmAcrossPerPage
        /FilmAcrossPerPage FilmUpPerPage
        def def
      } if
    } if
  } if

  /VerticalGutter PagesAcross 1 gt {
    FilmWidth FilmLeft FilmRight add ScaleX div sub
    PagesAcross FilmAcrossPerPage mul sub
    PagesAcross 1 sub div
  }  {
    0
  } ifelse def

  /HorizontalGutter PagesUp 1 gt {
    FilmHeight FilmTop FilmBottom add ScaleY div sub
    PagesUp FilmUpPerPage mul sub
    PagesUp 1 sub div
  }  {
    0
  } ifelse def

  % Define the dict if it hasn't already been done.
  PageList type /nulltype eq {
    currentglobal true setglobal
    //HqnImpose2GlobalDict /PageList PagesPerFilm dict put
    setglobal
  } if

  //CoreInstallPageSizes exec
} bind def


/ClearMarginValues {
  //HqnImpose2GlobalDict begin
  /MaxLeftMargin FilmWidth def
  /MaxTopMargin 0 def
  /MaxRightMargin 0 def
  /MaxBottomMargin FilmHeight def
  end
} bind def

/TestMargins {
  2 copy
  dup MaxTopMargin gt { /MaxTopMargin exch store }{ pop } ifelse
  dup MaxRightMargin gt { /MaxRightMargin exch store }{ pop } ifelse
  dup MaxBottomMargin lt { /MaxBottomMargin exch store }{ pop } ifelse
  dup MaxLeftMargin lt { /MaxLeftMargin exch store }{ pop } ifelse
} bind def

/OpenAngle (<) def

/IfSkip <<
  (<)0 get { 1 1 index length 1 sub getinterval } bind
  (#)0 get { 2 1 index length 2 sub getinterval } bind
  (+)0 get { 3 1 index length 3 sub getinterval } bind
  (!)0 get {
    /IfLevel dup load 1 sub def
    1 1 index length 1 sub getinterval
  } bind
  (?)0 get {
    /IfLevel dup load 1 add def
  } bind
  (:)0 get {
    IfLevel 1 eq {
      /IfLevel 0 def
      1 1 index length 1 sub getinterval
    } if
  } bind
>> def
/IfSkip {
  % Skip to <: or <!
  /IfLevel 1 def
    {
    //OpenAngle search {
      pop pop
      //IfSkip 1 index 0 get 2 copy known {
        get exec
      } { pop pop } ifelse
    }  {
      /Error ShowMessage /NoEndif ShowMessage
      % (Error: No endif in ControlText string)
      serverdict /terminatejobnow get exec
    } ifelse
    IfLevel 0 le { exit } if
  } loop
} bind def

% These font types can be re-endcoded.
/ReEncode << { 1 3 5 32 42 111 } { null } forall >> def
/RecordEncoding {
  TextEncodings 0
  //ReEncode 3 index /FontType get known {
    2 index /Encoding 2 copy known { get }{ pop pop null }ifelse
    dup gcheck not {
      currentglobal true setglobal exch
      dup length array copy
      exch setglobal
    } if
  }  { null } ifelse
  put
} bind def
/ReEncode {
  TextFont findfont
  dup /FontType get
  % encod fdict type
  //ReEncode exch known {
    % can be re-encoded
    dup length dict copy
    dup /Encoding 4 -1 roll
    dup type dup /nametype eq exch /stringtype eq or {
      findencoding
    } if
    put
    dup /FID undef
    dup /UniqueID undef
    TextFont exch definefont
    TextSize scalefont setfont
  }  {
    % Can't re-encode
    pop pop
  } ifelse
} bind def

/ExtractString (>) def
/ExtractString {
  //ExtractString search {
    exch pop
  }  {
    /Error ShowMessage /UnterminatedComand ShowMessage
    stop
  } ifelse
} bind def

/ExtractNumber {
  //ExtractString exec
  mark exch
  { token not { exit } if exch } loop
  counttomark 1 ne
  1 index type dup /integertype ne exch /realtype ne and or {
    /Error ShowMessage /InvalidCommandNumber ShowMessage
    stop
  } if
  exch pop    % The mark
} bind def

/TextShowCore {
  gsave
  Monochrome { 1 setgray }{ 0 RegisterColor } ifelse
  1 setlinejoin 1 setlinecap TextSize 12 div setlinewidth
  dup true charpath stroke
  grestore
  show
} bind def

/FontStyles [ /Plain /Emphasis /Narrow /NarrowEmphasis /Monospace /MonospaceEmphasis ] def

/ControlTextShow {
  % string
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    //TranslateChars_1 exec
    TextSize scalefont setfont
  } if
  //TextShowCore exec
} bind def

/StandardTextShow {
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    //TranslateString_1 exec
    TextSize scalefont setfont
  }   {
    //Translate exec
  } ifelse
  //TextShowCore exec
} bind def

/GUITextShow {
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    TransformGUI_1
    TextSize scalefont setfont
  } if
  //TextShowCore exec
} bind def

/FixedTextShow {
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    /PDFDoc Transform_1
    TextSize scalefont setfont
  } if
  //TextShowCore exec
} bind def

/separators << (/)0 get null (%)0 get null >> def
/backslash (\\)0 get def

/IsOversize {
  PageScaleX Rotate 0.001 gt { ScaleY }{ ScaleX } ifelse mul
  PageScaleY Rotate 0.001 gt { ScaleX }{ ScaleY } ifelse mul
  1. sub abs 0.001 gt exch 1. sub abs 0.001 gt or
  PageClipped or
} bind def

/IsColorManaged (No Color Management) def
/IsColorManaged {
  <</Type //IsColorManaged>> /HCMS //GetPageSetup exec
  %1183615869 internaldict /PageSetup get /HCMS get
  /Type get //IsColorManaged ne
} bind def

/IsUserDefined <<
  /PS { statusdict /ForDSC known } bind
  /EPS 1 index
  /PDF {
    mark { currentpdfcontext } //stopcheck exec {
      cleartomark false
    }  {
      exch pop
      /ContextID get
      1183615869 internaldict /getPDFinfo get exec
      /Author known
    } ifelse
  } bind
>> def
/IsUserDefined {
  //IsUserDefined 1183615869 internaldict /fileType get
  2 copy known {
    get exec
  }  {
    pop pop false
  } ifelse
} bind def

/GetUser <<
  /PS {
    statusdict /ForDSC
    2 copy known { get }{ pop pop null } ifelse
  } bind
  /EPS 1 index
  /PDF {
    mark { currentpdfcontext } //stopcheck exec {
      cleartomark null
    }  {
      exch pop
      /ContextID get
      1183615869 internaldict /getPDFinfo get exec
      /Author 2 copy known { get }{ pop pop null } ifelse
    } ifelse
  } bind
>> def

/SinglePage {
  HqnImpose2GlobalDict /PageList get length 1 eq
} bind def

/IsContone {
  currentpagedevice /Halftone get not
} bind def

/FileTypeDate <<
% keyed by file type. Each proc returns (date) true or false

  /PS {
    statusdict /DateDSC 2 copy known {
      get
      dup length 0 gt { true } { pop false } ifelse
    } { pop pop false } ifelse
  } bind

1183615869 internaldict begin
  /PDF {
    mark { currentpdfcontext } //stopcheck exec {
      cleartomark false
    }  {
      exch pop
       /ContextID get
      dup getPDFinfo
      dup /ModDate known {
        /ModDate get true
      }  {
        dup /CreationDate known {
          /CreationDate get true
        } { pop false } ifelse
      } ifelse
      dup  {
        pop
        dup type /pdfobjtype eq { getPDFobject } { exch pop } ifelse
        true
      } { exch pop } ifelse
    } ifelse
  } bind
end
  % #############

>> def

/GetImposition mark /HqnLayout /ProcSet resourcestatus {
  cleartomark
  % Can't pre-load here, because HqnImpose2 may be being loaded while
  % loading HqnLayout, leading to recursion.
  { /HqnLayout /ProcSet findresource /ImpositionName get exec }
}  {
  cleartomark { null }
} ifelse def

/IsSetup {
  1183615869 internaldict /PageSetup 2 copy known {
    get exch get //NoneString ne
  } { pop pop pop false } ifelse
} bind def

/IsImpositionKnown {
  //GetImposition exec
  null ne
} bind def

/IsTrappingKnown {
  /TrapType //IsSetup exec
} bind def

/IsCalKnown {
  /CalibrationSet //IsSetup exec
} bind def

/IsToneKnown {
  /ToneCurves //IsSetup exec
} bind def

/IsActualKnown {
  currentpagedevice /SeparationDetails get /SeparationStyle get
  dup 0 ne exch 1 ne and { false } {
    /ActualDotGain //IsSetup exec
  } ifelse
} bind def

/IsIntendedKnown {
  currentpagedevice /SeparationDetails get /SeparationStyle get
  dup 0 ne exch 1 ne and { false } {
    /IntendedDotGain //IsSetup exec
  } ifelse
} bind def

/IsDateKnown {
   1183615869 internaldict /fileType
  2 copy known { get } { pop pop /PS } ifelse
   //FileTypeDate exch 2 copy known {
     get exec
     dup { exch pop } if
  }  {
    % Don't know how to get mod date from this file type
    pop pop
    false
  } ifelse
} bind def

/GetFileName {
  1183615869 internaldict /fileObject 2 copy known {
    % Includes path ...
    get
  }  {
    pop pop
    serverdict /stdin get
  } ifelse
  statusdict begin //ImpoString filename pop end
} bind def

/GetJobName {
  % bool -> GetJobName -> name
  % bool controls whether the user will be stripped from a PostScript job name
  statusdict /jobname get dup type /stringtype ne {
    pop currentpagedevice /JobName get dup type /stringtype ne {
      pop
      //Messages /Untitled get
    } if
  } if

  exch {
    % Strip the '<user>; document: ' section.
    dup (;) search {
      pop pop (:) search {
        pop pop
        exch pop
      }  {
        pop
      } ifelse
    }  {
      pop
    } ifelse
  } if
} bind def

/IsScaled {
  PageScaleX Rotate 0.001 gt { ScaleY }{ ScaleX } ifelse mul
  PageScaleY Rotate 0.001 gt { ScaleX }{ ScaleY } ifelse mul
  1. sub abs 0.001 gt exch 1. sub abs 0.001 gt or
} bind def

/DiffJobFileName {
  GetFileName StripFileName_1
  true GetJobName
  ne
} bind def

/NonHPS <<
  { (HEDS) (HDS) }{ dup } forall
>> def

/FreqUnits <<
  (lpi) {}
  (lpcm) { 2.54 div } bind
  (lpmm) { 25.4 div } bind
>> def

/ScreenNames <<
  (Line90)  (Line 90)
  (HexChain) (Hexachrome Chain)
  (HDS-A) (HDS Super F)
  (HDS-B) (HDS Fine)
  (HDS-C) (HDS Medium)
  (HDS-D) (HDS Coarse)
  (HDS-E) (HDS Super C)
  (Hds-a6) (Hex HDS Super F)
  (Hds-b6) (Hex HDS Fine)
  (Hds-c6) (Hex HDS Medium)
  (Hds-d6) (Hex HDS Coarse)
  (Hds-e6)  (Hex HDS Super C)
>> def

/SetupName {
  1183615869 internaldict /PageSetup 2 copy known{
    get exch get //GUITextShow exec
  }  {
    pop pop pop
    //Messages /NoPageSetup get //GUITextShow exec
  }ifelse
} bind def

/ControlTextTags 60 dict def
ControlTextTags begin

%  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UPPER CASE

  (A)0 get {    %  A: Anti-Alias factor
    currentpagedevice /ResamplingFactor get
    dup 1 eq {
      pop    % 1
      //Messages /None get //StandardTextShow exec
    }  {
      //ImpoString cvs dup //FixedTextShow exec
      (x) //FixedTextShow exec
      //FixedTextShow exec
    } ifelse
  } bind def

  (B)0 get {    %  B: Block
    gsave
    /ZapfDingbats TextSize selectfont (n) //TextShowCore exec
    currentpoint grestore moveto
  } bind def

  (C)0 get {    %  C: Color Set name
    1183615869 internaldict /PageSetup 2 copy known{
      get begin
    ProofReady //NoneString ne {
        ProofReady //GUITextShow exec
        ( / ) //FixedTextShow exec
      HCMSSetup (\(No Color Management\)) ne {
          HCMSSetup //GUITextShow exec
      }  {
          ((ProofReady)) //FixedTextShow exec
      } ifelse
    }  {
        HCMS /SetupName get //GUITextShow exec
    } ifelse
    end
    }{pop pop
      //Messages /NoPageSetup get //GUITextShow exec
    }ifelse
  } bind def

  (D)0 get {    %  D: Device name
    currentpagedevice /PageBufferType get //ImpoString cvs
    //GUITextShow exec
  } bind def

  (E)0 get {    %  E: File encoding
    1183615869 internaldict /fileType 2 copy known {
      get
      dup /PS eq { pop (PostScript) } if
    }  {
      pop pop
      (PostScript)
    } ifelse
    //FixedTextShow exec
  } bind def

  (F)0 get {    %  F: job file name
    //GetFileName exec
    FontStyle 0 ge {
      //FontStyles FontStyle get exch
      TransformFileName_1
      TextSize scalefont setfont
    } if
    //TextShowCore exec
  } bind def

  (G)0 get {    %  G: job file name without path
    //GetFileName exec
    //StripFileName_1 exec
    FontStyle 0 ge {
      //FontStyles FontStyle get exch
      TransformFileName_1
      TextSize scalefont setfont
    } if
    //TextShowCore exec
  } bind def

  (H)0 get {    %  H: RIP product name
    /ProductName currentsystemparam //FixedTextShow exec
  } bind def

  (I)0 get {    %  I: resolution in dpi
    currentpagedevice /HWResolution get aload pop
    1 index //ImpoString cvs //FixedTextShow exec
    2 copy ne {
      ( x ) //FixedTextShow exec
      //ImpoString cvs //FixedTextShow exec
    } { pop } ifelse
    pop
    //onespace//FixedTextShow exec
    //Messages /dpi get //StandardTextShow exec
  } bind def

  (J)0 get  {   %  J: job name
    FontStyle 0 ge {
      //FontStyles FontStyle get
      //TransformJobName_1 exec
      TextSize scalefont setfont
      //TextShowCore exec
    }  {
      true //GetJobName exec
      //StandardTextShow exec
    } ifelse
  } bind def

  (K)0 get {    % K: was JDF ExposedMedia name (K was the only letter left free) - now obsolete
    false
  } bind def

  (L)0 get {    %  L: localised time & date
    localedaytime //GUITextShow exec
  } bind def

  (M)0 get {    %  M: resolution in dpmm
    currentpagedevice /HWResolution get aload pop
    1 index 25.4 div 1000 mul round cvi 10 div //ImpoString cvs //FixedTextShow exec
    2 copy ne {
      ( x ) //FixedTextShow exec
      25.4 div 1000 mul round cvi 10 div
      //ImpoString cvs //FixedTextShow exec
    } { pop } ifelse
    pop
    //onespace//FixedTextShow exec
    //Messages /dpmm get //StandardTextShow exec
  } bind def

  (N)0 get {    %  N: flat number
    FilmCount 1 add  //ImpoString cvs //FixedTextShow exec
  } bind def

  (O)0 get {    %  O: Show oversize info.
    PageClipped {
      (\() //FixedTextShow exec
      //Messages /Clipped get //StandardTextShow exec
    } if
    PageScaleX Rotate 0.001 gt { ScaleY }{ ScaleX } ifelse mul
    PageScaleY Rotate 0.001 gt { ScaleX }{ ScaleY } ifelse mul
    2 copy 1. sub abs 0.001 gt exch 1. sub abs 0.001 gt or {
      PageClipped { (, )}{ (\() } ifelse //FixedTextShow exec
      //Messages /Scale get //StandardTextShow exec
      (: ) //FixedTextShow exec
      % Show scale in percent - rounded to the nearest tenth.
      1 index 1000 mul round cvi 10. div //ImpoString cvs //FixedTextShow exec
      2 copy sub abs 0.001 gt {
        ( x )//FixedTextShow exec
        1000 mul round cvi 10. div //ImpoString cvs //FixedTextShow exec
        pop
      } { pop pop } ifelse
      (%\) ) //FixedTextShow exec
    }  {
      pop pop
      PageClipped { (\) ) } { //onespace } ifelse //FixedTextShow exec
    } ifelse
  } bind def

  (P)0 get {    %  P: PageSetup name
    //Messages /NoPageSetup get /PageSetupName //GetPageSetup exec
    //GUITextShow exec
  } bind def

  (Q)0 get {    %  Q: ICC profile name
    <</Profile //Messages /NoPageSetup get>>
    /HCMS //GetPageSetup exec /Profile get
    %1183615869 internaldict /PageSetup get /HCMS get /Profile get
    //GUITextShow exec
  } bind def

  (R)0 get {    %  R: RIP serial number
    serialnumber dup //ImpoString cvs //FixedTextShow exec (-) //FixedTextShow exec
    statusdict begin checksum end //ImpoString cvs //FixedTextShow exec
  } bind def

  (S)0 get {    %  S: Show separation names.
    gsave
    //ColorantList exec {
      Monochrome {
        /Name get
        dup /Gray eq { pop /Black } if
        dup /Separation currentsystemparam eq { 0 }{ 1 } ifelse
        setgray
      }  {
        dup /Name get exch
        [ /Separation 3 index /DeviceCMYK
        [ 6 -1 roll /CMYK get //BasicTintTransform /exec load ] cvx
        ] setcolorspace
        1. setcolor
      } ifelse
      dup type /stringtype ne { //ImpoString cvs } if
      //StandardTextShow exec
      //onespace//FixedTextShow exec
    } forall
    currentpoint grestore moveto
  } bind def

  (T)0 get {    %  T: time & date
    daytime //FixedTextShow exec
  } bind def

  (U)0 get {    %  U: user name
    //GetUser 1183615869 internaldict /fileType get
    2 copy known {
      get exec
      dup null eq {
        pop //Messages /Unknown get
        true
      } { false } ifelse
    }  {
      pop pop
      //Messages /Unknown get
      true
    } ifelse
      {
      //StandardTextShow exec
    }  {
      FontStyle 0 ge {
        % Assume user name will be encoded in the same way as the
        % job name inside the job file.
        //FontStyles FontStyle get exch
        //TransformJobString_1 exec
        TextSize scalefont setfont
      } if
      //TextShowCore exec
    } ifelse
  } bind def

  (V)0 get {    %  V: RIP version
    hqnversion //FixedTextShow exec
  } bind def

  (W)0 get {    %  W : file mod date (when?)
    1183615869 internaldict /fileType
    2 copy known { get } { pop pop /PS } ifelse
    //FileTypeDate 1 index 2 copy known {
      get exec not {
        //Messages /Unknown get true
      } { false } ifelse
    }  {
      % Don't know how to get mod date from this file type
      pop pop
      //Messages /Unknown get true
    } ifelse
      {
      //FixedTextShow exec
    }  {
      % ftype string
      1 index /PDF eq {
        FontStyle 0 ge {
          //FontStyles FontStyle get exch
          /ShortDate PDFDate_1
          TextSize scalefont setfont
        } if
        //TextShowCore exec
      }  {
        FontStyle 0 ge {
          % Assume date string will be encoded in the same way as the
          % job name inside the job file.
          //FontStyles FontStyle get exch
          //TransformJobString_1 exec
          TextSize scalefont setfont
        } if
        //TextShowCore exec
      } ifelse
    } ifelse
    pop % filetype
  } bind def

  (X)0 get {    %  X: OEM text X
    OEMTextX //StandardTextShow exec
  } bind def
  (Y)0 get {    %  Y: OEM text Y
    OEMTextY //StandardTextShow exec
  } bind def
  (Z)0 get {    %  Z: OEM text Z
    OEMTextZ //StandardTextShow exec
  } bind def

  (0)0 get {    %   0: screening report
    currentpagedevice /DefaultScreenName get
    //ScreenNames 1 index
    2 copy known { get }{ exch pop } ifelse
    //StandardTextShow exec
    true exch
    //NonHPS {
      exch pop
      % false name try
      anchorsearch {
        pop pop pop false ()
        exit
      } if
    } forall
    pop
      {
      % Could be HPS
      /AccurateScreens currentsystemparam {
        ( (HPS)) //StandardTextShow exec
      } if
      % and has a frequency
      (, ) //StandardTextShow exec
      /lpi /CSSEntry GetPageSetup
      dup type /dicttype eq { /ScreenFrequencyUnits get } if
      currentpagedevice /DefaultScreenFrequency get
      //FreqUnits 2 index get exec
      10 mul round cvi 10 div //ImpoString cvs //ControlTextShow exec
      ( ) //StandardTextShow exec
      //StandardTextShow exec     % units
    } if
  } bind def

  (1)0 get {    %  <1 - Imposition setup name
    //GetImposition exec
    dup null eq {
      pop
      //Messages /NoPageSetup get
    } if
    //GUITextShow exec
  } bind def

  (2)0 get {    %   <2 - Trapping setup name
    1183615869 internaldict /PageSetup 2 copy known{
      get begin
      TrapType
      dup (TrapPro) eq {
        pop TrapSet
      } if
      //GUITextShow exec
      end
    }  {
      pop pop
      //Messages /NoPageSetup get //GUITextShow exec
    }ifelse
  } bind def

  (3)0 get {    %   <3 - Calset name
    /CalibrationSet //SetupName exec
  } bind def

  (4)0 get {    %   <4 - Tone curve name name
    /ToneCurves //SetupName exec
  } bind def

  (5)0 get {    %   <5 - Actual press name
    currentpagedevice /SeparationDetails get /SeparationStyle get
    dup 0 ne exch 1 ne and {
      //NoneString //GUITextShow exec
    }  {
      /ActualDotGain //SetupName exec
    } ifelse
  } bind def

  (6)0 get {    %   <6 - Intended press name
    currentpagedevice /SeparationDetails get /SeparationStyle get
    dup 0 ne exch 1 ne and {
      //NoneString //GUITextShow exec
    }  {
      /IntendedDotGain //SetupName exec
    } ifelse
  } bind def

  (7) 0 get {  % <7 - show text as UTF-8
    //ExtractString exec
    //FontStyles FontStyle dup 0 lt { pop 0 } if get
    exch /UTF-8 Transform_1
    TextSize scalefont setfont
    //TextShowCore exec
  } bind def

  (8) 0 get {  % <8 - show text in appropriate encoding for GUI
    //ExtractString exec
    //FontStyles FontStyle dup 0 lt { pop 0 } if get
    exch TransformGUI_1
    TextSize scalefont setfont
    //TextShowCore exec
  } bind def

  (/) 0 get {  % </ - show X/Y
    //ExtractString exec
    2 {
      token {
        % post any
        dup type /stringtype ne { //ImpoString cvs dup length string copy } if
        % post string
        //FontStyles FontStyle dup 0 lt { pop 0 } if get
        exch
        //TranslateString_1 exec
        % post valstring font
        TextSize 2 div scalefont setfont
        % post valstring
        dup stringwidth pop
        % post valstring width
        3 -1 roll
        % valstring width post
      } {
        /Error ShowMessage /ControlTextOver ShowMessage
        defaulthandleerror
      } ifelse
    } repeat
    pop   % final post

    % topstring width bottomstring width
    dup 3 index
    2 copy lt { exch } if pop
    % topstring width bottomstring width markwidth
    gsave
    dup 3 -1 roll sub 2 div 0 rmoveto
    exch show
    grestore
    gsave
    dup 3 -1 roll sub 2 div TextSize .52 mul rmoveto
    exch show
    grestore
    gsave
    TextSize 30 div setlinewidth
    0 TextSize .43 mul rmoveto 0 rlineto currentpoint stroke
    grestore
    TextSize .43 mul sub moveto
  } bind def

%  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LOWER CASE

  (b)0 get {    %  b: move baseline, +ve is up, -ve is down
    //ExtractNumber exec 0 exch rmoveto
  } bind def

  (c)0 get {    %  c: text color
    //ExtractString exec
    Monochrome {
      /Separation currentsystemparam eq { 0 }{ 1 } ifelse
      setgray
    }  {
      [ /Separation 3 -1 roll /DeviceGray { 1. exch sub } ] setcolorspace
      1. setcolor
    } ifelse
  } bind def

  (e)0 get {    %  e: set encoding
    //ExtractString exec
    FontStyle -1 eq {
    //ReEncode exec
    } { pop } ifelse
  } bind def

  (f)0 get {    %  f: set font
    //ExtractString exec
    dup gcheck not {
      currentglobal true setglobal
      exch dup length string copy
      exch setglobal
    } if
    /TextFont 1 index store
    findfont
    //RecordEncoding exec
    TextSize scalefont setfont
    /FontStyle -1 store
  } bind def

  (k)0 get {    %  k: kern. +ve is away, -ve is towards
    //ExtractNumber exec 0 rmoveto
  } bind def

  (l)0 get {    %  l: set leading
    ExtractNumber exec
    HqnImpose2Dict /TextLeading 3 -1 roll put
  } bind def

  (m)0 get {    %   m: translated text
    //ExtractString exec
    //StandardTextShow exec
  } bind def

  (n)0 get {    %  n: new line
    0 currentpoint exch pop
    //HqnImpose2Dict /TextLeading known { TextLeading }{ TextSize 1.2 mul } ifelse
    sub moveto
  } bind def

  (p)0 get {    %  p: arbitrary PostScript
    //ExtractString exec
    cvx //stopcheck exec {
      /Error ShowMessage /ControlPostScript ShowMessage
      defaulthandleerror
    } if
  } bind def

  (s)0 get {    %  f: set font size
    //ExtractNumber exec /TextSize 1 index store
    TextFont exch selectfont
  } bind def

  (t)0 get {    %  t: tab - moveto X position
    //ExtractNumber exec currentpoint exch pop moveto
  } bind def

%  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SYMBOLS

  (<)0 get {    %  <: real <
    //OpenAngle //FixedTextShow exec
  } bind def

  (?)0 get {    %  ?: IF
    //ExtractString exec
    cvx exec not {
      //IfSkip exec
    } if
  } bind def

  (:)0 get {    %  :: ELSE
    //IfSkip exec
  } bind def

  (!)0 get {    %  !: ENDIF
    % Must be the end of an if or else that we've actually run.
    % just ignore it.
  } bind def

  (+)0 get {    %  +:  two character command
    dup 2 1 index length 2 sub getinterval
    //ControlTextTags 3 -1 roll dup 0 get 8 bitshift exch 1 get add
    2 copy known {
      get exec
    }  {
      /Error ShowMessage /InvalidControlText ShowMessage
      pop pop =print /CloseError ShowMessage
      stop
    } ifelse
  } bind def

  (#)0 get {    %   #:  command with single, numeric, character argument.
    % str
    dup 2 1 index length 2 sub getinterval
    % str remainder
    //ControlTextTags 2 index 0 get
    256 add
    % fullstring reststring tags tag
    2 copy known {
      get
      % fullstring reststring proc
      3 -1 roll 1 get dup 48 lt 1 index 57 gt or {  % 0-9
        /Error ShowMessage /InvalidHashText ShowMessage
        stop
      } if
      48 sub      % convert into 0-9
      exch exec
    }  {
      pop pop pop
      /Error ShowMessage /InvalidControlText ShowMessage
      =print /CloseError ShowMessage
      stop
    } ifelse
  } bind def

%  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ HASH COMMANDS

  (D)0 get 256 add {          %  <#DN
    FontStyle -1 eq {
      pop localedaytime
    }  {
      //FontStyles FontStyle get exch
      0 eq { /ShortDate }{ /LongDate } ifelse
      //CurrentDate_1 exec
      TextSize scalefont setfont
    } ifelse
    //TextShowCore exec
  } bind def

  (e)0 get 256 add {          %  <#eN
    % encoding number on stack
    FontStyle -1 eq {
      TextEncodings exch 2 copy known not { pop 0 } if
      get
      dup null eq { pop }{ ReEncode } ifelse
    } { pop } ifelse
  } bind def

  (f)0 get 256 add {
    % font number on stack
    TextFonts exch 2 copy known not { pop 0 } if
    get
    /TextFont 1 index store
    findfont
    //RecordEncoding exec
    TextSize scalefont setfont
    /FontStyle -1 store
  } bind def

  (s)0 get 256 add {
    % font style number on stack, as per HqnLocal
    % 0 - plain
    % 1 - emphasis
    % 2 - narrow
    % 3 - narrow emphasis
    % 4 - monospace
    % 5 - monospace emphasis
    dup 0 lt 1 index 3 gt or {
      /Warning ShowMessage /InvalidFontStyle ShowMessage
      pop 0
    } if
    /FontStyle exch store
  } bind def

end    % ControlTextTags

/ControlRedefines {
  <<
    /showpage { } bind
    /copypage 1 index
    /setpagedevice {
      pop
      //HqnImpose2Dict /ControlBoundinglevel 10 put
    } bind
  >> 1183615869 internaldict begin shadowop end

} bind def

/ControlXAlign <<

  % Called with wid height scaleX scaleY on the stack
  % Leave stack as is.

  /Left {  } bind

  /Center {
    MarkWidth 4 index 3 index mul sub
    2 div
    0 translate
  } bind

  /Right {
    MarkWidth 4 index 3 index mul sub
    0 translate
  } bind

>> def
/ControlXAlign {
  //ControlXAlign
  currentdict /AlignX 2 copy known {  get } {
    pop pop /Left
  } ifelse
  2 copy known { get exec } {
    /Error ShowMessage /UnknownControlFileAlignX ShowMessage =print
    /CloseError ShowMessage flush
    stop
  } ifelse
} bind def

/ControlYAlign <<

  % Called with wid height scaleX scaleY on the stack
  % Leave stack as is.

  /Top {
    0 MarkHeight 4 index 3 index mul sub
    translate
  } bind

  /Center {
    0 MarkHeight 4 index 3 index mul sub
    2 div
    translate
  } bind

  /Bottom { } bind

>> def
/ControlYAlign {
  //ControlYAlign
  currentdict /AlignY 2 copy known {  get } {
    pop pop /Bottom
  } ifelse
  2 copy known { get exec } {
    /Error ShowMessage /UnknownControlFileAlignY ShowMessage =print
    /CloseError ShowMessage flush
    stop
  } ifelse
} bind def

/ExecControlBounding <<

  % called with - level mark llx lly wid ht
  % Leave stack as is.

  /Scaled {
    MarkWidth 2 index div
    MarkHeight 2 index div
    2 copy gt { exch } if pop dup
    % w h sx sy
    //ControlXAlign exec
    //ControlYAlign exec

    2 copy
    % level mark llx lly wid ht sx sy sx sy

    % now adjust original translation to account for the scaling
    1 exch sub 6 index mul exch
    1 exch sub 7 index mul exch translate
    scale
  } bind

  /Stretched {
    MarkWidth 2 index div
    MarkHeight 2 index div
    % w h sx sy

    2 copy
    % level mark llx lly wid ht sx sy sx sy

    % now adjust original translation to account for the scaling
    1 exch sub 6 index mul exch
    1 exch sub 7 index mul exch translate
    scale
  } bind

  /Original {
  } bind

>> def
/ExecControlBounding {
  //HqnImpose2Dict begin
  dup ControlBoundinglevel gt {
    exch
    (?) search {
      pop pop pop
    }  {
      mark exch
      { token not { exit } if exch } loop
        counttomark 4 eq {
          true 1 1 4 {
            index type dup
            /integertype eq exch /realtype eq or not {
              pop false
              exit
            } if
          } for
            {
            % level mark llx lly urx ury
            FileMatrix setmatrix

            3 index neg 3 index neg translate

            % level mark llx lly urx ury
            2 index sub exch 3 index sub exch

            % level mark llx lly wid ht
            //HqnImpose2Dict /CurrentMark get begin

            //ExecControlBounding
            currentdict /Fit 2 copy known {
              get
              dup /Original ne {
                currentdict /MarkHeight known not currentdict /MarkWidth known not or {
                  /Warning ShowMessage /ControlSizeMissing ShowMessage
                  pop /Original
                } if
              } if
            }  {
              pop pop /Original
            } ifelse
            % level mark llx lly wid ht  ECB fit

            2 copy known { get exec } {
              /Error ShowMessage /UnknownControlFileFit ShowMessage =print
              /CloseError ShowMessage flush
              stop
            } ifelse

            % level mark llx lly wid ht
            pop pop
            pop pop

            end    % CurrentMark

            pop  % the mark
            /ControlBoundinglevel exch def
          }  { cleartomark pop } ifelse
        }  { cleartomark pop } ifelse
    } ifelse
  } { pop pop } ifelse

  end    % HqnImpose2Dict
} bind def

/ControlBounding <<

  /BoundingBox: {
    //HqnImpose2Dict /InExecBounding true put
    dup { pop } exec
    1 //ExecControlBounding exec
    //HqnImpose2Dict /InExecBounding false put
  }  % NOT bound
  /PageBoundingBox: {
    //HqnImpose2Dict /InExecBounding true put
    dup { pop } exec
    2 //ExecControlBounding exec
    //HqnImpose2Dict /InExecBounding false put
  }  % NOT bound
  /HiResBoundingBox: {
    //HqnImpose2Dict /InExecBounding true put
    dup { pop } exec
    3 //ExecControlBounding exec
    //HqnImpose2Dict /InExecBounding false put
  }  % NOT bound
  /CropBox: {
    //HqnImpose2Dict /InExecBounding true put
    dup { pop } exec
    4 //ExecControlBounding exec
    //HqnImpose2Dict /InExecBounding false put
  }  % NOT bound

>> def


/ControlExecDict <<
  /PageRange [ [ 1 ] ]
>> def

/ControlMarks 3 dict begin

  /ControlText (<) def
  /ControlText {
    TextFont findfont
    //RecordEncoding exec
    TextSize scalefont setfont
    /Monochrome currentpagedevice /SeparationDetails get
      /SeparationStyle get 0 eq def
    Monochrome { 0 setgray }{ 1 RegisterColor } ifelse

    Text
      {
      dup length 0 eq {
        pop
        exit
      } if
      //ControlText search {
        dup length 0 gt { //FixedTextShow exec }{ pop } ifelse
        pop    % (<)
        dup 1 1 index length 1 sub getinterval
        //ControlTextTags 3 -1 roll 0 get
        2 copy known {
          get exec
        }  {
          /Error ShowMessage /InvalidControlText ShowMessage
          pop pop =print /CloseError ShowMessage
          stop
        } ifelse
      }  {
        //FixedTextShow exec
        exit
      } ifelse
    } loop
  } bind def

  /ControlFile {
    /HqnControl /ProcSet resourcestatus
    dup { 3 1 roll pop pop } if
      {
      //HqnImpose2Dict /FileMatrix matrix currentmatrix put

      % redefine showpage etc.
      //ControlRedefines exec

      % Install boundingBox handling for offset origins
      //HqnImpose2Dict /ControlBoundinglevel 0 put
      (%%dict) load (%%actions) cvn get begin
      //ControlBounding {
        % key proc
        currentdict 2 index known {
          dup 5 3 index load put
        } if
        def
      } forall
      end

      FileName dup status {
        pop pop pop pop
  /dictstacks countdictstack def        % ############## temp
                          /HqnControl /ProcSet findresource /ExecFile get exec
  countdictstack dictstacks sub { end } repeat    % ############ temp
      }  {
        /Error ShowMessage /MissingControlFile ShowMessage
        =print /CloseError ShowMessage flush
        stop
      } ifelse
    }  {
      /Error //ShowMessage exec /NoControlFile //ShowMessage exec flush
      stop
    } ifelse
  } bind def

  /ControlStream {
    //HqnImpose2Dict /FileMatrix matrix currentmatrix put

    % redefine showpage etc.
    //ControlRedefines exec

    % Install boundingBox handling for offset origins
    //HqnImpose2Dict /ControlBoundinglevel 0 put
    (%%dict) load (%%actions) get begin
    //ControlBounding {
      % key proc
      currentdict 2 index known {
        dup 5 3 index load put
      } if
      def
    } forall
    end
    /Stream load

    % Clear down the dictionary and operand stacks
    % We can't just do this arbitrarily because that messes
    % things up, so store them away ...
    count 1 roll
    count 1 sub array astore //HqnImpose2Dict /HqnOpStack 3 -1 roll put

    countdictstack array dictstack //HqnImpose2Dict
      /HqnDictStack 3 -1 roll put
    cleardictstack

    0 () /SubFileDecode filter cvx //stopcheck exec {
      defaulthandleerror stop
    } if

    % And now restore the dict and operand stacks:
    clear
    //HqnImpose2Dict /HqnOpStack get aload pop
    cleardictstack
    countdictstack 1 //HqnImpose2Dict /HqnDictStack get length 1 sub {
      //HqnImpose2Dict /HqnDictStack get exch get begin
    } for
  } bind def

  /ControlRegMark 1 dict def
  /ControlRegMark {
    //ControlRegMark begin
    /RegWidth Size 2 div def
    RegWidth dup RegMark
    end    % ControlRegMark
  } bind def

currentdict end  def  % ControlMarks

/DrawControlMarks {
% Marks { { exch =print (  )print == } forall (_______)= } forall (++++++++++++++++)=
  Marks {
    dup /Enabled get
    dup xcheck { exec } if
      {
      //ControlMarks 1 index /MarkType get 2 copy known {
        get
        systemdict begin    % Avoid separation wrappers etc.
        exch begin

        save //HqnImpose2Dict /ControlSave 3 -1 roll put

        //HqnImpose2Dict /CurrentMark currentdict put

        % If any painting operators are redefined in userdict then wipe them out
        % they'll get restored after this file is run
        systemdict {
          type /operatortype eq {
            userdict exch undef
          } { pop } ifelse
        } forall

        << /DeviceGray null >> setinterceptcolorspace currentgray setgray
        InitGraphics

        ClipMarksToMargins {
          newpath clippath
          FilmLeft ScaleX div FilmBottom ScaleY div moveto
          FilmWidth FilmRight ScaleX div sub FilmBottom ScaleY div lineto
          FilmWidth FilmRight ScaleX div sub FilmHeight FilmTop ScaleY div sub lineto
          FilmLeft ScaleX div FilmHeight FilmTop ScaleY div sub lineto
          closepath
          clip
          newpath
        } if

        MirrorMarks not currentpagedevice /MirrorPrint get and {
          FilmWidth 0 translate
          -1 1 scale
        } if

        1. ScaleX div 1. ScaleY div
        scale
        << /OverprintProcess true >> setuserparams

        /LocFilmHeight FilmHeight ScaleY mul def
        /LocFilmWidth FilmWidth ScaleX mul def

        X dup 0 lt AllowNegativeMarkOffset not and { LocFilmWidth add } if
        Y dup 0 lt AllowNegativeMarkOffset not and { LocFilmHeight add } if
        translate
        0 0 moveto
        Angle rotate

        currentdict /Setup known {
          Setup exec
        } if

        exec

        currentdict /Cleanup known {
          Cleanup exec
        } if

        //HqnImpose2Dict /ControlSave get restore

        end end
      }  {
        /Error ShowMessage /UnknownMark ShowMessage
        =print /CloseError ShowMessage flush
        stop
      } ifelse
    } { pop } ifelse
  } forall
} bind def

% snap to nearest device pixel
/SnapDevice {
  currentpagedevice /HWResolution get exch get
  exch dup xcheck { exec } if
  1 index 72 div mul round 72 mul exch div
} bind def

% snap down to next lower whole device plugin
/SnipDevice {
  currentpagedevice /HWResolution get exch get
  exch dup xcheck { exec } if
  % dpi val
  1 index 72 div mul
  0.001 add
  cvi 72 mul exch div
} bind def

% snap up to next higher whole device pixel
/PadDevice {
  currentpagedevice /HWResolution get exch get
  exch dup xcheck { exec } if
  1 index 72 div mul 0.001 sub ceiling 72 mul exch div
} bind def

% Make sure that we always call the real setpagedevice from our definitions
/setpagedevice systemdict /setpagedevice get def

% The real work routines. These are loaded into the page device during
% InitImpose but defined here to make the code more readable and to reduce
% processing in the page feature if the procset is loaded while the RIP
% starts up.

/SensePageDevice {
  /HqnImpose2 pop
{
  //ImposeDebug { (Impose SensePageDevice+)= } if
  //HqnImpose2GlobalDict begin
  //HqnImpose2Dict begin

  globaldict /InImposedBeginPage 2 copy known { get }{ pop pop false } ifelse
  not {
    % (>>Sense)= RequestDict { exch =print (   )print  == } forall (~~~~~~~~~~~)= % currentpagedevice /ExtraOrientation get ==
    SensePageDeviceInit

    //HqnImpose2GlobalDict /AbortingJob get { false } {
      % We only need to act if the call has changed our current values
      RequestDict false [
        /PageSize /Scaling /Orientation /ExtraOrientation /ResamplingFactor
      ]  {
        2 index exch known {
          pop  % false
          true exit
        } if
      } forall
      exch pop  % RequestDict
    } ifelse
      {
      DebugReport {
        (________________________________________________)=
        (SETTING NEW PAGE LAYOUT:)=
      } if

      % Increment page size setting count
      /LookingForPageSize 10 store
      /PageClipped false store

      % clear out any pass backs from Objectives/Tactics
      //pagedevicePassBack {
        pop //pagedevicePassBack exch undef
      } forall

      % reset adjustment values.
      /AdjustX 0 store
        /AdjustY 0 store
        /PageScaleX 1 store
        /PageScaleY 1 store

      % Set new pageheight and width if required. MUST not use PageSize
      % from currentpagedevice because that might be the last value we
      % calculated.
      RequestDict /PageSize 2 copy known IgnoreJobPageSize not and {
        get
        aload pop

        {
          /CropSpace /FilmTop /FilmBottom
          /OptHGutter /MinHGutter /OptVGutter /MinVGutter
        }  {
          BaseValues 1 index get 1 SnapDevice store
        } forall
        { /FilmLeft /FilmRight } {
          BaseValues 1 index get 0 SnapDevice store
        } forall

        % If adding cropmarks in as well then expand the
        % page appropriately.
        CropMarks {
          CropsInside {
            2 { CropSpace 2. mul add exch } repeat
          } if
          % clear flag marking precalculated values
          /RegWidth null store
        } if

        1 SnapDevice
        /RequestPageHeight 1 index store
        /PageHeight exch store

        0 SnapDevice
        /RequestPageWidth 1 index store
        /PageWidth exch store
      }  { pop pop } ifelse

      /MaxHeight MaxHeight 0 gt {
        MaxHeight 1 SnipDevice
      } { 0 } ifelse store
      /MaxWidth MaxWidth 0 gt {
        MaxWidth 0 SnipDevice
      } { 0 } ifelse store

      /Prefix load dup null ne {
        DebugReport {
          (   Prefix: )print /Prefix load
          dup type /nametype eq { == }{ pop (*Procedure*)= } ifelse
        } if

        dup type /nametype eq {
          //Prefixes exch
          { get } //stopcheck exec {
            /Error ShowMessage /UnknownPrefix ShowMessage
            =print /CloseError ShowMessage flush
            serverdict /terminatejobnow get exec
          } if
        } if

        //stopcheck exec {   % Prefix proc.
          /Error ShowMessage /RunPrefix ShowMessage
          ReportError
          serverdict /terminatejobnow get exec
        } if
      } { pop } ifelse

      /PageWidth PageWidth 0 SnapDevice store
      /PageHeight PageHeight 1 SnapDevice store

      DebugReport {
        (   PageWidth: )print PageWidth =print
          (, PageHeight: )print PageHeight ==
        (   Objective: )print /Objective load
          dup type /nametype ne { pop (*Procedure*) } if =print
          (, Strategy: )print Strategy ==
        (   ExtraFlip: )print ExtraFlip =print
          (, Aspect: )print Aspect ==
        (   OptHGutter: )print OptHGutter =print
          (, Min: )print MinHGutter =print
          (, OptVGutter: )print OptVGutter =print
          (, Min: )print MinVGutter ==
      } if

      RequestDict dup /Scaling known exch /ResamplingFactor known or {
                                1 dict begin
                                   /ResamplingFactor 1 def
           currentpagedevice begin
             Scaling aload pop
             BaseScaleY mul ResamplingFactor div exch
             BaseScaleX mul ResamplingFactor div
             /AAlias ResamplingFactor store
           end
          /BaseScaleX exch store
          /BaseScaleY exch store
                                end
      } if
      /ScaleX BaseScaleX store
      /ScaleY BaseScaleY store

      % test for valid Aspect
      Aspect null ne {
        << /Portrait dup /Landscape dup
           /Original dup /Rotated dup
           /BestFit dup
        >> Aspect known not {
          /Error ShowMessage /Aspect ShowMessage
          Aspect =print /CloseError ShowMessage flush
          serverdict /terminatejobnow get exec
        } if
      } if
      /BaseAspect Aspect def

      % Don't let any previous panelling mess up an un-paneled setting
      % (may have been set by RespondPending etc).
      % Don't call this on first setup to allow to be set from original call.
      ImpositionInitialised 0 gt {
        /PanelWidth null store
        /PanelHeight null store
        /PanelOffsetX 0 store
        /PanelOffsetY 0 store

        /OffsetX 0 store
        /OffsetY 0 store

        /PageScaleX 1. store
        /PageScaleY 1. store

        /Rotate 0 store
      } if
      % Now reset them again if they were in the dictionary given to setpagedevice
      RequestDict [
        /PanelWidth /PanelHeight
        /PanelOffsetX /PanelOffsetY
        /OffsetX /OffsetY
        /PageScaleX /PageScaleY
        /Rotate
        /ClipPath
        /SrcClipPath
        /SheetClipPath
        /SheetClipPathOffsets
        ] {
        2 copy known {
          2 copy get store
        }  {
          pop
        } ifelse
      } forall
      pop  % RequestDict

      % Make sure old clippaths don't trip us up
      /ClipPath null store
      /GutterClip null store
      /SrcClipPath null store
      /SheetClipPath null store
      %This is a composite object, so we need to make sure its in global VM
      currentglobal true setglobal
      /SheetClipPathOffsets [ 0 0 ] store
      setglobal
      //HqnImpose2GlobalDict /AbortOversize false put

      % Objective may be a key entry in the Objectives dict or
      % a procedure supplied in the page feature
      /Objective load dup type /nametype eq {
        //Objectives exch { get } //stopcheck exec {
          /Error ShowMessage /Objective ShowMessage
          =print /CloseError ShowMessage flush
          % (Error: unknown imposition Objective: )print
          serverdict /terminatejobnow get exec
        } if
      } if

      mark exch //stopcheck exec {   % objective proc.
        /Error ShowMessage /RunObjective ShowMessage
        % (Error: while running imposition Objective procedure)=
        ReportError
        serverdict /terminatejobnow get exec
      } if
      counttomark 5 ne {
        /Error ShowMessage /ObjectiveStack1 ShowMessage
        % (Error: Imposition Objective procedure left invalid items on stack:\n     )=
        counttomark =print
        /ObjectiveStack2 ShowMessage
        % ( item(s) left \(should have been 5\))=
        /HqnStopImpose true store
        serverdict /terminatejobnow get exec
      } if

      % Convert Rotate from boolean to number.
      dup type /booleantype eq {
        { RotatedAngle }{ 0 } ifelse
      } if
      ExtraFlip { 180 add 360 mod } if
      [ /Rotate /PagesUp /PagesAcross ] { exch store } forall
      /FilmHeight exch 1 PadDevice store
      /FilmWidth exch 0 PadDevice store
      pop  % mark

      { InstallPageSizes } //stopcheck exec {
        //ReportError exec
        serverdict /terminatejobnow get exec
      } if

      /Suffix load dup null ne {
        DebugReport {
          (    Suffix: )print /Suffix load
          dup type /nametype eq { == }{ pop (*Procedure*)= } ifelse
        } if

        dup type /nametype eq {
          //Suffixes exch { get } //stopcheck exec {
            /Error ShowMessage /UnknownSuffix ShowMessage
            =print /CloseError ShowMessage flush
            serverdict /terminatejobnow get exec
          } if
        } if
        //stopcheck exec {   % Suffix proc.
          /Error ShowMessage /RunSuffix ShowMessage
          ReportError
          serverdict /terminatejobnow get exec
        } if
      } { pop } ifelse

      % Now trim off any excess (possibly caused by SheetSlop)
      FilmHeight MaxHeight ScaleY div gt MaxHeight 0.001 gt and {
        /FilmHeight MaxHeight ScaleY div 1 PadDevice store
      } if
      FilmWidth MaxWidth ScaleX div gt MaxWidth 0.001 gt and {
        /FilmWidth MaxWidth ScaleX div 0 PadDevice store
      } if

      ClearMarginValues

      % Leave appropriate values on the stack to be
      % fed back to the page device.

      % Extra stuff from page feature
      SensePageDeviceExtra

      % pass backs from Objectives/Tactics. These must be before defaults to
      % override if necessary.
      //pagedevicePassBack {} forall

      /PageSize [ FilmWidth FilmHeight ]
      /ImagingBBox     null
      /Orientation     0
      /ExtraOrientation   0
      /FilmSaving    false
      /TimeSaving  false

      /Policies << /PageSize 7 >>  % Who me? paranoid?

      /PriorSensePage load null ne { PriorSensePage } if
    }  {
      % Extra stuff from page feature
      SensePageDeviceExtra

      /PriorSensePage load null ne { PriorSensePage } if
    } ifelse
  } if
  end  % HqnImpose2Dict
  end  % HqnImpose2GlobalDict
% (Sense>>)= pstack (**************)=
  counttomark 1 and 0 ne {
    (%stderr)(w) file
    (HqnImpose2: SensePageDevice - invalid stack returned\n) writestring
    /SensePageDevice errordict /undefinedresult get exec
  } if
  //ImposeDebug { (Impose SensePageDevice-)= } if
 } //stopcheck exec {
  defaulthandleerror serverdict /terminatejobnow get exec
 } if
} bind def

/PathOps <<
  /m /moveto load
  /l /lineto load
  /c /curveto load
  /v { currentpoint 6 2 roll curveto } bind
  /y { 2 copy curveto } bind
  /h /closepath load
  /re {
    4 2 roll moveto
    1 index 0 rlineto
    0 exch rlineto
    neg 0 rlineto
    closepath
  } bind
>> def

/CropPath {
  newpath
  3 index DevXPixel sub 3 index DevYPixel sub moveto
  3 index DevXPixel sub 1 index DevYPixel add lineto
  1 index DevXPixel add 1 index DevYPixel add lineto
  1 index DevXPixel add 3 index DevYPixel sub lineto
  closepath
  clip
  newpath
  pop pop pop pop
} bind def

/TidyMatrix {
  % tidy up rounding errors - snap to integers if < 1e-6 away.
  matrix currentmatrix aload pop
  6 2 roll
  4  {
    dup dup round sub abs 1e-6 le {
      round
    } if
    6 1 roll
  } repeat
  % snap offsets to exact device pixels.
  % Makes the final page exactly match single-pages, especially
  % useful if used in conjunction with TrapMaster.
  itransform
  2 {
    round cvi
    exch
  } repeat
  transform
  6 array astore setmatrix
} bind def

/LowerLeftAdjustment <<
  0 {
    0
    90 ListExtraRotation sub cos locpagewidth mul
% (0a: )print dup ==
  } bind
  1 {
    180 ListExtraRotation sub sin locpageheight mul
% (1a: )print dup ==
    180 ListExtraRotation sub cos locpagewidth mul
% (1b: )print dup ==
    add

    180 ListExtraRotation sub cos locpageheight mul
% (1c: )print dup ==
  } bind
  2 {
    ListExtraRotation 180 sub cos locpagewidth mul
% (2a: )print dup ==

    ListExtraRotation 180 sub sin locpagewidth mul
% (2b: )print dup ==
    ListExtraRotation 180 sub cos locpageheight mul
% (2c: )print dup ==
    add
  } bind
  3 {
    0
    360 ListExtraRotation sub sin locpagewidth mul
% (3: )print dup ==
  } bind
>> def

/PagePositions 2 dict begin

  /Origin {
    % Lower left corner of page - the default
  } bind def

  /LowerLeft 2 dict def
  /LowerLeft {
    % Lower left corner, AFTER any rotation, as required for JDF
    currentdict /ListExtraRotation known
    PageWidth 0 gt PageHeight 0 gt and
    and {
      //LowerLeft begin
      /locpageheight PageHeight CropMarks { CropSpace 2 mul sub } if def
      /locpagewidth PageWidth CropMarks { CropSpace 2 mul sub } if def
      //LowerLeftAdjustment ListExtraRotation 90 div floor cvi 4 mod get exec
      translate
      end
    } if
  } bind def

currentdict end def

/DefinePageArea {
  % Called from both BeginPage and before CropMarkEndPage and PageOverlay
  % in EndPage, so split out to here.

  % boolean on stack. true means from BeginPage, false from EndPage
% (DPA+: )print dup ==
  InitGraphics
  initclip
  1 1 idtransform /DevYPixel exch abs def /DevXPixel exch abs def

% gsave 0 0 1 setrgbcolor 2 setlinewidth FilmLeft ScaleX div FilmBottom ScaleY div FilmWidth FilmLeft FilmRight add ScaleX div sub FilmHeight FilmTop FilmBottom add ScaleY div sub rectstroke grestore

  % Clip for margins - NOT for end page (crop marks etc)
  dup CropsInside and {
% (CLIP0: )print [ ([) FilmLeft ScaleX div FilmBottom ScaleY div FilmWidth FilmRight ScaleX div sub FilmHeight FilmTop ScaleY div sub (]) ]{ =print ( )print } forall ()=
    FilmLeft ScaleX div
    FilmBottom ScaleY div
    FilmWidth FilmRight ScaleX div sub
    FilmHeight FilmTop ScaleY div sub
    //CropPath exec
  } if

  % move to the page position
  % - for film margin:
  FilmLeft ScaleX div FilmBottom ScaleY div
% (TRAN1: )print 1 index =print (  )print dup ==
  translate //TidyMatrix exec

  AdjustX ScaleX div AdjustY ScaleY div
% (TRAN2: )print 1 index =print (  )print dup ==
  translate //TidyMatrix exec

  ClipPath type /nulltype ne {
% (CLIP1: )print ClipPath ==
    ClipPath aload pop
    //CropPath exec
  } if
  GutterClip type /nulltype ne {
% (CLIP2: )print GutterClip ==
    GutterClip aload pop
% gsave 1.5 setlinewidth 0 1 1 0 setcmykcolor newpath
% 3 index DevXPixel sub 3 index DevYPixel sub moveto 3 index DevXPixel sub 1 index DevYPixel add lineto
% 1 index DevXPixel add 1 index DevYPixel add lineto 1 index DevXPixel add 3 index DevYPixel sub lineto
% closepath stroke grestore
    //CropPath exec
  } if

  SheetClipPath type /nulltype ne {
    mark
    SheetClipPathOffsets aload pop translate
    newpath
    SheetClipPath {
      dup type
      /nametype eq {
        //PathOps exch 2 copy known {
          get exec
        }  {
           /Error ShowMessage /UnknownPathOp ShowMessage
           =print /CloseError ShowMessage flush
          pop stop
        } ifelse
      } if
    } forall
% gsave 1 0 0 setrgbcolor 8 setlinewidth stroke grestore
    counttomark 0 ne {
      /Warning ShowMessage /PathOpStack ShowMessage
      cleartomark
    } { pop } ifelse
    clip
    newpath
    SheetClipPathOffsets { neg } forall translate
  } if

  PageList PageCount get begin

  ListCTM null ne {
    ListCTM concat
  }  {
    % - and page position
    ListPosition aload pop
    % (TRAN3: )print 1 index =print (  )print dup ==
    translate //TidyMatrix exec

    % - scale the page as required
    PageScaleX PageScaleY
    % (SCALE: )print 1 index =print (  )print dup ==
    scale

    % - rotate as required
    ListRotation dup 0 ne {
    % (ROT: )print dup ==
      rotate
    } { pop } ifelse
  } ifelse

  SrcClipPath type /nulltype ne {
    mark
    newpath
    SrcClipPath {
      dup type
      /nametype eq {
        //PathOps exch 2 copy known {
          get exec
        }  {
           /Error ShowMessage /UnknownPathOp ShowMessage
           =print /CloseError ShowMessage flush
          pop stop
        } ifelse
      } if
    } forall
% gsave 1 0 0 setrgbcolor 8 setlinewidth stroke grestore
    counttomark 0 ne {
      /Warning ShowMessage /PathOpStack ShowMessage
      cleartomark
    } { pop } ifelse
    clip
    newpath
  } if

  //PagePositions PagePosition 2 copy known not {
    /Error ShowMessage /missingPagePosition ShowMessage
    =print /CloseError ShowMessage flush
    stop
  } if
  get exec
  currentdict /ListExtraRotation known { ListExtraRotation rotate } if

  end  % dict for this page in PageList
% gsave .25 setlinewidth dup { 0 1 1 0 }{ 1 1 0 0 } ifelse setcmykcolor 0. 0. PanelWidth PanelHeight rectstroke grestore (OUTLINE)=
  % - clip to panel - not for end page (crop marks etc)
  dup PanelWidth 0 gt PanelHeight 0 gt and and CropsInside and {
    0 0 PanelWidth PageScaleX div PanelHeight PageScaleY div
% (CLIP3: )print 4 copy 4 array astore ==
    //CropPath exec
  } if

  % - move to the page origin within the panel
  PanelOffsetX PanelOffsetY
% (TRAN4: )print 1 index =print (  )print dup ==
  translate //TidyMatrix exec

  % - clip to the page within the panel, deliberately clockwise
  % to match the direction of clippath for device bounds (bug 20409)
  % Again, not for end page (crop marks etc)
  dup PageWidth 0 gt PageHeight 0 gt and and {
    CropsInside {
      0 0 PageWidth PageHeight
    }  {
      Bleed neg dup
      PageWidth Bleed add
      PageHeight Bleed add
    } ifelse
%(CLIP4: )print 4 copy 4 array astore ==
% gsave 1.5 setlinewidth 1 0 1 0 setcmykcolor newpath
% 3 index DevXPixel sub 3 index DevYPixel sub moveto 3 index DevXPixel sub 1 index DevYPixel add lineto
% 1 index DevXPixel add 1 index DevYPixel add lineto 1 index DevXPixel add 3 index DevYPixel sub lineto
% closepath stroke grestore
    //CropPath exec
  } if

  % - move origin offset into page, only from BeginPage
      {
    OffsetX neg OffsetY neg
% (TRAN5: )print 1 index =print (  )print dup ==
    translate //TidyMatrix exec
  } if
  newpath

% (DPA-)=
} bind def

/BeginPage {
  /HqnImpose2 pop
  //ImposeDebug { (Impose BeginPage+)= } if

  //HqnImpose2GlobalDict begin //HqnImpose2Dict begin
% (BP>> )print PageCount ==

  globaldict /InImposedBeginPage 2 copy known { get }{ pop pop false } ifelse
  not {
    % ImposedBeginPage can be defined in HqnPDFChecker, etc.
    % It's used to trigger setting of appropriate transparency modes for this sheet.
    statusdict /ImposedBeginPage known { statusdict /ImposedBeginPage get exec } if

    /currentforcepositive /ForcePositive currentsystemparam def
    //fpparams dup /ForcePositive recombinestatus 2 ge and not put setsystemparams

    /BeginPageExtra runsafe
    BeginPageExtras dup begin {
      pop runsafe
    } forall end

    pop    % showpagecount

    % initialise values for this page from PageList
    PageList PageCount get begin
    /PanelWidth ListPanelSize aload pop /PanelHeight exch store store
    /PageWidth ListPageSize aload pop /PageHeight exch store store
    /PanelOffsetX ListPanelOffset aload pop /PanelOffsetY exch store store
    /OffsetX ListPageOffset aload pop /OffsetY exch store store
    /PageScaleX ListScale aload pop /PageScaleY exch store store
    /Rotate ListRotation store
    /ClipPath ListClip store
    /GutterClip currentdict /ListGutterClip known { ListGutterClip }{ null } ifelse store
    /SrcClipPath ListSrcClipPath store
    /SheetClipPath ListSheetClipPath store
    /SheetClipPathOffsets ListSheetClipPathOffsets store

    end    % This PageList

    % First page on film.
    PageCount 0 eq dup
    PendingPageWidth 0 ne and {
      pop
      << /PageSize [ PendingPageWidth PendingPageHeight ] >>
      /PendingPageWidth 0 store
      /PendingPageHeight 0 store
      //setpagedevice
    }  {
        {
        InitGraphics

        % Blank page for neg output.
        1 currenttransfer exec 0.5 lt {
          //fpparams dup /ForcePositive currentforcepositive put setsystemparams

          gsave 1 setgray clippath fill grestore

          //fpparams dup /ForcePositive recombinestatus 2 ge and not put setsystemparams
        } if

        /FilmUnderlay runsafe
      } if

      true DefinePageArea

      HalftonePhase {
        /HalftonePhaseBeginPage runsafe
      } if

      CropMarks {
        /CropMarkBeginPage runsafe
      } if

      /PageUnderlay  runsafe
    } ifelse

    /LastPage false store

    //fpparams dup /ForcePositive currentforcepositive put setsystemparams
  } { pop } ifelse

  end    % HqnImpose2Dict
  /ObjectOnPage false def
  end    %  HqnImpose2GlobalDict
% (>>BP)=
  //ImposeDebug { (Impose BeginPage-)= } if
} bind def

/CornerLists << { /llx /lly /urx /ury /x1 /y1 /x2 /y2 } { 0 } forall >> def

/LastEndPageInterrupt false def

/EndPage <<
  % llx lly urx ury X Y W H

  0  {
    2 index add exch
    3 index add exch
  } bind
  1  {
    neg 3 index add exch
    1 index add
  } bind
  2  {
    neg 2 index add exch
    neg 3 index add exch
  } bind
  3  {
    3 index add exch
    neg 1 index add
  } bind
>> def

/GetFontFailed /HqnMissingFonts /ProcSet resourcestatus {
  pop pop
  /HqnMissingFonts /ProcSet findresource /GetFontFailed get
}  {
  { false } bind
} ifelse def

/EndPage {
  /HqnImpose2 pop
  //ImposeDebug { (Impose EndPage+)= } if
  % decide whether to output the page
  % showpagecount code -> bool
% (>>EP )print 1 index =print (  )print dup ==
  //HqnImpose2GlobalDict begin //HqnImpose2Dict begin

  globaldict /InImposedBeginPage 2 copy known { get }{ pop pop false } ifelse
  not {
    /currentforcepositive /ForcePositive currentsystemparam def

    //fpparams dup /ForcePositive
    recombinestatus 2 ge and not
    put setsystemparams

    exch pop

    /interrupting $error /errorname get /interrupt eq def

    currentpagedevice /NumCopies get
    dup null eq {
      pop
      userdict /#copies get
    } if 0 eq {
      RecombineEnabled not { /CancellingPage true store } if
    } if

    % Backstop for multiple pages and recombining separations together
    PageCount 0 ne PagesPerFilm 1 gt and
    interrupting not and {
      //HqnImpose2GlobalDict /AbortingJob get {
        /interrupting true def
      }  {
        mark { TestRecombination } //stopcheck exec {
          cleartomark
          pop 2    % treat as device deactivation
          $error begin /command load /HqnImpose2 eq errorname /undefinedresult eq and
          //HqnImpose2GlobalDict /AbortingJob 2 index put
          erasepage
          pop false
          /HqnImpose2 errordict /undefinedresult get exec
        } { cleartomark } ifelse
      } ifelse
    } if

    2 eq
    /Deactivating 1 index def
    dup {
      % Don't output anything on an interrupt.
      interrupting LastEndPageInterrupt not and {
        % This message is included solely for compatibility with none-imposed jobs
        % No U V S, because the same string is used from inside the core RIP (jobpss.pss)
        (%%[ Flushing: rest of job (to end of file) will be ignored ]%%)=
      } if
      interrupting GetFontFailed or {
        /PageCount 0 store
        erasepage
        /FlushingPage true store
      } if
      % Has this page made any marks that we should image anyway?
      /AutoShowpage currentsystemparam {
        mark { 1183615869 internaldict /pagebbox get exec } //stopcheck exec {
          % no - film is completely blank
          $error /newerror false put
          cleartomark
        }  {
          % Marks on film - any from this page?
          %
          % llx lly urx ury
          //CornerLists begin
          { /ury /urx /lly /llx }{ exch def } forall

          PageList PageCount get begin
          ListPosition aload pop
          % X1 Y1
          ListPanelSize aload pop
          % X1 Y1 W H
          //EndPage ListRotation 90 div round cvi 4 mod get exec
          % X1 Y1 X2 Y2
          end

          { /y2 /x2 /y1 /x1 }{ exch def } forall

          pop  % mark

          x1 llx lt x2 llx lt ne
          x1 urx lt x2 urx lt ne or
          llx x1 lt urx x1 lt ne
          llx x2 lt urx x2 lt ne or or
          y1 lly lt y2 lly lt ne
          y1 ury lt y2 ury lt ne or
          lly y1 lt ury y1 lt ne
          lly y2 lt ury y2 lt ne or or
          and {
            pop false
            /LastPage true store
          } if

          end    % CornerLists
        } ifelse
      } if
    } if
      {
      % Device de-activation. Throw a film if any pages have been
      % placed already.

      PageCount 0 ne dup {  % The dup leaves a bool on the stack.
        /PageCount 0 store
      } if
    }  {
      FlushingPage {
        PageCount 0 ne dup    % expose the film?

        ProgressReport and {
          /FilmFlushed ShowMessage
        } if
        /PageCount 0 store
        /FlushingPage false store
      }  {
        CancellingPage not {
          save /ImposeSave exch def

          false DefinePageArea

          % disable trapping for register marks etc.
          userdict /settrap known { 0 settrap } if

          /Trailer load {} ne ObjectOnPage Deactivating not or and {
            % Don't do this if this is a device deactivation
            % and there was nothing on this page ...

            % Mark the page for the trailer to determine page area
            PageList PageCount get begin
            ListPosition aload pop
            FilmBottom add
            PanelOffsetY OffsetY PageScaleY mul sub add exch
            FilmLeft add
            PanelOffsetX OffsetX PageScaleX mul sub add exch

            PageWidth PageScaleX mul
            PageHeight PageScaleY mul
            ListRotation dup cos exch sin
            end

            % stack: xbase ybase pwidth pheight costheta sintheta

            % Top left
            5 index 3 index 2 index mul sub   % xbase - pheight*sintheta
            5 index 4 index 4 index mul add    % ybase + pheight*costheta
            TestMargins

            % Bottom Right
            5 index 4 index 3 index mul add    % xbase + pwidth*costheta
            5 index 5 index 3 index mul add    % ybase +  pwidth*sintheta
            TestMargins

            % Top Right
            5 index 3 index 2 index mul sub    % xbase - pheight*sintheta +
              4 index 3 index mul add      %  pwidth*costheta
            5 index 4 index 4 index mul add    % ybase + pheight*costheta +
              5 index 3 index mul add      %  pwidth*sintheta
            TestMargins

            % Bottom left
            4 { pop } repeat
            TestMargins
          } if

          RecombineActive {
            % We're inside EndPage, which means that we don't even have the default
            % screen installed. Make sure that's in place here.
            currentpagedevice /Private get /Install get exec
            doShadowedScreens
            //fpparams dup /ForcePositive recombinestatus 2 ge and not put setsystemparams
          } if

          mark { currenttrapintent } stopped {
            cleartomark
            null
          } {
            exch pop
            false settrapintent
          } ifelse

          CropMarks {
            /CropMarkEndPage runsafe
            false DefinePageArea
          } if

          /PageOverlay load length 0 gt {
          /PageOverlay runsafe
          } if

          dup null eq { pop }{ settrapintent } ifelse

          /PagesExposed PagesExposed 1 add store
          ProgressReport ObjectOnPage Deactivating not or and {
            /PlateProgress ShowMessage
            % (>  Interpreted plate )print
            PagesExposed ==
          } if

          % Add one to page count and check whether the next page
          % will be the first on a new signature. Throw a page if so.
          /PageCount PageCount 1 add PagesPerFilm mod dup 0 eq
          3 1 roll store

          ImposeSave restore
        }  {
          false    % don't expose film.
        } ifelse
      } ifelse  % FlushingPage

      /runsafereturn 1 index def
      /EndPageExtra runsafe
      pop
      runsafereturn
    } ifelse    % device deactivation

    LastPage interrupting not and {
      pop true
      /PageCount 0 store
    } if

    /CancellingPage false store

    dup  {
      % We are outputting the film
      currentglobal dup not { true setglobal } if
      not { false setglobal } if

      % Required to work round core RIP bug ######################
      RecombineActive {
        % We're inside EndPage, which means that we don't even have the default
        % screen installed. Make sure that's in place here.
        currentpagedevice /Private get /Install get exec
        doShadowedScreens
      } if

      InitGraphics

      mark { currenttrapintent } stopped {
        cleartomark
        null
      } {
        exch pop
        false settrapintent
      } ifelse

      /FilmOverlay runsafe

      /DrawControlMarks runsafe

      dup null eq { pop }{ settrapintent } ifelse

      /FilmCount FilmCount 1 add store    % Must be set after InitGraphics and DrawControlText

      /runsafereturn exch def
        /Trailer runsafe
      runsafereturn
      ClearMarginValues

      ProgressReport {
        /FilmProgress ShowMessage
        % (>> Finished Film )print
        FilmCount == flush
        dup not {
          /BlankSuppressed ShowMessage
        } if
      } if
    } if

    //fpparams dup /ForcePositive currentforcepositive put setsystemparams

    /LastEndPageInterrupt interrupting store
  } { pop pop false } ifelse

% (EP>> )print dup =print (   )print PageCount ==
  end end    % HqnImpose2Dict & global
  //ImposeDebug { (Impose EndPage-)= } if
} bind def

/StartPainting <<
  /HqnImpose2 {
    //ImposeDebug { (Impose StartPainting+)= } if
    //HqnImpose2GlobalDict /ObjectOnPage true put

    //HqnImpose2GlobalDict /AbortOversize get {
      /Error //ShowMessage exec /AbortedOversize //ShowMessage exec
      //HqnImpose2GlobalDict /AbortingJob true put
      /HqnImpose2 errordict /rangecheck get stopped pop
                        superstop
    } if
    //ImposeDebug { (Impose StartPainting-)= } if
  } bind
>> def

/DebugPage {
  % stack should be item for labeling page
  gsave
  0.7 setgray clippath fill
  0. 0.
  PageWidth PageHeight

  CropMarks CropsInside and {
    2 { CropSpace 2. mul sub exch } repeat
  } if

  0 setgray 2 setlinewidth
  4 copy rectstroke
  1 setgray 0.125 setlinewidth
  rectstroke
  /Helvetica 64 selectfont
  0 0 moveto
  //ImpoString cvs dup
  false charpath flattenpath pathbbox
  2 { 2 index sub 2. div 3 -1 roll sub exch } repeat
  PageWidth 2. div 3 -1 roll sub
  PageHeight 2. div 3 -1 roll sub
  CropMarks CropsInside and { 2 { CropSpace sub exch } repeat } if
  newpath moveto
  gsave
  dup false charpath
  2 setlinewidth stroke
  grestore
  0 setgray show
  grestore
} bind def

/FlushFilm {
  //HqnImpose2GlobalDict /FlushingPage true put
  showpage
} bind def

% *************************
% CROP MARK STUFF:

% Utilities for drawing the marks.

/RegisterColor {
  { /Separation /All
    /DeviceCMYK { dup dup dup } } cvlit
  setcolorspace
    setcolor
} bind def

/CropMark {
  gsave
  translate rotate
  CropSpace neg 0. moveto CropClearance neg 0. lineto
  0. CropSpace moveto 0. CropClearance lineto
  % White, round ends
  0. RegisterColor 1 setlinecap CropRule 3. mul setlinewidth
  gsave stroke grestore
  % now overprint in register colour
  1 setcolor CropRule setlinewidth
  stroke
  grestore
} bind def

/RegMark
  {
  gsave
  translate
  % white out behind mark
  0. RegisterColor 1 setlinecap CropRule 3. mul setlinewidth
  0. RegWidth neg moveto 0. RegWidth lineto
  RegWidth neg 0. moveto RegWidth 0. lineto
  0. 0. RegWidth .8 mul 0. 360. arc
  0. 0. RegWidth .4 mul 0. 360. arc
  gsave stroke grestore
  % black stroke
  1. setcolor CropRule setlinewidth
  stroke
  % draw inner circle
  0. 0. RegWidth .4 mul CropRule 2. div add 0. 360. arc
  % fill inner circle
  gsave fill grestore
  % draw white stroke in inner circle
  clip newpath
  0. setcolor
  0. RegWidth neg moveto 0. RegWidth lineto
  RegWidth neg 0. moveto RegWidth 0. lineto
  stroke
  grestore
} bind def

/Progressive {
  % str C M Y K
  1. 1. 1. 1. setcmykcolor 0. dup BoxSize dup rectfill
  setcmykcolor
  0. BoxSize .25 mul BoxSize dup .75 mul
  4 copy rectfill
  1. 1. 1. 1. setcmykcolor rectstroke
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    //TranslateChars_1 exec
    ProgressiveFontSize scalefont setfont
  } if
  dup stringwidth pop BoxSize exch sub 2 div
  0.5 moveto 1 setgray show
  BoxSize 0. translate
} bind def

/DeviceFudge {
  % make sure the box size is an exact multiple of device units ...
  dup dtransform .5 add round exch .5 add round exch idtransform pop abs
} bind def

% White in behind any text drawn by the crop mark routines.
/blockshow {
  gsave
  dup
  false charpath
  flattenpath pathbbox
  2 { 4 -1 roll .5 sub } repeat
  4 2 roll
  2 index sub 1 add exch
  3 index sub
  4 index stringwidth pop
  2 copy
  lt { exch } if pop
  1 add exch
  1 setgray rectfill
  grestore
  show
} bind def

/tcblockshow {
  FontStyle 0 ge {
    //FontStyles FontStyle get exch
    //TranslateChars_1 exec
    LabelSize scalefont setfont
  } if
  //blockshow exec
} bind def

/CalculateReqWidth {
  /RegWidth CropSpace CropClearance sub 2. div store
  CropSpace Bleed sub 2. mul
  /CropHeight PageHeight
    CropsInside not { CropSpace 2 mul add } if
    2 index sub def
  /CropWidth PageWidth
    CropsInside not { CropSpace 2 mul add } if
    3 -1 roll sub def
%  DebugReport { (   CropWidth: )print CropWidth =print (, CropHeight: )print CropHeight == } if
} bind def

/CropMarkBeginPage {
  //CalculateReqWidth exec

  % move to bottom left
  CropsInside { CropSpace dup translate } if
  % set clipping path
%  initclip
  newpath
  OffsetX Bleed sub
  OffsetY Bleed sub
  CropWidth CropHeight rectclip
} bind def

/CropWedgeValues [ .1 .2 .3 .4 .5 .6 .7 .8 .9 1.0 ] def

/SpotWedge {
  gsave
  false setoverprint
  CropRule setlinewidth
  [ BoxSize 2 div dup ] BoxSize 4 div setdash
  CropWedgeValues {
    currentcolorspace 0 get /DeviceGray eq { 1. exch sub } if
    setcolor
    0. 0. BoxSize dup rectfill
    gsave
    1 RegisterColor
    0. 0. BoxSize dup rectstroke
    grestore
    BoxSize 0. translate
  } forall
  grestore
} bind def

/CropMarkEndPage [
  % positioning for step wedges.
  {  % 0 - bottom left
  gsave
  CropSpace CropClearance sub 0.9 mul
    CropSpace CropClearance add
    CropClearance CropWedgeValues length BoxSize mul add WedgeCycle mul add
    translate
  90. rotate
  SpotWedge
  grestore
} bind
  {  % 1 - top left
  gsave
  CropSpace CropClearance sub 0.9 mul
    Ht CropSpace sub
    CropClearance CropWedgeValues length BoxSize mul add WedgeCycle 1 add mul sub
    translate
  90. rotate
  SpotWedge
  grestore
} bind
  {  % 2 - top right
  gsave
  Wid CropSpace CropClearance sub 0.9 mul sub
    Ht CropSpace sub CropClearance sub
    CropClearance CropWedgeValues length BoxSize mul add WedgeCycle mul sub
    translate
  -90. rotate
  SpotWedge
  grestore
} bind
  {  % 3 - bottom right
  gsave
  Wid CropSpace CropClearance sub 0.9 mul sub
    CropSpace
    CropClearance CropWedgeValues length BoxSize mul add WedgeCycle 1 add mul add
    translate
  -90. rotate
  SpotWedge
  grestore
} bind
] def
/CropMarkEndPage {
  save

  % use stroke adjust to improve crop & register marks
  currentstrokeadjust not { true setstrokeadjust } if

  << /OverprintProcess false >> setuserparams % just in case. It'll be restored out again.

  RegWidth type /nulltype eq {
    //CalculateReqWidth exec
  } if

  CropsInside {
    PageHeight PageWidth
  }  {
    % Will get restored out at the end of this procedure
    CropSpace neg dup translate

    PageHeight CropSpace 2 mul add
    PageWidth CropSpace 2 mul add
  } ifelse
  /Wid exch def /Ht exch def

  /CropMarkSetup runsafe

  1 currenttransfer exec 1 ne {
    % probably negated through settransfer - paint in the crop area
    newpath clippath
    CropSpace Bleed sub dup moveto
    CropWidth 0 rlineto
    0 CropHeight rlineto
    CropWidth neg 0 rlineto
    closepath
    0. 0. 0. 0. setcmykcolor eofill
  } if

  LabelFont type /integertype eq {
    /FontStyle LabelFont store
  } {
    LabelFont /Font resourcestatus {
      pop pop
      LabelFont LabelSize selectfont
      /FontStyle -1 store
    } {
      % LabelFont not found
      /FontStyle -1 store
    } ifelse
  } ifelse

  ShowJobName {
    1 RegisterColor
    CropSpace CropClearance add  % X position
    Ht RegWidth 2. mul sub LabelSize 0.35 mul add % descenders
    moveto
    FontStyle 0 ge {
      //FontStyles FontStyle get
      //TransformJobName_1 exec
      LabelSize scalefont setfont
    }  {
      statusdict begin jobname end dup type /stringtype ne {
          pop currentpagedevice /JobName get dup type
          /stringtype ne {
            pop (Untitled) //Translate exec
          } if
      } if
    } ifelse
    blockshow
    (; ) tcblockshow
    //Messages /PlateLabel get
    FontStyle 0 ge {
      //FontStyles FontStyle get exch
      //TranslateString_1 exec
      LabelSize scalefont setfont
    } if
    blockshow
    ( )tcblockshow  % (; Plate )
    PagesExposed 1 add //ImpoString cvs tcblockshow

    % time - Top right
    FontStyle 0 ge {
      //FontStyles FontStyle get /ShortDate
      CurrentDate_1
      LabelSize scalefont setfont
    }  { localedaytime } ifelse
    Wid CropSpace sub CropClearance sub
      1 index stringwidth pop sub  % -> X pos
    Ht RegWidth 2. mul sub LabelSize 0.35 mul add % descenders
    moveto
    blockshow  % daytime is left on the stack from last call.
  } if  % ShowJobName

  CropRule setlinewidth 0 setlinejoin

  currentpagedevice /Separations known {
      currentpagedevice /Separations get
    }  {
    false
  } ifelse
  % sepChosen:
  %  -3 - unseparated composite colour
  %  -2 - a spot colour sep in pre-separated job
  %  -1 - separating
  %   0, 1, 2, 3 - Cyan, Magenta, Yellow, Black sep in pre-sep job.
  % separations on ==> true here
  sepChosen 0 ge sepChosen -2 eq or {
          {
      /sepChosen -1 store  % separating
      true
    }  {
      % From 3.3r5 we can tell if we're
      % outputting a pre-separated page. Show the
      % correct wedge etc if so.
      /Separation currentsystemparam cvn
      <<
        /Cyan 0
        /Magenta 1
        /Yellow 2
        /Black 3
        /Composite -3  % unseparated composite colour
        / -3
      >>
      exch 2 copy known {
        get /sepChosen exch store
        true
      }  {
        pop pop
        /sepChosen -2 store  % spot colour
        true
      } ifelse
    } ifelse
  } { pop true } ifelse

    {
    % WE ARE SEPARATING or processing a pre-separated job

    recombinestatus pop not
    sepChosen -1 gt
    and {
      % Add separation wrapper. This will be cleared by the
      % restore at the end of the procedure
      % It doesn't have to be very fancy!
      <<
      /setcmykcolor {
        1. 4 sepChosen sub index sub setgray
        4 { pop } repeat
      } bind
      /setgray {
        sepChosen 3 ne { pop 1. } if
        //setgray
      } bind
      >> 1183615869 internaldict begin shadowop end
    }  {
      sepChosen -2 eq {
        <<
        /setcmykcolor {
          pop pop pop pop 1 setgray
        } bind
        >> 1183615869 internaldict begin shadowop end
      } if
    } ifelse  % sepChosen -1 ne

    ShowSepNames {
      gsave
      0 RegisterColor
      CropSpace 0 Wid CropSpace 2 mul sub CropSpace Bleed sub rectfill

      CropSpace CropClearance add
      CropSpace Bleed sub LabelSize 0.9 mul sub % clear bleed
      moveto
      sepChosen dup -1 eq exch -3 eq or {
        /BoxSize CropSpace CropClearance sub 0.8 mul DeviceFudge def
        true setoverprint
        //ColorantList exec {
          dup /Name get exch
          [ /Separation 3 index /DeviceCMYK
          [ 6 -1 roll /CMYK get //BasicTintTransform /exec load ] cvx
          ] setcolorspace
          1. setcolor

          % If we're too far right start from left again
          currentpoint pop
          Wid CropSpace sub CropClearance sub BoxSize 9. mul sub
          CropSpace sub gt {
            CropSpace CropClearance add currentpoint exch pop
            moveto
          } if

          mark exch //ImpoString cvs
          FontStyle 0 ge {
            //FontStyles FontStyle get exch
            TranslateString_1
            LabelSize scalefont setfont
          } if
          blockshow cleartomark
          ( )tcblockshow
        } forall
      }  {
        % Pre-sep job. setcmykcolor has been redefined to only put these
        % on the correct seps.
        1. 0. 0. 0. setcmykcolor //Messages /Cyan get Translate show ( )show
        0. 1. 0. 0. setcmykcolor //Messages /Magenta get Translate show ( )show
        0. 0. 1. 0. setcmykcolor //Messages /Yellow get Translate show ( )show
        0. 0. 0. 1. setcmykcolor //Messages /Black get Translate show ( )show
        sepChosen -2 eq {
          % Spot sep in pre-sep job
          0 setgray
          /Separation currentsystemparam
          FontStyle 0 ge {
            //FontStyles FontStyle get exch
            TranslateString_1
            LabelSize scalefont setfont
          } if
          blockshow
        } if
      } ifelse
      grestore
    } if  % ShowSepNames

    ShowWedges {
      /BoxSize CropSpace CropClearance sub 0.8 mul DeviceFudge def
      sepChosen dup -1 eq exch -3 eq or {
        /WedgeCycle 0 def /WedgeSlot 0 def
        //ColorantList exec {
          [ /Separation 2 index /Name get
          /DeviceCMYK
          [ 6 -1 roll /CMYK get //BasicTintTransform /exec load ] cvx
          ] setcolorspace
          //CropMarkEndPage WedgeSlot get exec
          /WedgeSlot dup load 1 add
          dup 4 eq {
            /WedgeCycle dup load 1 add def
            Ht 2 div CropSpace sub CropClearance sub RegWidth sub
            WedgeCycle 1 add CropWedgeValues length BoxSize mul CropClearance add mul sub
            0 lt {
              pop pop
              exit
            } if
            pop 0
          } if def
        } forall
      }  {
        sepChosen 0 ge {
          /WedgeCycle 0 def
          /WedgeSlot sepChosen def
        }  {
          /WedgeCycle 1 def
          /WedgeSlot 0 def
        } ifelse
        0 setgray
        //CropMarkEndPage WedgeSlot get exec
      } ifelse
    } if  % ShowWedges

    ShowProgressives {
      gsave
      ProgressiveFont type /integertype eq {
        /FontStyle ProgressiveFont store
      }  {
      ProgressiveFont ProgressiveFontSize selectfont
        /FontStyle -1 store
      } ifelse
      /BoxSize CropSpace CropClearance sub 0.8 mul DeviceFudge def
      Wid CropSpace sub CropClearance sub BoxSize 9. mul sub
        CropSpace CropClearance sub 0.1 mul
        translate
      (C)  1. 0. 0. 0. Progressive
      (CM)  1. 1. 0. 0. Progressive
      (M)  0. 1. 0. 0. Progressive
      (MY)  0. 1. 1. 0. Progressive
      (Y)  0. 0. 1. 0. Progressive
      (CMY)  1. 1. 1. 0. Progressive
      % neutral(ish!!) gray
      (CMY50%) 0.5 0.5 0.5 0.  Progressive
      (K50%)  0. 0. 0. 0.5 Progressive
      grestore
    } if  % ShowProgressives
  }  {
    % NOT separating & not CMY or K
    ShowWedges {
      % Wedge - bottom left
      gsave
      CropSpace CropClearance add
      CropSpace CropClearance sub 0.1 mul translate
      /BoxSize CropSpace CropClearance sub 0.8 mul DeviceFudge def
      /WedgeCycle 0 def /WedgeSlot 0 def
      [ /Separation /Black /DeviceCMYK { 0 0 0 4 -1 roll } bind ] setcolorspace
      SpotWedge
      grestore
    } if
  } ifelse

  ShowCropMarks {
    0. CropSpace Ht CropSpace sub CropMark  % top left
    90. CropSpace dup CropMark      % bottom left
    180 Wid CropSpace sub CropSpace CropMark  % bottom right
    270 Wid CropSpace sub
      Ht CropSpace sub CropMark    % top right
  } if

  ShowRegisterMarks {
    RegWidth Ht 2. div RegMark     % Left
    Wid 2. div RegWidth RegMark      % Bottom
    Wid RegWidth sub Ht 2. div RegMark % right
    Wid 2. div Ht RegWidth sub RegMark % top
  } if  % ShowRegisterMarks

  restore
} bind def

/CropMarkInit {
  % Use crop min gutter instead of 'standard'
  //HqnImpose2GlobalDict begin
  /MinHGutter MinHCropGutter def
  /MinVGutter MinVCropGutter def
  /CropMarkInitialised true def
  end
} bind def

/HalftonePhaseBeginPage {
  0. PageWidth add 2 div
  0. PageHeight add 2 div
  transform
  2 { cvi exch } repeat
  sethalftonephase
} bind def

% *********************************************
% Misc extras

/TextOverlay {
% (>>TO: )print 2 copy == ==
  % call with font, text on stack, e.g.:
  %     /Helvetica (DRAFT) TextOverlay
  DebugReport {
    (    Text Overlay: )print dup ==
  } if

  gsave

  /TextOverlayText exch def
  100 selectfont

  clippath pathbbox % llx lly urx ury
  2 index sub 4 1 roll % ph llx lly urx
  2 index sub 4 1 roll % pw ph llx lly
  % width, height of current clipping path - that
  % will distinguish PageOverlay from FilmOverlay
  neg exch neg exch
  translate
  % we have moved to the bottom left of the
  % clipping area

  newpath 0 0 moveto
  TextOverlayText true charpath flattenpath pathbbox
        newpath

  3 -1 roll sub 3 1 roll exch sub % pw ph th tw
  exch 4 2 roll % tw th pw ph
  2 copy exch 2 div exch 2 div translate % tw th pw ph
  2 2 roll % pw ph tw th

  2 copy 2 copy lt { exch } if pop % pw ph tw th min(tw,th)
  4 index dup mul 4 index dup mul add sqrt div % w h pw ph scalefactor
  0.7 mul dup scale

  exch atan rotate % w h

  exch neg 2 div exch neg 2 div translate

  0 setgray 0 0 moveto TextOverlayText true charpath

  [ /Separation /All /DeviceCMYK { dup dup dup } ] setcolorspace
  gsave
  currentlinewidth 3 mul setlinewidth 0 setcolor stroke
  grestore
  1 setcolor stroke

  grestore
% (TO>>)=
}  def    % NOTE: not bound

/stringconcat {
  % string1, string2 -> string3.
  2 copy length exch length add string
  2 index 1 index copy pop
  dup 4 -1 roll length
  4 -1 roll putinterval
} bind def

% (remainder of comment line) priority -> ExecBounding -> |
/ExecBounding {
  //HqnImpose2Dict begin //HqnImpose2GlobalDict begin
  dup LookingForPageSize gt ParseBoundingBox and InExecBounding not and
  vmstatus pop pop
  BoundingSaveLevel le and
  statusdict /impositionstatus get exec not and {
    exch
% (EXECBOUNDING: )print dup ==
    (?) search {
      pop pop pop pop
    }  {
      mark exch
      { token not { exit } if exch } loop
      counttomark 4 eq {
        true 1 1 4 {
          index type dup
          /integertype eq exch /realtype eq or not {
            pop false
            exit
          } if
        } for
        {
          2 index sub dup 0 gt {
            exch 3 index sub dup 0 gt {
              exch
              <<
                /PageSize [ 5 -2 roll ]
                /OffsetX 6 -1 roll
                /OffsetY 7 -1 roll
              >> //setpagedevice
              /LookingForPageSize counttomark 1 add index def
            } if
          } if
        } if
      } if
      cleartomark
      pop
    } ifelse
  }  {
    pop pop
  } ifelse
  end end
} bind def

(%%dict) load (%%actions) get begin

/BoundingBox: {
  1 //ExecBounding exec
}
currentdict /BoundingBox: known {
  [
  /dup load /BoundingBox: load /exec load
  5 -1 roll /exec load
] cvx
} if
bind def
/PageBoundingBox: {
  2 //ExecBounding exec
}
currentdict /PageBoundingBox: known {
  [
  /dup load /PageBoundingBox: load /exec load
  5 -1 roll /exec load
] cvx
} if
bind def
/HiResBoundingBox: {
  3 //ExecBounding exec
}
currentdict /HiResBoundingBox: known {
  [
  /dup load /HiResBoundingBox: load /exec load
  5 -1 roll /exec load
] cvx
} if
bind def
/CropBox: {
  4 //ExecBounding exec
}
currentdict /CropBox: known {
  [
  /dup load /CropBox: load /exec load
  5 -1 roll /exec load
] cvx
} if
bind def

end

% Run shadowed operator if it exists, else call op in systemdict
/shadowproc 1183615869 internaldict /shadowproc get def

/testShadowed {
  //shadowproc exch 2 copy known { get null ne } { pop pop false } ifelse
} bind def

% make sure any screen selected has been through any shadowing of the screening operators
% so that calibration will work.
/doShadowedScreens  <</AdobeCurrentHalftone true /Password 0>> def
/doShadowedScreens {
  /AdobeCurrentHalftone currentsystemparam
  //doShadowedScreens dup /AdobeCurrentHalftone false put setsystemparams
  currenthalftone
  exch { //doShadowedScreens dup /AdobeCurrentHalftone true put setsystemparams } if
  /HalftoneType get 2 eq {
    [ /currentcolorscreen /setcolorscreen ]
  }  {
    currentscreen 3 1 roll pop pop
    type /dicttype eq {
      [ /currenthalftone /sethalftone ]
    }   {
      [ /currentscreen /setscreen ]
    } ifelse
  } ifelse
  dup 1 get //testShadowed exec {
      {
      dup //testShadowed exec { //shadowproc } { //systemdict } ifelse
      exch get exec
    } forall
  } { pop } ifelse
} bind def

/setpagedevicekeys <<
% stack comes in as dict, /key, val. Must leave dict on stack.

  % Always ignore setting ImagingBBox
  /ImagingBBox {
    pop currentglobal 3 -1 roll
    % key glob dict
    dup gcheck setglobal
    dup maxlength dict copy
    3 1 roll
    setglobal
    1 index exch undef
  } bind

  % Install StartRender keys round the setpagedevice call.
  /StartRender {
    % This is probably very naughty, but ...
    currentpagedevice /StartRender get begin
    dup { def } forall
    end
    pop currentglobal 3 -1 roll
    % key glob dict
    dup gcheck setglobal
    dup maxlength dict copy
    3 1 roll
    setglobal
    1 index exch undef
  } bind

  % File these away so that a later call that sets the page size will be able to act on them.
    {
    /NumCopies /Orientation /ExtraOrientation /Margins /MirrorPrint /Duplex /Tumble
    /ResamplingFactor /Scaling /HWResolution /JobName /NegativePrint /Separations
    /OverrideKeys /OverrideThroughput
  }  {
       {
      currentpagedevice 2 index 3 -1 roll { put } superexec
      2 copy undef pop
    } bind
  } forall

>> def

/RecombineEnabled {
  % Test whether recombine is turned on.

  recombinestatus pop
} bind def

/RecombineActive {
  % Test whether recombine is turned on and actually in use.
  recombinestatus 2 ge and
} bind def

/TestRecombination {
  % Check if recombine separations is turned on.
  % If so, show warning and stop.

  //RecombineEnabled exec {
    % Yes - it's on
    (%monitor)(w)file
    /Error //ShowMessage exec
    /Recombining //ShowMessage exec
    flush
    /HqnImpose2 errordict /undefinedresult get exec
  } if
} bind def

% Any keys in this dict are one-shot options in the call to HqnInitImpose and will not
% be copied into HqnImpose2Dict.
/OneShots <<
  % /SavePrior dup
>> def

% This dictionary lists names in the call to HanInitImpose which may have dictionary
% values, but where that dictionary should bodily replace the existing dict rather
% than being merged with it.
/OverWrites <<
  /PageOrder dup
>> def

/GutterMerge [
  [ /OptHGutter /OptVGutter /OptimalGutter ]
  [ /MinHGutter /MinVGutter /MinGutter ]
  [ /MinHCropGutter /MinVCropGutter /MinCropGutter ]
] def
/MergeConfig {
  dup type /dicttype ne
  //OverWrites 3 index known or {
    def
  }  {
    currentdict 2 index known {
      1 index load dup type /dicttype eq {
        % adding into existing dictionary
        begin
        { def } forall
        end
        pop  % the key
      }  {
        % the current value was not a dict - replace it.
        pop def
      } ifelse
    }  {
      % new dictionary
      def
    } ifelse
  } ifelse
} bind def
/MergeConfig {
    {
    //OneShots 2 index known {
      pop pop
    }  {
      % If the name is already known in HqnImpose2GlobalDict then store there
      % else if the name is already known in HqnImpose2Dict then store there
      % else if the value is global, store in HqnImpose2GlobalDict
      % else in HqnImpose2Dict.
      % Treat sub-dictionaries LOCAL and GLOBAL as special cases and store
      % their contents as appropriate.
      % Intent: allow dictionaries constructed for HqnImpose to work for most simple
      %   cases without modification, and provide mechanisms to add new keys as
      %   necessary.
      % key val
      1 index /LOCAL eq {
        //HqnImpose2Dict begin
        { //MergeConfig exec } forall
        pop
        end
      }  {
        1 index /GLOBAL eq {
          dup gcheck ne 1 index type /dicttype ne or {
            /Error ShowMessage /BadGLOBAL ShowMessage stop
          } if
          //HqnImpose2GlobalDict begin
          { //MergeConfig exec } forall
          pop
          end
        }  {
          //HqnImpose2GlobalDict 2 index known { true }{
            //HqnImpose2Dict 2 index known { false }{
              dup gcheck
            } ifelse
          } ifelse
            {
            dup gcheck not {
              dup type /stringtype eq {
                dup length currentglobal true setglobal exch string exch setglobal copy
              }  {
                1 index =print (   )print ==
                /Error ShowMessage /NonGlobal ShowMessage
                stop
              } ifelse
            } if
            //HqnImpose2GlobalDict
          }{ //HqnImpose2Dict } ifelse
          begin
          //MergeConfig exec
          end
        } ifelse
      } ifelse
    } ifelse
  } forall

  //HqnImpose2GlobalDict begin
  //GutterMerge {
    aload pop
    % opth optv opt
    currentdict 1 index known {
      dup 4 1 roll load
      2 copy def
      exch pop def
      currentdict exch undef
    }  {
      pop pop pop
    } ifelse
  } forall
  end
} bind def

/CheckPrevious <<
  /Imposition { false eq } bind
  /BeginPage { 0 get /HqnImpose2 ne } bind
  /EndPage 1 index
  /SensePageDevice 1 index
>> def

/NoFurtherCalls false def

% Read and munge in customisation dict from Usr/CustomImpose2
(%os%Usr/CustomImpose2) dup status {
  pop pop pop pop
  mark exch run
  counttomark 1 ne 1 index type /dicttype ne or {
    /Error ShowMessage /BadCustom ShowMessage
    % (Error: Usr/CustomImpose2 must return a dictionary and nothing else)=
    stop
  } if
  //MergeConfig exec
  pop  % mark
}  {
  pop % file name
} ifelse

/Dosetpagedevice {
  % Catch setpagedevice's originally supplied dictionary
  //HqnImpose2Dict /RequestDict 2 index put

  //setpagedevice
  //doShadowedScreens exec
  //HqnImpose2GlobalDict /HqnStopImpose get { stop } if

  currentpagedevice /Private get begin Width Height end
  { /ClippedHeight /ClippedWidth } { //HqnImpose2GlobalDict exch 3 -1 roll put } forall
} bind def

% Can be overridden by a calling environment
/JobFinished {
  //serverdict /stdin get status not
} bind def

% *********************************

5 dict begin

% The procset itself:
/HqnInitImpose {
% (>>II: )print //HqnImpose2GlobalDict /ImpositionInitialised get ==
  count 1 lt {
    /HqnInitImpose errordict /stackunderflow get exec
  } if
  dup type /dicttype ne {
    /HqnInitImpose errordict /typecheck get exec
  } if

  vmstatus pop pop dup 0 eq {
    pop
    //HqnImpose2Dict begin
    /Error ShowMessage /ImposeOutsideServerLoop ShowMessage
    end
    stop
  } if
  1 index /AllowSaveLevel known {
    pop
    dup /AllowSaveLevel get not
  } { 2 gt } ifelse {
    //HqnImpose2Dict begin
    /Error ShowMessage /ImposeNotAtTop ShowMessage
    end
    stop
  } if

  % stack - dictionary.
  //HqnImpose2GlobalDict begin
  /PageCount 0 def
  /FilmCount 0 def
  /PagesExposed 0 def

  /AbortOversize false def
  /AbortingJob false def

  //HqnImpose2Dict begin

  % Pass Tumble from pagedevice to Imposition. This is treated as RedBook tumble,
  % ie. rotate by 180 every back page. Note that if Duplex is set in the Imposition dict,
  % then we honour these settings regardless of the pagedevice keys.

  % dict on stack
  /HonourDuplexFromDevice true def
  dup /Duplex known {
    dup /Duplex get {
      % Honour pagedevice Duplex, if set
      /HonourDuplexFromDevice false def
    } if
  } if

  HonourDuplexFromDevice {
    currentpagedevice /Duplex known currentpagedevice /Tumble known and {
      currentpagedevice /Duplex get currentpagedevice /Tumble get and {
        /Tumble true def
        /RedBookTumble true def
        /Duplex true def
        /HardwareTumble { false } bind def
      } if
    } if
  } if
  //HqnImpose2Dict /HonourDuplexFromDevice undef


  NoFurtherCalls {
      /Error ShowMessage /NoFurtherCalls ShowMessage
      end
      stop
  } if


  % squirrel away things that we attempt to relinquish in HqnUnloadImpose
  % Scaling will always be valid (now!) but Imposition may not yet exist

  //HqnImpose2GlobalDict /ImpositionInitialised get 0 eq {
    /PriorScaling currentpagedevice /Scaling get def
    currentpagedevice /Imposition 2 copy known{
      get /PriorImposition exch def
    }{pop pop} ifelse

    /PriorEndPage currentpagedevice /EndPage get def
    /PriorBeginPage currentpagedevice /BeginPage get  def

  } if

  DeviceType null eq {
    /DeviceType
      currentpagedevice /XFeed 2 copy known
        { get } { pop pop false } ifelse {
        % =========================
        % how to detect FullDrum/PartDrum
        /deviceTypePartDrum
      }  {
        statusdict /mediasize get exec
        0 eq {
          % unlimited Y
          0 eq {
            % unlimited X as well
            /deviceTypeUnlimited
          }  {
            /deviceTypeCapstan
          } ifelse
        }  {
          pop
          /deviceTypeSheet
        } ifelse
      } ifelse

      DebugReport {
      (Device Type: )print dup ==
    } if
    store
  } if

  ImpositionInitialised 0 eq {
    % Save away the TimeSaving state for use on PartDrum devices.
    /TimeSaving currentpagedevice /TimeSaving get dup null eq { pop false } if def

    % Save away the page size from the page Setup dialog
    /BasePageSize currentpagedevice /PageSize get GlobalizeArray store

    statusdict /mediasize get exec % width height
    % 0 media size means unrestricted, so use page size instead
    dup 0 eq { pop BasePageSize 1 get } if

    /MediaHeight exch def
    dup 0 eq { pop BasePageSize 0 get } if
    /MediaWidth exch def
  }  {
    dup /CropSpace known {
      //BaseValues /CropSpace 2 index /CropSpace get put
    } if
  } ifelse

  Strategy null ne {
    /Objective load type /nametype eq {
      StrategyList Objective Strategy put
    } if
    /Strategy null store
  } if
  /Tactic load null ne {
    /Objective load type /nametype eq {
      TacticList Objective /Tactic load put
    } if
    /Tactic null store
  } if

  % copy all values in supplied dictionary into HqnImpose2Dict
  MergeConfig

  /Objective load type /nametype eq {
    StrategyList Objective 2 copy known Strategy null eq and {
      get /Strategy exch store
    } { pop pop } ifelse
    TacticList Objective 2 copy known /Tactic load null eq and {
      get /Tactic exch store
    } { pop pop } ifelse
  } if
  /Suffix load /FixedSizeSheet eq {
    /StandardBackstop false store
  } if

  ImpositionInitialised 0 eq {
    /BaseScaleX ScaleX store
    /BaseScaleY ScaleY store

    % Save away the scaling from the page Setup dialog, adjusting for any changes
    % in the call to HqnInitImpose
    % We embed the resamplingfactor in ScaleX and ScaleY at this point to reduce the
    % calculations required to generate film margins etc with 'physical' sizes rather
    % than logical ones, i.e. they don't get scaled.
                1 dict begin
                  /ResamplingFactor 1 def
      currentpagedevice begin
        Scaling aload pop
        BaseScaleY mul ResamplingFactor div exch
        BaseScaleX mul ResamplingFactor div
        /AAlias ResamplingFactor store
      end
      /ScaleX exch store
      /ScaleY exch store
          end

    % Make sure that the page size is defined.
    PageWidth null eq
      { /PageWidth BasePageSize 0 get store } if
    PageHeight null eq
      { /PageHeight BasePageSize 1 get store } if
  } if

  ScaleMode /None ne {
    ScaleWidth null eq {
      /ScaleWidth BasePageSize 0 get store
    } if
    ScaleHeight null eq {
      /ScaleHeight BasePageSize 1 get store
    } if
  } if

  % If opt gutter < min gutter then reduce min gutter
  OptHGutter MinHGutter lt { /MinHGutter OptHGutter store } if
  OptVGutter MinVGutter lt { /MinVGutter OptVGutter store } if

  CropMarks { CropMarkInitialised not { CropMarkInit } if } if

  { /OptHGutter /MinHGutter /OptVGutter /MinVGutter } {
    //BaseValues exch dup load put
  } forall

  % Additional bits from page feature
  InitExtra

  ImpositionInitialised 0 eq {
    % Make sure we can catch interupts in EndPage
    $error /errorname null put

    % Save any pre-defined SensePageDevice
    /PriorSensePage currentpagedevice /SensePageDevice get def

    % Pre-load setpagedevice requesting dictionary entry for
    % first call to SensePageDevice
    /RequestDict currentpagedevice dup length dict copy def

    % Under some circumstatnces, e.g. PartDrum where PageHeight>Media width,
    % the PageSize in currentpagedevice will already be clipped.
    RequestDict /PageSize [ PageWidth PageHeight ] put

    { /CropSpace /FilmTop /FilmBottom /FilmLeft /FilmRight }{
      //BaseValues exch dup load put
    } forall

    % now add imposition into pagedevice. This must be done inside
    % InitImpose rather than loose in the procset so that the procset
    % may be loaded during RIP start-up if desired, but we can minimise
    % processing here by simply loading up routines from
    % HqnImpose2Dict. It makes InitImpose easier to understand as well.

      <<
      % Tell the RIP we're imposing
      /Imposition true

      /SensePageDevice /SensePageDevice load

      /BeginPage /BeginPage load

      /EndPage /EndPage load

      /StartPainting /StartPainting load

      /SeparationDetails <<
        /Ignore
          currentpagedevice /SeparationDetails get /Ignore get
          dup type /nulltype eq {
            pop 1 dict
          }  {
            dup length 1 add dict copy
          } ifelse
          dup /EndPage true put
      >>

      /PageSize [ PageWidth PageHeight ]

      /Deactivate 666

    >> //setpagedevice

    <<
    /setpagedevice {
      //ImposeDebug { (Impose setpagedevice+)= } if
% (>>SPD)=  dup  { exch =print (  )print == }forall (++++++++++++++++++++++++)=
      % Only call setpageparams if we're at the beginning of a film
      % Can't just use override since some jobs set the page size
      % several times and we want the last 'real' one.
      % We only know what that is when the first page is imaged and
      % setting override then would wipe it.
      % If we let all calls through then concatenating several
      % job files would wipe previous pages.
                        % Substitute incoming dictionary with a shallow copy because we might
                        % undef some disallowed keys.
                        dup length dict copy

                        currentpagedevice /OverrideKeys get

                        % Knock out disallowed changes

                        {
                          {
                            1 index exch undef
                          }
                          {
                            pop
                          } ifelse
                        } forall

                        % |- << SPD >> (with disallowed keys removed)

% (>>SPD altered)=  dup  { exch =print (  )print == }forall (++++++++++++++++++++++++)=

      % Wipe irrelevant bits that must *NOT* be passed through, or must ALWAYS be
      % passed round setpagedevice
      dup   {
        //setpagedevicekeys 2 index 2 copy
        known   {
          get exec
        }  {
          pop pop pop pop
        } ifelse
      } forall

      % Don't allow anything to screw us up.
      //CheckPrevious {
        % newdict key test
        3 copy pop known {
          2 index 3 -1 roll get exch exec {
            //HqnImpose2Dict begin
            /Error ShowMessage /IllegalCall ShowMessage
            % (Error: setpagedevice call including illegal procedure when)=
            % (       used with HqnImpose2 ProcSet: )print
            =print /CloseError ShowMessage flush
            end
            stop
          } if
        } { pop pop } ifelse
      } forall

      % let it through if it's the end of the job - it triggers the final
      % device deactivation call to EndPage
      //HqnImpose2Dict /JobFinished get exec
        $error /errorname get /interrupt ne and
      dup 2 index length 0 gt or
      //HqnImpose2GlobalDict /ImpositionInitialised get 2 lt or
        {
        //HqnImpose2GlobalDict /PageCount get 0 eq
            //HqnImpose2GlobalDict /AlwaysRespond get not
            and or
        //HqnImpose2GlobalDict /ImpositionInitialised get 2 lt
        or {
          //Dosetpagedevice exec
        }  {
          % Compare any requested PageSize with that currently in use. If more than 5 pts different in
          % either dimension then warn. The 5 pts comes from the limits used on PageSize Policies
          % decisions from the Red Book
          dup /PageSize known {
            //HqnImpose2GlobalDict begin //HqnImpose2Dict begin
            PageWidth null ne {
              dup
              /PageSize get aload pop
              PageHeight sub
              CropMarks CropsInside and { CropSpace 2. mul add } if
              abs PageSizeMatch gt
              exch
              PageWidth sub
              CropMarks CropsInside and { CropSpace 2. mul add } if
              abs PageSizeMatch gt
              or  {
                /Response load null eq {
                  /Response /RespondPending store
                } if
                DebugReport {
                  (Response: )print
                  /Response load dup type /nametype ne { pop (**Procedure**) } if
                  ==
                } if
                /Response load dup type /nametype eq {
                  Responses exch { get } //stopcheck exec {
                    /Error ShowMessage /Response ShowMessage
                    =print /CloseError ShowMessage flush
                    % (Error: unknown imposition Response: )print
                    stop
                  } if
                } if
                //stopcheck exec {   % response proc.
                  /Error ShowMessage /runResponse ShowMessage
                  % (Error: while running imposition Response procedure)=
                  ReportError
                  stop
                } if
                  {
                  //Dosetpagedevice exec
                }  {
                  CancelCurrentPage
                } ifelse
              }  {
                pop
                initgraphics
                erasepage
                //HqnImpose2GlobalDict /ObjectOnPage false put
              } ifelse
            }  {
              pop
              erasepage
              initgraphics
              //HqnImpose2GlobalDict /ObjectOnPage false put
            } ifelse
            end end  % HqnImpose2Dict, HqnImpose2GlobalDict
          }  {
            % don't pass the dictionary through.
            % This will ignore changes to Orientation, ExtraOrientation and Scaling
            % unless there's also a PageSize change, but that is OK.
            % ===================================
            pop
            erasepage
            initgraphics
            //HqnImpose2GlobalDict /ObjectOnPage false put
          } ifelse
        } ifelse
      }  {
        pop pop    % boolean and dictionary
        erasepage
        initgraphics
        //HqnImpose2GlobalDict /ObjectOnPage false put
      } ifelse
      //HqnImpose2GlobalDict /ImpositionInitialised 2 put
% (SPD>>)=
      //ImposeDebug { (Impose setpagedevice-)= } if
    } bind

    /copypage {
      //HqnImpose2Dict begin
      /Warning ShowMessage /copypageWarn ShowMessage
      end
      copypage
    } bind

    >> 1183615869 internaldict /shadowop get exec

    % Turn PseudoErasePage off, so that pagebbox returns marks in all conditions
    << /EnablePseudoErasePage false >> setuserparams

    % Only run these parts the first time the procset is called.
    % Set to 1 if in job initialization, otherwise set straight to 2.
    /ImpositionInitialised vmstatus pop pop 2 lt { 1 }{ 2 } ifelse store


    % Early end if recombining and multiple pages.
    % It's safer to trigger an abort outside the page device calls,
    % and it can be much quicker too.
    (%%dict) load (%%actions) get begin

    /Page: {
      pop
      //HqnImpose2GlobalDict /PagesPerFilm get 1 gt {
        //HqnImpose2Dict /TestRecombination get //stopcheck exec {
          serverdict /terminatejobnow get exec
        } if
      } if
    }
    currentdict /Page: known {
      [
      /dup load /Page: load /exec load
      5 -1 roll /exec load
    ] cvx
    } if
    bind def

    end
  }  {
    //HqnImpose2GlobalDict /ImpositionInitialised 2 copy get 3 1 roll 1 put
    << /PageSize [
      RequestPageWidth RequestPageHeight
      CropMarks CropsInside and {
        2 { CropSpace 2 mul sub exch } repeat
      } if
    ] >> //setpagedevice
    //HqnImpose2GlobalDict /ImpositionInitialised 3 -1 roll put
  } ifelse    % first call to initialise

  DebugFilm {
    0 1 PagesPerFilm 1 sub {
      1 add DebugPage
      showpage
    } for
  } if

  /LookingForPageSize 0 store

  end end  % HqnImpose2Dict & global
% (II>>)=
} bind def

/HqnFlushFilm {
  % Start next film
  % No crops etc are added for the current page
  //HqnImpose2Dict /FlushFilm get exec
} bind def

% Called to check whether separation recombination is on.
/HqnTestRecombination {
  //HqnImpose2Dict /TestRecombination get exec
} bind def

/HqnMergeConfig {
  //HqnImpose2GlobalDict begin
  //HqnImpose2Dict begin
  MergeConfig
  end
  end
} bind def

% Call this to make a reasonable attempt at unloading HqnImpose2
% code. This cannot be guaranteed to excise just the right bits.
/HqnUnloadImpose {
  //HqnImpose2GlobalDict /ImpositionInitialised get 0 gt {
      <<
        {
        /setpagedevice /copypage
      }  { null } forall
    >> 1183615869 internaldict /shadowop get exec

    //HqnImpose2GlobalDict begin

    //HqnImpose2Dict begin
    <<
      /EndPage /PriorEndPage load
      /BeginPage /PriorBeginPage load
      /SensePageDevice /PriorSensePage load
      /Imposition /PriorImposition load
      /Scaling /PriorScaling load
    >> //setpagedevice
    end

    /ImpositionInitialised 0 def

    /DeviceType null def
    /Objective /OneUp def  % default Objective
    /Strategy null def
    /Aspect null def

    /MaxHeight 0 def
    /MaxWidth 0 def
    /MinHeight 0 def
    /MinWidth 0 def

    /UnlimitedMediaWidth 0 def
    /UnlimitedMediaHeight 0 def

    /LimitPageCount 0 def

    /PageWidth null def
    /PageHeight null def
    /RequestPageWidth 0 def
    /RequestPageHeight 0 def

    /PanelWidth null def
    /PanelHeight null def
    /PanelOffsetX 0 def
    /PanelOffsetY 0 def
    /ClipPath null def
    /GutterClip null def
    /SrcClipPath null def

    /OffsetX 0 def
    /OffsetY 0 def

    /PagesUp null def
    /PagesAcross null def

    /ScaleY  1. def
    /ScaleX  1. def
    /BaseScaleX 1. def
    /BaseScaleY 1. def
    /AAlias 1 def

    /ScaleMode  /None def
    /ScaleAspect  /BestFit def
    /ScaleWidth  null def
    /ScaleHeight  null def
    /PageScaleX  1. def
    /PageScaleY  1. def
    /PageClipped false def

    /PageList null  def

    end    % HqnImpose2GlobalDict
  } if
} bind def

% If imposition is active, return the number of pages to be placed on each film
/HqnCurrentPagesPerFilm
{
  //HqnImpose2GlobalDict begin
    ImpositionInitialised 0 gt { PagesPerFilm } { 1 } ifelse
  end
} bind def

% Test to see if imposition is active
/HqnImpose2Active {
  //HqnImpose2GlobalDict /ImpositionInitialised get
  0 ne
} bind def

/HqnCancelCurrentPage {
  //CancelCurrentPage exec
} bind def

currentdict end

/HqnImpose2 exch /ProcSet defineresource pop

end  % HqnImpose2Dict
end  % HqnImpose2GlobalDict

//HqnImpose2Dict /globalness get
setglobal

%%EndProcSet
