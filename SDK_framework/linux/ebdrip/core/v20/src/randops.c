/** \file
 * \ingroup ps
 *
 * $HopeName: SWv20!src:randops.c(EBDSDK_P.1) $
 *
 * Copyright (C) 1992-2009 Global Graphics Software Ltd. All rights reserved.
 * Global Graphics Software Ltd. Confidential Information.
 *
 * \brief
 * PS random operators
 */

#include "core.h"
#include "swoften.h" /* public file */
#include "often.h"

#include "bitblts.h"
#include "matrix.h"
#include "constant.h"
#include "objects.h"
#include "params.h"
#include "stacks.h"
#include "swerrors.h"

#include "randops.h"
#include "control.h"

/* Constants & variables used in the Random Number Generator */

#define RAND_SEED         1
#define RAND_MULTIPLIER   16807
#define RAND_MODULUS      0x7FFFFFFF    /* 2^31 - 1 */

/* Values used to scale intermediate calculations to avoid integer overflow */

#define RAND_SCALE        (RAND_MODULUS / RAND_MULTIPLIER)
#define RAND_REMAINDER    (RAND_MODULUS % RAND_MULTIPLIER)

/*
 * Multiply one non-negative and one positive integer together checking
 * that integer overflow does not occur
 */

#define CHECK_MUL( s, a, b ) MACRO_START \
  int32 _a_ = (a) ; \
  int32 _b_ = (b) ; \
\
  HQASSERT( _a_ >= 0, "CHECK_MUL: first operand < 0" ) ; \
  HQASSERT( _b_ >  0, "CHECK_MUL: second operand <= 0" ) ; \
  HQASSERT( _a_ <= MAXINT32 / _b_, "CHECK_MUL: overflow" ) ; \
\
  (s) = _a_ * _b_ ; \
MACRO_END

static int32 seed = RAND_SEED ;


void initRandomNumberGenerator( void )
{
  seed = RAND_SEED ;
}

/* ----------------------------------------------------------------------------
   function:            rand_()            author:              Andrew Cave
   creation date:       12-Oct-1987        last modification:   ##-###-####
   arguments:           none .
   description:

   See PostScript reference manual page 207.

   The implementation is mathematically described by:

    seed = (seed * RAND_MULTIPLIER) % RAND_MODULUS

   However, we need to perform this in stages to avoid integer overflow
   of the intermediate result.

---------------------------------------------------------------------------- */

Bool rand_(ps_context_t *pscontext)
{
  int32 tmp;

  UNUSED_PARAM(ps_context_t *, pscontext) ;

  CHECK_MUL( tmp,  seed / RAND_SCALE, RAND_REMAINDER ) ;
  CHECK_MUL( seed, seed % RAND_SCALE, RAND_MULTIPLIER ) ;

  if ( seed <= tmp )
    tmp -= RAND_MODULUS;

  seed -= tmp;

  HQASSERT( 0 < seed && seed < RAND_MODULUS, "rand_: invalid result" ) ;

  oInteger(inewobj) = seed ;
  return push( & inewobj , & operandstack ) ;
}

/* ----------------------------------------------------------------------------
   function:            srand_()           author:              Andrew Cave
   creation date:       12-Oct-1987        last modification:   ##-###-####
   arguments:           none.
   description:

   See PostScript reference manual page 224.

---------------------------------------------------------------------------- */
Bool srand_(ps_context_t *pscontext)
{
  OBJECT *theo ;

  UNUSED_PARAM(ps_context_t *, pscontext) ;

  if ( isEmpty( operandstack ))
    return error_handler( STACKUNDERFLOW ) ;

/*  The seed for the random number generator must be an integer.  */
  theo = theTop( operandstack ) ;
  if ( oType(*theo) != OINTEGER )
    return error_handler( TYPECHECK ) ;

  seed = oInteger(*theo) ;

/*
 * Modify seed to be in the range 0 < seed < RAND_MODULUS
 * (see task #04794 for more details)
 */

  if ( seed <= 0 ) {
    if ( seed <= -(RAND_MODULUS - 1) )
      seed += RAND_MODULUS - 1 ;
    seed = 1 - seed ;
  }
  else if ( seed >= RAND_MODULUS )
    seed = RAND_MODULUS - 1;

  HQASSERT( 0 < seed && seed < RAND_MODULUS, "srand_: invalid seed" ) ;

  pop( & operandstack ) ;

  return TRUE ;
}

/* ----------------------------------------------------------------------------
   function:            rrand_()           author:              Andrew Cave
   creation date:       12-Oct-1987        last modification:   ##-###-####
   arguments:           none .
   description:

   See PostScript reference manual page 207.

---------------------------------------------------------------------------- */
Bool rrand_(ps_context_t *pscontext)
{
  UNUSED_PARAM(ps_context_t *, pscontext) ;

  oInteger(inewobj) = seed ;
  return push( & inewobj , & operandstack ) ;
}


/* A Sobol' sequence is a quasi-random sequence which exhibits more uniform
   distribution of points in the range of its output than does a random
   sequence. These sequences are useful in sampling applications, where a
   smaller number of samples generated by the Sobol' sequence will cover the
   sample space evenly, with further samples refining the result.

   For a quick discussion of Sobol' sequences, see "Numerical Recipes in C",
   2nd edition, pp. 309-315.

   The routine sobol() stores the next values of two Sobol' sequences into
   the pointers provided. If the sequence count is negative on entry, the
   fractions are used to initialise the last_x and last_y values. After
   initialisation, it should be called with incrementing sequence counts
   starting from zero. */
void sobol(int32 seqn, SYSTEMVALUE *xp, SYSTEMVALUE *yp)
{
#define FRACBITS 30 /* Fractional bits in result (<= 30) */
  SYSTEMVALUE factor = 1.0 / (1L << FRACBITS) ;

  static uint32 last_x, last_y ;

  /* Bit tables are identified by degree and polynomial. Tables generated
     by SWv20!testsrc:shfills:sobol.pl */
  static uint32 bits_1_0[FRACBITS] = {
    0x20000000, 0x30000000, 0x28000000, 0x3c000000, 0x22000000, 0x33000000,
    0x2a800000, 0x3fc00000, 0x20200000, 0x30300000, 0x28280000, 0x3c3c0000,
    0x22220000, 0x33330000, 0x2aaa8000, 0x3fffc000, 0x20002000, 0x30003000,
    0x28002800, 0x3c003c00, 0x22002200, 0x33003300, 0x2a802a80, 0x3fc03fc0,
    0x20202020, 0x30303030, 0x28282828, 0x3c3c3c3c, 0x22222222, 0x33333333,
  } ;
  static uint32 bits_2_1[FRACBITS] = {
    0x20000000, 0x10000000, 0x38000000, 0x2c000000, 0x1a000000, 0x3d000000,
    0x21800000, 0x13c00000, 0x3a200000, 0x2d100000, 0x19b80000, 0x3fec0000,
    0x203a0000, 0x102d0000, 0x38198000, 0x2c3fc000, 0x1a202000, 0x3d101000,
    0x21b83800, 0x13ec2c00, 0x3a3a1a00, 0x2d2d3d00, 0x1999a180, 0x3fffd3c0,
    0x20001a20, 0x10003d10, 0x380021b8, 0x2c0013ec, 0x1a003a3a, 0x3d002d2d,
  } ;

  HQASSERT(xp, "No X pointer in sobol") ;
  HQASSERT(yp, "No Y pointer in sobol") ;
  HQASSERT(bits_1_0[0] == (1L << (FRACBITS - 1)), "Bad Sobol' table for X dimension") ;

  HQASSERT(bits_2_1[0] == (1L << (FRACBITS - 1)), "Bad Sobol' table for Y dimension") ;

  if ( seqn < 0 ) {
    HQASSERT(*xp >= 0 && *xp < 1.0, "Initialising X factor out of range") ;
    HQASSERT(*yp >= 0 && *yp < 1.0, "Initialising Y factor out of range") ;

    last_x = (uint32)(*xp * (1L << FRACBITS)) ;
    last_y = (uint32)(*yp * (1L << FRACBITS)) ;
  } else { /* Next numbers in sequence */
    int32 bitindex = 0 ;

    while ( (seqn & 1) != 0 ) { /* Find rightmost zero bit */
      ++bitindex ;
      seqn >>= 1 ;
    }
    HQASSERT(bitindex < FRACBITS, "FRACBITS too small, or sequence too long") ;

    last_x ^= bits_1_0[bitindex] ;
    last_y ^= bits_2_1[bitindex] ;
    *xp = last_x * factor ;
    *yp = last_y * factor ;
    HQASSERT(*xp >= 0 && *xp <= 1.0, "Sobol' X result out of range") ;
    HQASSERT(*yp >= 0 && *yp <= 1.0, "Sobol' Y result out of range") ;
  }
}

void init_C_globals_randops(void)
{
  seed = RAND_SEED ;
}

/* Log stripped */
