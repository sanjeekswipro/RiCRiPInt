/** \file
 * \ingroup pdfin
 *
 * $HopeName: SWpdf!src:pdfops.c(EBDSDK_P.1) $
 *
 * Copyright (C) 1997-2014 Global Graphics Software Ltd. All rights reserved.
 * Global Graphics Software Ltd. Confidential Information.
 *
 * \brief
 * PDF Operators Implementation
 */

#include "core.h"
#include "pdfops.h"
#include "swerrors.h"
#include "objects.h"
#include "hqmemcpy.h"
#include "hqmemset.h"

#include "control.h"
#include "display.h" /* dl_safe_recursion */
#include "devices.h"
#include "fileio.h"
#include "monitor.h"
#include "params.h"
#include "rbtree.h"
#include "render.h"
#include "routedev.h"
#include "stacks.h"
#include "swcopyf.h"
#include "swpdfin.h"
#include "swerrors.h"
#include "swmemory.h"
#include "tables.h"
#include "trap.h"
#include "lowmem.h" /* mm_memory_is_low */

#include "pdfbxex.h"
#include "pdfclip.h"
#include "pdfcolor.h"
#include "pdfdefs.h"
#include "pdfexec.h"
#include "pdffont.h"
#include "pdfgstat.h"
#include "pdfimg.h"
#include "pdfin.h"
#include "pdfinlop.h"
#include "pdfmc.h"
#include "pdfmem.h"
#include "pdfpaint.h"
#include "pdfpseg.h"
#include "pdfrr.h"
#include "pdfscan.h"
#include "pdfsgs.h"
#include "pdftxt.h"
#include "pdftype3.h"
#include "pdfvign.h"
#include "pdfxobj.h"

#include "namedef_.h"

#if defined( ASSERT_BUILD )
static Bool trace_pdf_ops = FALSE ;
#endif

/* ---------------------------------------------------------------------- */

/** PDF operator table entry. */

typedef struct pdfop {
  /** The null-terminated operator name. */
  uint8 name[ 4 ] ;

  /** The operator entry point. */
  PDFOPFN opcall ;

  /** The unique identifier. */
  uint8 pdfop ;

  /** Does calling this operator usually result in a mark on the page?
      (May not happen if, for example, it's clipped out or falls
      outside the page bounds) */
  uint8 marking ;

  /* Has this operator been made safe for GC? */
  uint8 gc_safe;

  /** Standard states as per pdf spec. */
  int32 stdstate ;

  /** Extra states permitted when not strictpdf. */
  int32 extstate ;

  /** Return state for ops that change state. 0 means "no change". */
  int32 retstate ;
} PDFOP ;

/** Accessor function for operator name. */

uint8 *pdf_op_name( void *pdfop )
{
  return (( PDFOP * )pdfop )->name ;
}

/** Accessor function for operator identifier. */

uint8 pdf_op_number( void *pdfop )
{
  return (( PDFOP * )pdfop )->pdfop ;
}

/** Accessor function for operator function. */

PDFOPFN pdf_op_call( void *pdfop )
{
  return (( PDFOP * )pdfop )->opcall ;
}

/** Accessor function for operator marking flag. */

Bool pdf_op_marking( void *pdfop )
{
  return (( PDFOP * )pdfop )->marking ;
}

/** The operator table. The order is critical! It's fine to change the
    flags etc. but DO NOT change the order, insert or delete
    items. This is a perfect (non-minimal) hash table, generated by
    GNU gperf. See \c SWpdf!testsrc:ophash:* for the details. If there
    should ever be any change to the PDF operator set, this table will
    need to be regenerated. Note that slot zero is empty in the
    generated hash - which is handy because we can hijack that to use
    as our catch-all "Unkown" slot which is used for correct BX/EX
    handling. */

static struct pdfop pdfops[] = {
  { ""            , pdfop_Unknown , PDFOP_NONE,FALSE, FALSE, OPSTATE_ALL , 0 , 0 } ,
  { { 'n' , 0 , 0 , 0 }, pdfop_n  , PDFOP_n  , FALSE, FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'T' ,'m', 0 , 0 }, pdfop_Tm , PDFOP_Tm , FALSE, FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { { 'K' , 0 , 0 , 0 }, pdfop_K  , PDFOP_K  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'T' ,'J', 0 , 0 }, pdfop_TJ , PDFOP_TJ , TRUE , FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { "" }  ,
  { { 's' , 0 , 0 , 0 }, pdfop_s  , PDFOP_s  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'T' ,'r', 0 , 0 }, pdfop_Tr , PDFOP_Tr , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { { '\"', 0 , 0 , 0 }, pdfop_T2q, PDFOP_T2q, TRUE , FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { { 'T' ,'z', 0 , 0 }, pdfop_Tz , PDFOP_Tz , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { "" }  ,
  { { 'd' , 0 , 0 , 0 }, pdfop_d  , PDFOP_d  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'T' ,'c', 0 , 0 }, pdfop_Tc , PDFOP_Tc , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { "" }  ,
  { { 'T' ,'w', 0 , 0 }, pdfop_Tw , PDFOP_Tw , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { "" }  ,
  { { 'B' , 0 , 0 , 0 }, pdfop_B  , PDFOP_B  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 's' ,'c', 0 , 0 }, pdfop_sc , PDFOP_sc , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 's' ,'c','n', 0 }, pdfop_scn, PDFOP_scn, FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'T' ,'d', 0 , 0 }, pdfop_Td , PDFOP_Td , FALSE, FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { "" }  ,
  { { 'g' , 0 , 0 , 0 }, pdfop_g  , PDFOP_g  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'T' ,'f', 0 , 0 }, pdfop_Tf , PDFOP_Tf , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { { 'B' ,'M','C', 0 }, pdfop_BMC, PDFOP_BMC, FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATH_OR_TEXT , 0 } ,
  { { 'P' ,'S', 0 , 0 }, pdfop_PS , PDFOP_PS , TRUE , FALSE, OPSTATE_PDL        , 0 , 0 } ,
  { "" }  ,
  { { 'J' , 0 , 0 , 0 }, pdfop_J  , PDFOP_J  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'T' ,'s', 0 , 0 }, pdfop_Ts , PDFOP_Ts , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { "" }  ,
  { { 'C' ,'S', 0 , 0 }, pdfop_CS , PDFOP_CS , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { { 'c' , 0 , 0 , 0 }, pdfop_c  , PDFOP_c  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 'c' ,'m', 0 , 0 }, pdfop_cm , PDFOP_cm , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT | OPSTATE_TEXTOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { { 'd' ,'1', 0 , 0 }, pdfop_d1 , PDFOP_d1 , FALSE, FALSE, OPSTATE_TYPE3FONT  , 0 , OPSTATE_PDL } ,
  { "" }  ,
  { { 'Q' , 0 , 0 , 0 }, pdfop_Q  , PDFOP_Q  , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'T' ,'D', 0 , 0 }, pdfop_TD , PDFOP_TD , FALSE, FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { "" }  ,
  { { 'I' ,'D', 0 , 0 }, pdfop_ID , PDFOP_ID , TRUE , FALSE, OPSTATE_IMGOBJECT  , 0 , 0 } ,
  { "" }  ,
  { { 'S' , 0 , 0 , 0 }, pdfop_S  , PDFOP_S  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'B' ,'I', 0 , 0 }, pdfop_BIV, PDFOP_BIV, FALSE, FALSE, OPSTATE_PDL        , 0 , OPSTATE_IMGOBJECT } ,
  { { 'E' ,'M','C', 0 }, pdfop_EMC, PDFOP_EMC, FALSE, FALSE, OPSTATE_PDL        , OPSTATE_TEXTOBJECT , 0 } ,
  { { 'd' ,'0', 0 , 0 }, pdfop_d0 , PDFOP_d0 , FALSE, FALSE, OPSTATE_TYPE3FONT  , OPSTATE_PDL , OPSTATE_PDL } ,
  { "" }  ,
  { { 'f' , 0 , 0 , 0 }, pdfop_f  , PDFOP_f  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'g' ,'s', 0 , 0 }, pdfop_gs , PDFOP_gs , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'M' , 0 , 0 , 0 }, pdfop_M  , PDFOP_M  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'T' ,'L', 0 , 0 }, pdfop_TL , PDFOP_TL , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, 0 , 0 } ,
  { { 'B' ,'D','C', 0 }, pdfop_BDC, PDFOP_BDC, FALSE, FALSE, OPSTATE_PDL        , OPSTATE_TEXTOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { { 'j' , 0 , 0 , 0 }, pdfop_j  , PDFOP_j  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'c' ,'s', 0 , 0 }, pdfop_cs , PDFOP_cs , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'b' , 0 , 0 , 0 }, pdfop_b  , PDFOP_b  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'E' ,'I', 0 , 0 }, pdfop_EIV, PDFOP_EIV, FALSE, FALSE, OPSTATE_IMGOBJECT  , 0 , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'h' , 0 , 0 , 0 }, pdfop_h  , PDFOP_h  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 'D' ,'P', 0 , 0 }, pdfop_DP , PDFOP_DP , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_TEXTOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'y' , 0 , 0 , 0 }, pdfop_y  , PDFOP_y  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 'S' ,'C', 0 , 0 }, pdfop_SC , PDFOP_SC , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'S' ,'C','N', 0 }, pdfop_SCN, PDFOP_SCN, FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { "" }  ,
  { { 'W' , 0 , 0 , 0 }, pdfop_W  , PDFOP_W  , FALSE, FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , 0 } ,
  { { 'T' ,'*', 0 , 0 }, pdfop_T1s, PDFOP_T1s, FALSE, FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'w' , 0 , 0 , 0 }, pdfop_w  , PDFOP_w  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'c' ,'q', 0 , 0 }, pdfop_cq , PDFOP_cq , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'v' , 0 , 0 , 0 }, pdfop_v  , PDFOP_v  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 'M' ,'P', 0 , 0 }, pdfop_MP , PDFOP_MP , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_TEXTOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'q' , 0 , 0 , 0 }, pdfop_q  , PDFOP_q  , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'B' ,'*', 0 , 0 }, pdfop_B1s, PDFOP_B1s, TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'm' , 0 , 0 , 0 }, pdfop_m  , PDFOP_m  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 'r' ,'e', 0 , 0 }, pdfop_re , PDFOP_re , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'k' , 0 , 0 , 0 }, pdfop_k  , PDFOP_k  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'T' ,'j', 0 , 0 }, pdfop_Tj , PDFOP_Tj , TRUE , FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'i' , 0 , 0 , 0 }, pdfop_i  , PDFOP_i  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT , 0 } ,
  { { 'r' ,'i', 0 , 0 }, pdfop_ri , PDFOP_ri , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'l' , 0 , 0 , 0 }, pdfop_l  , PDFOP_l  , FALSE, FALSE, OPSTATE_PDL_OR_PATH, 0 , OPSTATE_PATHOBJECT } ,
  { { 's' ,'h', 0 , 0 }, pdfop_sh , PDFOP_sh , TRUE , FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'G' , 0 , 0 , 0 }, pdfop_G  , PDFOP_G  , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { { 'r' ,'g', 0 , 0 }, pdfop_rg , PDFOP_rg , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'F' , 0 , 0 , 0 }, pdfop_f  , PDFOP_f  , TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { { 'f' ,'*', 0 , 0 }, pdfop_f1s, PDFOP_f1s, TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { '\'', 0 , 0 , 0 }, pdfop_T1q, PDFOP_T1q, TRUE , FALSE, OPSTATE_TEXTOBJECT , 0 , 0 } ,
  { { 'B' ,'X', 0 , 0 }, pdfop_BX , PDFOP_BX , FALSE, FALSE, OPSTATE_ALL        , 0 , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'D' ,'o', 0 , 0 }, pdfop_Do , PDFOP_Do , TRUE , FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'b' ,'*', 0 , 0 }, pdfop_b1s, PDFOP_b1s, TRUE , FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'B' ,'T', 0 , 0 }, pdfop_BT , PDFOP_BT , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATH_OR_TEXT , OPSTATE_TEXTOBJECT } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'E' ,'X', 0 , 0 }, pdfop_EX , PDFOP_EX , FALSE, FALSE, OPSTATE_ALL        , 0 , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'W' ,'*', 0 , 0 }, pdfop_W1s, PDFOP_W1s, FALSE, FALSE, OPSTATE_PATHOBJECT , OPSTATE_ALL , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'c' ,'Q', 0 , 0 }, pdfop_cQ , PDFOP_cQ , FALSE, FALSE, OPSTATE_PDL        , OPSTATE_PATHOBJECT , 0 } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'E' ,'T', 0 , 0 }, pdfop_ET , PDFOP_ET , FALSE, FALSE, OPSTATE_TEXTOBJECT , 0 , OPSTATE_PDL } ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { "" }  ,
  { { 'R' ,'G', 0 , 0 }, pdfop_RG , PDFOP_RG , FALSE, FALSE, OPSTATE_PDL_OR_TEXT, OPSTATE_PATHOBJECT | OPSTATE_TYPE3FONT , 0 }
} ;

/* ---------------------------------------------------------------------- */

/** Execute the current content stream of the given PDF context. */

int32 pdf_execops( PDFCONTEXT *pdfc , int32 state , int stream_type )
{
  STACK *stack ;
  OBJECT *contents ;
  FILELIST *flptr ;

  int saved_dl_safe_recursion = dl_safe_recursion;
  int saved_gc_safety_level = gc_safety_level;
  PDF_IMC_PARAMS *imc ;
  PDFXCONTEXT *pdfxc ;
  PDF_IXC_PARAMS *ixc ;

  FILELIST *rr_flptr = NULL ;
  OBJECT rr_page = OBJECT_NOTVM_NULL ;
  void *rr_priv = NULL ;

  int32 pres_device = CURRENT_DEVICE() ;

  PDF_CHECK_MC( pdfc ) ;
  PDF_GET_IMC( imc ) ;
  PDF_GET_XC( pdfxc ) ;
  PDF_GET_IXC( ixc ) ;

  HQASSERT( state != OPSTATE_ERROR , "Error state passed into pdf_execops" ) ;

  /* Make sure we don't recurse indefinitely, by imposing a limit on the
     recursion depth. */
  if ( ps_interpreter_level >= pdfc->corecontext->systemparams->MaxInterpreterLevel ) {
    ( void )error_handler( LIMITCHECK ) ;
    state = OPSTATE_ERROR ;
    goto CLEANUP ;
  }
  ++ps_interpreter_level;

  stack = ( & imc->pdfstack ) ;

  if ( ! pdf_get_content( pdfc, & contents )) {
    FAILURE( state = OPSTATE_ERROR ) ;
    goto CLEANUP ;
  }

  if ( contents == NULL ) {
    goto CLEANUP ;
  }

  HQASSERT( oType(*contents) == OFILE ,
            "Invalid content stream in pdf_execops" ) ;
  flptr = oFile(*contents) ;

  if ( ! pdf_rr_start_exec( pdfc , & flptr , stream_type ,
                            & rr_page , & rr_flptr , & rr_priv )) {
    FAILURE( state = OPSTATE_ERROR ) ;
    goto CLEANUP ;
  }

  for (;;) {
    int32 result = TRUE ;
    OBJECT nextobj = OBJECT_NOTVM_NOTHING ;

    /* Code for handling low memory, interrupts, timeouts, etc. */
    if ( mm_memory_is_low || dosomeaction )
      if ( !handleNormalAction() ) {
        FAILURE( state = OPSTATE_ERROR );
        goto CLEANUP;
      }

    if ( ! pdf_scancontent( pdfc , & flptr , & nextobj )) {
      setup_error_name( ( uint8* )"pdfscan" ) ;
      FAILURE( state = OPSTATE_ERROR ) ;
      goto CLEANUP ;
    }

    if ( oType( nextobj ) == OOPERATOR ) {
      int32 op = oInteger( nextobj ) ;
      PDFOP *lpdfop = & pdfops[ op ] ;
      Bool skip_op = FALSE ;

      HQTRACE( trace_pdf_ops , ("op: %s" , lpdfop->name )) ;

      /* Check if valid state for the operator. */
      if ((( state & lpdfop->stdstate ) == 0 &&
           ( ixc->strictpdf || ( ( state & lpdfop->extstate ) == 0 )))) {
        ( void ) error_handler( UNDEFINEDRESULT ) ;
        state = OPSTATE_ERROR ;
        goto CLEANUP ;
      }

      if ( rr_flptr != NULL &&
           ! pdf_rr_pre_op( pdfc , lpdfop , & skip_op , rr_priv )) {
        state = OPSTATE_ERROR ;
        goto CLEANUP ;
      }

      if ( ! skip_op ) {
        Bool flptr_at_eof = ( flptr->filter_state == FILTER_EOF_STATE ) ;
        int32 count = flptr->count ;

        if ( !lpdfop->gc_safe )
          ++gc_safety_level;
        result = (*lpdfop->opcall)( pdfc ); /* Execute the operator */
        gc_safety_level = saved_gc_safety_level;
        dl_safe_recursion = saved_dl_safe_recursion ;

        /* If the stream was at eof, restore it to eof in the rare event that an
           operator should reposition it, which can happen with recursive
           patterns. NB. The restorefiles mechanism will restore the position
           if the stream were at any other valid position. */
        if ( flptr_at_eof ) {
          flptr->filter_state = FILTER_EOF_STATE ;
          flptr->count = count ;
        }
      }
      else {
        /* The PDF spec says there is no such thing as a PDF stack and
           that all args are consumed by each operator. \See
           objstack.h for why the "size" of a stack is nothing of the
           sort. */

        npop( stack->size + 1 , stack ) ;
      }

      if ( rr_flptr != NULL && ! pdf_rr_post_op( pdfc , lpdfop , rr_priv )) {
        FAILURE_GOTO( CLEANUP ) ;
      }

      if ( result ) {
        /* Operator succeeded, it may change state. */
        if ( lpdfop->retstate && state != lpdfop->retstate &&
             /* Only the top-level ET opcall changes the state. */
             ( lpdfop->pdfop != PDFOP_ET || imc->textstate_count == 0 )) {
          state = lpdfop->retstate ;
          if ( rr_flptr != NULL &&
               ! pdf_rr_state_change( pdfc , skip_op ,
                                      1 << highest_bit_set_in_bits[ state ]) ) {
            FAILURE( state = OPSTATE_ERROR ) ;
            goto CLEANUP ;
          }
        }
      }
      else {
        /* Operator failed. */
        if ( lpdfop->name[ 0 ] ) {
          uint8 *errstring = (uint8 *)"%s%s" ;
          uint8 buffer[ 16 ] ;

          swcopyf( buffer , errstring , lpdfop->name , "(PDF)" ) ;
          setup_error_name( buffer ) ;
        }
        else
          setup_error_name( ( uint8* )"pdfscan" ) ;

        FAILURE( state = OPSTATE_ERROR ) ;
        goto CLEANUP ;
      }
    }
    else if ( oType( nextobj ) != ONOTHING ) {
      if ( ! push( & nextobj , stack )) {
        setup_error_name( ( uint8* )"pdfstack" ) ;
        FAILURE( state = OPSTATE_ERROR ) ;
        goto CLEANUP ;
      }
    }
    else {
      /* ONOTHING:
       * We've exhausted the current content stream, so see if there's
       * another one
       */
      pdf_rr_end_exec( pdfc , & rr_flptr , & rr_priv ) ;
      if ( ! pdf_next_content( pdfc , & flptr )) {
        FAILURE( state = OPSTATE_ERROR ) ;
        goto CLEANUP ;
      }
      if ( flptr != NULL ) {
        if ( ! pdf_rr_start_exec( pdfc , & flptr , stream_type ,
                                  & rr_page , & rr_flptr , & rr_priv )) {
          FAILURE( state = OPSTATE_ERROR ) ;
          goto CLEANUP ;
        }
      }
    }

    if ( flptr == NULL ) {
      break ; /* Out of for (;;) */
    }
  }

 CLEANUP:

  /* Clean up unclosed BT/ET pairs. */
  if ( !pdf_cleanup_bt(pdfc, (state != OPSTATE_ERROR)) )
     state = OPSTATE_ERROR ;

  pdf_rr_end_exec( pdfc , & rr_flptr , & rr_priv ) ;

  SET_DEVICE( pres_device ) ;
  --ps_interpreter_level;
  return state ;
}

/* ---------------------------------------------------------------------- */

/** Called by the scanner to map a three character sequence onto a PDF
    operator. Uses a gperf-generated perfect hash so it's nice and
    quick. */

int32 pdf_whichop( int32 ch1 , int32 ch2 , int32 ch3 )
{
  static unsigned char asso_values[] = {
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168,   7, 168, 168, 168, 168, 125,
    168, 168, 168,  75, 168, 168, 168, 168, 168,  32,
    22, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168,  15,  27,  30,  35,
    120, 115,  40,   2,  25,   2, 168,  50,   5, 168,
    22,  35, 125,  40,   0, 125, 168,  75, 168, 110,
    168, 168, 168, 168, 168, 168, 168, 168,  60,  30,
    10,  17,  45,  20,  65, 105,  55, 100, 110,  95,
    0, 168, 100,  90,  50,   5,  25, 168,  85,  80,
    12,  70, 168,   7, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168, 168, 168, 168,
    168, 168, 168, 168, 168, 168, 168
  } ;
  register int key ;

  if ( ch2 == 0 ) {
    key = 1 ;
  }
  else if ( ch3 == 0 ) {
    key = 2 ;
  }
  else {
    key = 3 ;
  }

  switch ( key ) {
    default:
      key += asso_values[( unsigned char )ch2 + 1 ] ;
      /*@fallthrough@*/
    case 1:
      key += asso_values[( unsigned char )ch1 ] ;
      break ;
  }

#define MAX_HASH_VALUE 167

  if ( key <= MAX_HASH_VALUE && key >= 0 ) {
    uint8 *s = pdfops[ key ].name ;

    if ( s[ 0 ] == ch1 && s[ 1 ] == ch2 && s[ 2 ] == ch3 ) {
      return ( int32 )key ;
    }
  }

  return 0 ;
}

/** Global initialisation. Just a sanity check that we get back what
    we would expect from scanning every known PDF operator. */

void init_C_globals_pdfops(void)
{
#if defined( ASSERT_BUILD )
  PDFOP op ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'd', 0 , 0 )]).opcall == pdfop_d   && op.pdfop == PDFOP_d  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'g','s', 0 )]).opcall == pdfop_gs  && op.pdfop == PDFOP_gs , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'i', 0 , 0 )]).opcall == pdfop_i   && op.pdfop == PDFOP_i  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'j', 0 , 0 )]).opcall == pdfop_j   && op.pdfop == PDFOP_j  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'J', 0 , 0 )]).opcall == pdfop_J   && op.pdfop == PDFOP_J  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'M', 0 , 0 )]).opcall == pdfop_M   && op.pdfop == PDFOP_M  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'w', 0 , 0 )]).opcall == pdfop_w   && op.pdfop == PDFOP_w  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'q', 0 , 0 )]).opcall == pdfop_q   && op.pdfop == PDFOP_q  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'Q', 0 , 0 )]).opcall == pdfop_Q   && op.pdfop == PDFOP_Q  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'c','m', 0 )]).opcall == pdfop_cm  && op.pdfop == PDFOP_cm , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'c','q', 0 )]).opcall == pdfop_cq  && op.pdfop == PDFOP_cq , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'c','Q', 0 )]).opcall == pdfop_cQ  && op.pdfop == PDFOP_cQ , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'g', 0 , 0 )]).opcall == pdfop_g   && op.pdfop == PDFOP_g  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'G', 0 , 0 )]).opcall == pdfop_G   && op.pdfop == PDFOP_G  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'k', 0 , 0 )]).opcall == pdfop_k   && op.pdfop == PDFOP_k  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'K', 0 , 0 )]).opcall == pdfop_K   && op.pdfop == PDFOP_K  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'r','g', 0 )]).opcall == pdfop_rg  && op.pdfop == PDFOP_rg , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'R','G', 0 )]).opcall == pdfop_RG  && op.pdfop == PDFOP_RG , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 's','c', 0 )]).opcall == pdfop_sc  && op.pdfop == PDFOP_sc , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'S','C', 0 )]).opcall == pdfop_SC  && op.pdfop == PDFOP_SC , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 's','c','n')]).opcall == pdfop_scn && op.pdfop == PDFOP_scn, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'S','C','N')]).opcall == pdfop_SCN && op.pdfop == PDFOP_SCN, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'c','s', 0 )]).opcall == pdfop_cs  && op.pdfop == PDFOP_cs , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'C','S', 0 )]).opcall == pdfop_CS  && op.pdfop == PDFOP_CS , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'r','i', 0 )]).opcall == pdfop_ri  && op.pdfop == PDFOP_ri , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','c', 0 )]).opcall == pdfop_Tc  && op.pdfop == PDFOP_Tc , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','f', 0 )]).opcall == pdfop_Tf  && op.pdfop == PDFOP_Tf , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','L', 0 )]).opcall == pdfop_TL  && op.pdfop == PDFOP_TL , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','r', 0 )]).opcall == pdfop_Tr  && op.pdfop == PDFOP_Tr , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','s', 0 )]).opcall == pdfop_Ts  && op.pdfop == PDFOP_Ts , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','w', 0 )]).opcall == pdfop_Tw  && op.pdfop == PDFOP_Tw , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','z', 0 )]).opcall == pdfop_Tz  && op.pdfop == PDFOP_Tz , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','j', 0 )]).opcall == pdfop_Tj  && op.pdfop == PDFOP_Tj , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','J', 0 )]).opcall == pdfop_TJ  && op.pdfop == PDFOP_TJ , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop('\'', 0 , 0 )]).opcall == pdfop_T1q && op.pdfop == PDFOP_T1q, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( '"', 0 , 0 )]).opcall == pdfop_T2q && op.pdfop == PDFOP_T2q, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','d', 0 )]).opcall == pdfop_Td  && op.pdfop == PDFOP_Td , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','D', 0 )]).opcall == pdfop_TD  && op.pdfop == PDFOP_TD , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','m', 0 )]).opcall == pdfop_Tm  && op.pdfop == PDFOP_Tm , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'T','*', 0 )]).opcall == pdfop_T1s && op.pdfop == PDFOP_T1s, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'c', 0 , 0 )]).opcall == pdfop_c   && op.pdfop == PDFOP_c  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'l', 0 , 0 )]).opcall == pdfop_l   && op.pdfop == PDFOP_l  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'h', 0 , 0 )]).opcall == pdfop_h   && op.pdfop == PDFOP_h  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'm', 0 , 0 )]).opcall == pdfop_m   && op.pdfop == PDFOP_m  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'r','e', 0 )]).opcall == pdfop_re  && op.pdfop == PDFOP_re , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'v', 0 , 0 )]).opcall == pdfop_v   && op.pdfop == PDFOP_v  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'y', 0 , 0 )]).opcall == pdfop_y   && op.pdfop == PDFOP_y  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'f', 0 , 0 )]).opcall == pdfop_f   && op.pdfop == PDFOP_f  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'F', 0 , 0 )]).opcall == pdfop_f   && op.pdfop == PDFOP_f  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'f','*', 0 )]).opcall == pdfop_f1s && op.pdfop == PDFOP_f1s, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'n', 0 , 0 )]).opcall == pdfop_n   && op.pdfop == PDFOP_n  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 's', 0 , 0 )]).opcall == pdfop_s   && op.pdfop == PDFOP_s  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'S', 0 , 0 )]).opcall == pdfop_S   && op.pdfop == PDFOP_S  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'b', 0 , 0 )]).opcall == pdfop_b   && op.pdfop == PDFOP_b  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'b','*', 0 )]).opcall == pdfop_b1s && op.pdfop == PDFOP_b1s, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B', 0 , 0 )]).opcall == pdfop_B   && op.pdfop == PDFOP_B  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','*', 0 )]).opcall == pdfop_B1s && op.pdfop == PDFOP_B1s, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'W', 0 , 0 )]).opcall == pdfop_W   && op.pdfop == PDFOP_W  , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'W','*', 0 )]).opcall == pdfop_W1s && op.pdfop == PDFOP_W1s, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'M','P', 0 )]).opcall == pdfop_MP  && op.pdfop == PDFOP_MP , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'D','P', 0 )]).opcall == pdfop_DP  && op.pdfop == PDFOP_DP , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'd','0', 0 )]).opcall == pdfop_d0  && op.pdfop == PDFOP_d0 , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'd','1', 0 )]).opcall == pdfop_d1  && op.pdfop == PDFOP_d1 , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'I','D', 0 )]).opcall == pdfop_ID  && op.pdfop == PDFOP_ID , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'D','o', 0 )]).opcall == pdfop_Do  && op.pdfop == PDFOP_Do , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'P','S', 0 )]).opcall == pdfop_PS  && op.pdfop == PDFOP_PS , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','T', 0 )]).opcall == pdfop_BT  && op.pdfop == PDFOP_BT , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'E','T', 0 )]).opcall == pdfop_ET  && op.pdfop == PDFOP_ET , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','I', 0 )]).opcall == pdfop_BIV && op.pdfop == PDFOP_BIV, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'E','I', 0 )]).opcall == pdfop_EIV && op.pdfop == PDFOP_EIV, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','X', 0 )]).opcall == pdfop_BX  && op.pdfop == PDFOP_BX , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'E','X', 0 )]).opcall == pdfop_EX  && op.pdfop == PDFOP_EX , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 's','h', 0 )]).opcall == pdfop_sh  && op.pdfop == PDFOP_sh , "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','M','C')]).opcall == pdfop_BMC && op.pdfop == PDFOP_BMC, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'B','D','C')]).opcall == pdfop_BDC && op.pdfop == PDFOP_BDC, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'E','M','C')]).opcall == pdfop_EMC && op.pdfop == PDFOP_EMC, "Op hashing fail" ) ;
  HQASSERT( (op = pdfops[ pdf_whichop( 'd','u','h')]).opcall == pdfop_Unknown && op.pdfop == PDFOP_NONE , "Op hashing fail" ) ;
#endif
}

/* end of file pdfops.c */

/* Log stripped */
