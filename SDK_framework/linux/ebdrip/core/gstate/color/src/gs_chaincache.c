/** \file
 * \ingroup color
 *
 * $HopeName: COREgstate!color:src:gs_chaincache.c(EBDSDK_P.1) $
 *
 * Copyright (C) 2013-2014 Global Graphics Software Ltd. All rights reserved.
 * Global Graphics Software Ltd. Confidential Information.
 *
 * \brief
 * Color chain cache - stores and retrieves color chains
 *
 * ChainCache bits.
 *
 * Color chains are constructed as needed, often in response to a setcolorspace,
 * using the attributes currently set in the graphics state and various userparams
 * and systemparams. A color chain consists of a) chain head, which contains the
 * colorspace, color values, and other pertinent info, and b) a linked list of
 * color links (CLINKs), each of which performs one transform in the process of
 * converting the color values to the output device code's.
 *
 * A color chain will remain in the graphics state until one of the relevant
 * attributes changes - at which point the chain will get invalidated, which means
 * that only the chain head will remain. The rest of the chain will await being
 * rebuilt using the new attributes, which usually happens lazily when the first
 * color value requires processing.
 *
 * For the sake of performance, a ChainCache preserves invalidated chains within
 * the graphics state in many cases, which makes them available for quick
 * restoration should the current graphics state revert to the same state. All
 * graphics states refer to one ChainCache (per colorType), and many graphics
 * states may refer to the same ChainCache. In this way chains may be reused
 * in more than one graphics state.
 *
 * It is also true that there are many attributes that the ChainCache doesn't
 * cope with, some we may want to deal with, and some we are unlikely to want to
 * because they change infrequently, e.g. setreproduction will typically
 * only change at job start. Such attribute changes force the ChainCache to be
 * flushed from the current graphics state, but preserved in graphics states
 * unaffected by the new attribute value. A new ChainCache will be created,
 * initially for just the one graphics state, but this number will grow as gsave
 * and gstate operators get called.
 *
 * There is one ChainCache per colorType because changes in different attributes
 * will require the chains to be invalidated for just one colorType, or all of
 * them. Keeping the ChainCache's keyed on colorType gives us the best performance.
 *
 * The list of attributes that can currently be coped with inclues:
 *
 * - the colorspace, but limited to DeviceCMYK, DeviceRGB, DeviceGray, Separation,
 *   DeviceN, Indexed, ICCBased and equivalent in PDF & XPS.
 *   If PS VM, or other external memory is referenced by the cache, i.e. for
 *   Indexed spaces, or if tint transforms aren't simple transforms, then the
 *   cache entries concerned will be flushed on restore. This should match the
 *   lifetime of candidate colour spaces.
 * - Separation and DeviceN colorspaces are treated specially. They are cached,
 *   along with the tint transform for use in the current save level.
 *   They may also be cached across save levels in restricted conditions.
 *   If, a) colorants can be directly rendered using the current raster style,
 *   or b) we have processed the job using backdrop rendering and therefore the
 *   color space contains a simple transform, or c) Separation Black color
 *   spaces in recombined jobs. The reason for not caching chains using
 *   tint transforms is that PostScript applications are in the habit of modifying
 *   such colorspace objects while they are in use, so the chain cache would not
 *   know whether it contained the original or the modified colorspace. The reason
 *   for allowing tint transforms with backdrop rendering is that the tint
 *   transforms will have been generated by the rip which we can guarantee is
 *   unmodified. NB. If current raster style is a transparency backdrop, then all
 *   colorants can usually be directly rendered for this stage in the processing.
 * - ICCBased colorspaces are treated specially if they originate from PDF or XPS
 *   for which the ICC profile has job specific identifier which may used to
 *   cache ICCBased chains for the lifetime of the PDF/XPS context.
 * - renderingIntent.
 * - reproType, aka. reproduction type, one of Picture, Text, Vignette, Other.
 *   This can change very frequently, especially whilst backdrop rendering.
 * - colorModel, which is derived from the colorspace but simpler to model as
 *   an independent attribute.
 * - blackType, for black preservation. In front end chains, we evaluate whether
 *   a color will affect preservation but use one chain for all blackType's. In
 *   back end chains we have unique chains for each blackType.
 * - overprint, from setoverprint.
 * - opMode, aka. overprintmode.
 * - opBlack, aka. overprintblack.
 * - prevIndependentChannels, for indicating that the previous color chain in a
 *   transparency group stack had any mixing of colorants. This is only used on
 *   the final output groups to help decide if the virtual device can be bypassed.
 * - interceptId, from setinterceptcolorspace. This is actually a set of various
 *   intercepts, but are taken as a whole and the set is assumed to have changed
 *   if any one changes. There are 2 special cases, a) the default case with all
 *   intercepts at default values and intercept overrides turned off, which is
 *   useful for soft masks where we force color management off, and b) a similar
 *   case but with overrides turned on, which is useful for XPS.
 * - rasterstyle. When a new rastersyle is produced as a result of setpagedevice
 *   this forces the ChainCache to be flushed. But new rasterstyle's can be
 *   created for backdrop groups and if these are verified as the same then
 *   the cached color chains are reused.
 * - opaqueNonStroke and opaqueStroke. This is required because the halftone will
 *   be set to the page default in PDF when compositing.
 * - fSoftMaskLuminosityChain. The chain will be constructed differently because
 *   we only want the luminosity value for soft masks generated from a colored
 *   image.
 * - chainStyle. Determines whether transfers and calibration are required. The
 *   presence of these things will vary for backdrop rendering and trapping.
 * - fCompositing. This is true if the colors have been involved in compositing
 *   which is false when converting into the first blend space, and true for all
 *   other color conversions.
 * - fPresepColorIsGray. When recombining a composite page, this is true when
 *   processing a gray color whether it's from a DeviceCMYK, DeviceRGB, DeviceGray,
 *   or Separation colorspace. This can change frequently when recombining.
 *
 */

#include "core.h"
#include "gs_chaincachepriv.h"
#include "gs_colorpriv.h"       /* frontEndColorState */
#include "gu_chan.h"            /* guc_rasterstyleId */
#include "swerrors.h"           /* error_handler */
#include "metrics.h"            /* sw_metrics_group */
#include "monitor.h"            /* monitorf */
#include "dlstate.h"            /* DL_STATE */
#include "gsccmmpriv.h"         /* TRANSFORM_LINK_INFO */
#include "gscdevcn.h"           /* cc_interceptdevicenCachable */
#include "gscheadpriv.h"        /* GS_CHAINinfo */
#include "gscicc.h"             /* cc_iccSaveLevel */
#include "gsctintpriv.h"        /* cc_tintSimpleTransform */
#include "lowmem.h"
#include "mps.h"


/* --------------------------------------------------------------------------- */

/* The maximum number of colorants in a DeviceN colour space that we'll bother
 * attempting to cache. Larger numbers won't be cached but will be otherwise
 * processed correctly. Not that we're ever likely to encounter them.
 */
#define MAX_CHAIN_CACHE_SEPS (512)

#if defined(DEBUG_BUILD)
int32 debug_chainCache = 0;
#endif

/* The main ChainCache structure that resides in the graphics state.
 * It reference counts the number of gstates that refer to it and is destroyed
 * when 'refCnt' becomes zero.
 * It contains a 'list' of GS_CHAIN_CACHE_LIST each of which holds just one chain.
 * A 'chainCnt' holds the number of chains in the 'list'. This is useful for
 * integrity verification and for low memory purging of the ChainCache.
 * The GS_CHAIN_CACHE structures are all placed in a linked list 'next' which is
 * also used for integrity verification and low memory purging of the ChainCache.
 */
struct GS_CHAIN_CACHE {
  cc_counter_t          refCnt;
  int32                 chainCnt;
  GS_CHAIN_CACHE_LIST   *list;
  Bool                  trimmed;
  GS_CHAIN_CACHE        *next;
  GS_CHAIN_CACHE_STATE  *state;
};

/* The set of info that the ChainCache can cope with when an attribute changes.
 * The individual attributes are described above.
 */
struct GS_CHAIN_CACHE_INFO {
  uint8                 renderingIntent;
  uint8                 reproType;
  REPRO_COLOR_MODEL     colorModel;
  TRANSFORM_LINK_INFO   associatedProfile;
  Bool                  overprint;
  Bool                  opMode;
  Bool                  opBlack;
  uint32                interceptId;
  Bool                  opaqueNonStroke;
  Bool                  opaqueStroke;
  uint32                rasterStyleId;
  OBJECT                internalisedColorSpace;
  OBJECT                internalisedCSA[MAX_CSA_LENGTH];
  int32                 nDeviceNColorants;
  COLORANTINDEX         *colorantArray;
  GSC_SIMPLE_TRANSFORM  *simpleTransform;
  int32                 saveLevel;
  Bool                  forThisSaveLevelOnly;
};

/* The ChainCache structure that holds all the required info about one chain.
 * It refers to the 'chain' itself, and to a collection of 'info' that is
 * accumulated from around the graphics state.
 * These structures are placed in a list that forms the set of chains
 * available for reuse by one graphics state.
 */
struct GS_CHAIN_CACHE_LIST {
  GS_CHAINinfo          *chain;
  GS_CHAIN_CACHE_INFO   info;
  GS_CHAIN_CACHE_LIST   *next;
};


/* Top level state for the chain cache. */
struct GS_CHAIN_CACHE_STATE {
  /* Maintain some counts of the total number of chains in the ChainCache. This is
   * for low memory purging and also for passing to the job metrics module.
   */
  uint32 nCachedChains;
  uint32 nMaxCachedChains;

  /* The pointers to a list of populated ChainCache structs in use throughout the
   * rip. Newly added ChainCaches will get placed at the tail which gives the low
   * memory handler a chance to purge out chains from the head of the ChainCache
   * first. OTOH. This ordering doesn't matter too much because we don't purge
   * chains out of the cache if they are still being referenced by something else,
   * probably a colorInfo within a gstate.
   * ChainCaches only go onto this list if they contain at least one chain, with
   * empty ChainCaches isolated within their colorInfo. As a corollary, there is
   * movement into and out of the list as chains are created and destroyed.
   */
  GS_CHAIN_CACHE *gChainCacheHead;
  GS_CHAIN_CACHE *gChainCacheTail;

  /* The count of the number of ChainCache structs. Used for debug only.
   */
  uint32 nChainCaches;
  uint32 nEmptyChainCaches;
};

#define INCREMENT_CACHED_CHAINS \
MACRO_START \
  chainCacheState->nCachedChains++; \
  if (chainCacheState->nCachedChains > chainCacheState->nMaxCachedChains) \
    chainCacheState->nMaxCachedChains = chainCacheState->nCachedChains; \
MACRO_END

#define DECREMENT_CACHED_CHAINS  (chainCacheState->nCachedChains--)


static Bool cc_createChainCache(GS_COLORinfo *colorInfo, int32 colorType);
static Bool cc_validColorSpace(GS_COLORinfo          *colorInfo,
                               GS_CHAINinfo          *colorChain,
                               int32                 colorType,
                               Bool                  potentiallyUnsafe,
                               int32                 *nDeviceNColorants,
                               COLORANTINDEX         *colorantIndexArray,
                               GSC_SIMPLE_TRANSFORM  **simpleTransform,
                               Bool                  *forThisSaveLevelOnly);
static void cc_validAssociatedProfile(TRANSFORM_LINK_INFO *associatedProfile,
                                      Bool                *forThisSaveLevelOnly);
static void destroyCacheEntry(GS_CHAIN_CACHE      *chainCache,
                              GS_CHAIN_CACHE_LIST *cacheListEntry);
static void cc_destroyChainCacheList(GS_CHAIN_CACHE *chainCache);

/* ---------------------------------------------------------------------- */

Bool cc_startChainCache(GS_CHAIN_CACHE_STATE **stateRef)
{
  GS_CHAIN_CACHE_STATE *state, init = {0};

  HQASSERT(*stateRef == NULL, "Chain cache state already exists");

  state = mm_alloc(mm_pool_color, sizeof(GS_CHAIN_CACHE_STATE),
                   MM_ALLOC_CLASS_NCOLOR);
  if ( state == NULL )
    return error_handler(VMERROR);

  *state = init;
  *stateRef = state;
  return TRUE;
}


void cc_stopChainCache(GS_CHAIN_CACHE_STATE **stateRef)
{
  if ( *stateRef != NULL ) {
    mm_free(mm_pool_color, *stateRef, sizeof(GS_CHAIN_CACHE_STATE));
    *stateRef = NULL;
  }
}


static Bool cc_createChainCache(GS_COLORinfo *colorInfo, int32 colorType)
{
  GS_CHAIN_CACHE_STATE *chainCacheState = colorInfo->colorState->chainCacheState;

  HQASSERT(colorInfo != NULL, "colorInfo NULL");
  COLORTYPE_ASSERT(colorType, "cc_createChainCache") ;
  HQASSERT(colorInfo->chainCache[colorType] == NULL, "chainCache non-NULL");

  colorInfo->chainCache[colorType] = mm_sac_alloc(mm_pool_color,
                                                  sizeof (GS_CHAIN_CACHE),
                                                  MM_ALLOC_CLASS_NCOLOR);
  if (colorInfo->chainCache[colorType] == NULL)
    return error_handler(VMERROR);

  colorInfo->chainCache[colorType]->refCnt = 1;
  colorInfo->chainCache[colorType]->chainCnt = 0;
  colorInfo->chainCache[colorType]->list = NULL;
  colorInfo->chainCache[colorType]->trimmed = FALSE;
  colorInfo->chainCache[colorType]->next = NULL;
  colorInfo->chainCache[colorType]->state = chainCacheState;

  chainCacheState->nEmptyChainCaches++;

  return TRUE;
}

void freeChainCache(GS_CHAIN_CACHE *chainCache)
{
  GS_CHAIN_CACHE_STATE *chainCacheState = chainCache->state;

#ifdef ASSERT_BUILD
  uint32 nChainCaches = chainCacheState->nChainCaches;
#endif

#ifdef ASSERT_BUILD
  /* Validate the chainCache structures, but limit it to avoid exessive processing */
  if ((nChainCaches <= 10000 || nChainCaches % 10000 == 0) &&
      (nChainCaches <= 1000  || nChainCaches % 1000  == 0) &&
      (nChainCaches <= 100   || nChainCaches % 100   == 0) &&
      (nChainCaches <= 10    || nChainCaches % 10    == 0)) {
    uint32 totalCaches = 0;
    uint32 totalChains = 0;
    GS_CHAIN_CACHE *chainCacheEntry = chainCacheState->gChainCacheHead;
    GS_CHAIN_CACHE *chainCacheTail = chainCacheEntry;
    while (chainCacheEntry != NULL) {
      HQASSERT(chainCacheEntry == chainCache || chainCacheEntry->refCnt > 0, "Zero refCnt");
      HQASSERT(chainCacheEntry->chainCnt > 0, "Zero chainCnt in ChainCache");
      totalCaches++;
      totalChains += chainCacheEntry->chainCnt;
      chainCacheTail = chainCacheEntry;
      chainCacheEntry = chainCacheEntry->next;
    }
    HQASSERT(chainCacheTail == chainCacheState->gChainCacheTail,
             "Inconsistent chain cache tail");
    HQASSERT(totalCaches == chainCacheState->nChainCaches,
             "Inconsistent number of chain caches");
    HQASSERT(totalChains == chainCacheState->nCachedChains,
             "Inconsistent number of cached chains");
  }
#endif

  cc_destroyChainCacheList(chainCache);

  HQASSERT(chainCache->chainCnt == 0, "Non-zero cache count");

  mm_sac_free(mm_pool_color, chainCache, sizeof (GS_CHAIN_CACHE)) ;

  chainCacheState->nEmptyChainCaches--;
}

void cc_destroyChainCache(GS_COLORinfo *colorInfo, int32 colorType)
{
  HQASSERT(colorInfo != NULL, "colorInfo NULL");
  COLORTYPE_ASSERT(colorType, "cc_destroyChainCache") ;

  if ( colorInfo->chainCache[colorType] != NULL )
    CLINK_RELEASE(&colorInfo->chainCache[colorType], freeChainCache);
}

void cc_reserveChainCache(GS_CHAIN_CACHE *chainCache)
{
  if (chainCache != NULL)
    CLINK_RESERVE(chainCache);
}

/** Internalise the colorspace into the cache info for the purpose of making
 * sure that the color chain cache has access to data in the original setcolorspace.
 * This is mainly for benefit of Separation/DeviceN and ICCBased spaces.
 * For Separation/DeviceN, the colorants list is internalised.
 * For ICCBased, we can make use of additional caching of ICC profiles in the ICC
 * cache. So we only need to cache the file object from the CSA for the color
 * chain cache to be useful for the lifetime of the ICC file object.
 * The other composite colour spaces that is cacheable is Indexed, which is also
 * deemed safe.
 */
static Bool internaliseColorSpace(OBJECT *colorChain, GS_CHAIN_CACHE_INFO *info)
{
  int i;
  COLORSPACE_ID colorSpaceId;
  OBJECT *colorantObj;

  /* A mostly shallow copy the new color space into the internalised color space
   * within the info structure. The critical features that are deep copied are
   * the colorants within Separation & DeviceN spaces. That's because these
   * often gets poked by applications so we have to ensure we have the original
   * values in the color chain cache because they are critical to it's operation.
   */
  Copy(&info->internalisedColorSpace, colorChain);
  if (oType(*colorChain) == OARRAY ||
      oType(*colorChain) == OPACKEDARRAY) {
    HQASSERT(theLen(*colorChain) <= MAX_CSA_LENGTH && theLen(*colorChain) > 0,
             "Invalid CSA length");
    oArray(info->internalisedColorSpace) = info->internalisedCSA;

    /* Always internalise the space type and colorant list, but don't copy the
     * alternate space & tint transform if it will be invalidated during a
     * future restore operation in the forThisSaveLevelOnly mode.
     */
    Copy(&info->internalisedCSA[0], &oArray(*colorChain)[0]);
    if (theLen(*colorChain) > 1)
      Copy(&info->internalisedCSA[1], &oArray(*colorChain)[1]);
    if (info->forThisSaveLevelOnly || info->simpleTransform != NULL) {
      for (i = 2; i < theLen(*colorChain); i++)
        Copy(&info->internalisedCSA[i], &oArray(*colorChain)[i]);
    }
    if (!gsc_getcolorspacetype(colorChain, &colorSpaceId))
      HQFAIL("Should've validated this color space prior to now");

    /* If a Separation space has a string object for the colorant, convert it
     * to a name to a) guard against applications that poke new colorants into the
     * same string, and b) protect it against restore when caching chains across
     * save levels.
     */
    colorantObj = &info->internalisedCSA[1];
    if (colorSpaceId == SPACE_Separation &&
        oType(*colorantObj) == OSTRING) {
      NAMECACHE *name = cachename(oString(*colorantObj), theLen(*colorantObj));
      if ( name == NULL )
        return FALSE;
      object_store_namecache(colorantObj, name, LITERAL);
    }
    /* Ditto for DeviceN spaces, except we have to make an allocation for the
     * colorants list.
     */
    else if (colorSpaceId == SPACE_DeviceN &&
             info->simpleTransform == NULL) {
      OBJECT *devNArray;

      HQASSERT(oType(*colorantObj) == OARRAY || oType(*colorantObj) == OPACKEDARRAY,
               "DeviceN colorants not an array");
      devNArray = mm_sac_alloc(mm_pool_color,
                               theLen(*colorantObj) * sizeof(OBJECT),
                               MM_ALLOC_CLASS_NCOLOR);
      if (devNArray == NULL) {
        /* Ensure the colorants list is blatted to avoid confusion when freeing
         * a cache entry.
         */
        Copy(&info->internalisedCSA[1], &onothing);
        return FALSE;
      }
      for (i = 0; i < theLen(*colorantObj); i++) {
        (void) object_slot_notvm(&devNArray[i]);
        Copy(&devNArray[i], &oArray(*colorantObj)[i]);
        if (oType(devNArray[i]) == OSTRING) {
          NAMECACHE *name = cachename(oString(devNArray[i]), theLen(devNArray[i]));
          if ( name == NULL )
            return FALSE;
          object_store_namecache(&devNArray[i], name, LITERAL);
        }
        else
          HQASSERT(oType(*devNArray) == ONAME, "Expected a name");
      }

      oArray(*colorantObj) = devNArray;
    }
    /* For ICCBased spaces internalise the first two elements of a potentially 3
     * element array.  Replace the file object in the 2nd element with a C ptr
     * to the ICC cached info.  Ignore the optional dictionary in the 3rd
     * element which can disappear under the cache's feet when used as a base
     * space in PDF.
     */
    else if (colorSpaceId == SPACE_ICCBased) {
      info->internalisedColorSpace = onull;
      gsc_safeBackendColorSpace(&info->internalisedColorSpace, colorChain,
                                info->internalisedCSA);
    }
  }

  return TRUE;
}

Bool cc_addChainCacheEntry(GS_COLORinfo *colorInfo,
                           int32        colorType,
                           Bool         notIfCacheOwner,
                           Bool         potentiallyUnsafe)
{
  GS_CHAIN_CACHE_STATE *chainCacheState = colorInfo->colorState->chainCacheState;
  GS_CHAIN_CACHE_LIST *cacheListEntry;
  GS_CHAIN_CACHE_INFO tmpInfo;
  COLORANTINDEX tmpColorantArray[MAX_CHAIN_CACHE_SEPS];
  COLORANTINDEX *newColorantArray = NULL;
  GS_CHAINinfo *foundChain;
  GS_CHAINinfo *newChain;
  Bool suitableForCaching;
  GS_CHAIN_CONTEXT *newChainCtxt;
  GS_CHAIN_CONTEXT *foundChainCtxt;

  HQASSERT(colorInfo != NULL, "colorInfo NULL");
  COLORTYPE_ASSERT(colorType, "cc_addChainCacheEntry") ;

  newChain = colorInfo->chainInfo[colorType];
  newChainCtxt = newChain->context;

  /* There's no point creating an entry if the chain doesn't exist yet */
  if (newChainCtxt == NULL || newChainCtxt->pnext == NULL)
    return TRUE;

  /* There is no point caching the chain if we are about to destroy the cache */
  if (notIfCacheOwner && CLINK_OWNER(colorInfo->chainCache[colorType]))
    return TRUE;

  /* Ignore this request if the chainCache is disabled */
  if ((newChainCtxt->cacheFlags & GSC_ENABLE_CHAIN_CACHE) == 0)
    return TRUE;

  /* This is setting potentiallyUnsafe to TRUE. It's important because we don't
   * want the internals to unnecessarily look inside colorspace objects that
   * might have been restored away. It's unnecessary because all the required
   * information exists within the chain links.
   */
  tmpInfo.colorantArray = tmpColorantArray;
  if (!cc_findChainCacheEntry(colorInfo, colorType, potentiallyUnsafe,
                              &foundChain, &tmpInfo, &suitableForCaching))
    return FALSE;
  if (!suitableForCaching)
    return TRUE;

  if (foundChain != NULL) {
    GS_CHAIN_CACHE_LIST *prevCacheEntry;

    foundChainCtxt = foundChain->context;
    HQASSERT(foundChainCtxt->pnext != NULL, "An empty chain in the cache");

    /* This chain already exists in the cache. So move the entry to the front
     * of the list to make an MRU list ready for low memory purging - unless
     * it's already at the front.
     */
    prevCacheEntry = colorInfo->chainCache[colorType]->list;
    if (prevCacheEntry->chain->context->pnext != foundChainCtxt->pnext) {
      while (prevCacheEntry != NULL) {
        if (prevCacheEntry->next->chain->context->pnext == foundChainCtxt->pnext) {
          GS_CHAIN_CACHE_LIST *foundCacheEntry = prevCacheEntry->next;
          prevCacheEntry->next = foundCacheEntry->next;
          foundCacheEntry->next = colorInfo->chainCache[colorType]->list;
          colorInfo->chainCache[colorType]->list = foundCacheEntry;
          break;
        }
        prevCacheEntry = prevCacheEntry->next;
      }
      HQASSERT(prevCacheEntry != NULL, "Didn't find cache entry");
    }

    return TRUE;
  }

  /* Create new list entry and populate it. Along with the colorant array */
  cacheListEntry = mm_sac_alloc(mm_pool_color,
                                sizeof (GS_CHAIN_CACHE_LIST),
                                MM_ALLOC_CLASS_NCOLOR );
  if (cacheListEntry == NULL) {
    return error_handler(VMERROR);
  }
  if (tmpInfo.nDeviceNColorants > 0) {
    newColorantArray =
                mm_sac_alloc(mm_pool_color,
                             tmpInfo.nDeviceNColorants * sizeof (COLORANTINDEX),
                             MM_ALLOC_CLASS_NCOLOR );
    if (newColorantArray == NULL) {
      mm_sac_free(mm_pool_color, cacheListEntry, sizeof (GS_CHAIN_CACHE_LIST));
      return error_handler(VMERROR);
    }
  }

  cacheListEntry->chain = newChain;
  CLINK_RESERVE(cacheListEntry->chain);

  cacheListEntry->info = tmpInfo;     /* struct copy */
  cacheListEntry->info.colorantArray = newColorantArray;

  /* Internalise the color space by copying details into the cache entry */
  if (!internaliseColorSpace(&newChain->colorspace, &cacheListEntry->info))
    return FALSE;
  if (oType(newChain->colorspace) == OARRAY ||
      oType(newChain->colorspace) == OPACKEDARRAY) {
    int i;
    oArray(cacheListEntry->info.internalisedColorSpace) =
      cacheListEntry->info.internalisedCSA;
    for (i = 0; i < tmpInfo.nDeviceNColorants; i++)
      cacheListEntry->info.colorantArray[i] = tmpInfo.colorantArray[i];
  }

  /* Add new entry to the front of the list */
  cacheListEntry->next = colorInfo->chainCache[colorType]->list;
  colorInfo->chainCache[colorType]->list = cacheListEntry;
  colorInfo->chainCache[colorType]->chainCnt++;

  if (colorInfo->chainCache[colorType]->chainCnt == 1) {
    /* If the current chainCache was empty, then now it's not. So we're going to
     * add it to the tail of the global list of chainCache's so that it can can be
     * found in low memory handling but also marked as the MRU.
     */
    HQASSERT(colorInfo->chainCache[colorType]->next == NULL,
             "ChainCache shouldn't be in a list");
    HQASSERT(chainCacheState->gChainCacheTail == NULL ||
             chainCacheState->gChainCacheTail->next == NULL,
             "ChainCacheTail isn't at the end of the list");
    if (chainCacheState->gChainCacheTail == NULL) {
      HQASSERT(chainCacheState->gChainCacheHead == NULL,
               "chainCacheState->gChainCacheHead non-NULL");
      chainCacheState->gChainCacheHead = colorInfo->chainCache[colorType];
      chainCacheState->gChainCacheTail = colorInfo->chainCache[colorType];
    }
    else {
      HQASSERT(chainCacheState->gChainCacheHead != NULL,
               "chainCacheState->gChainCacheHead NULL");
      chainCacheState->gChainCacheTail->next = colorInfo->chainCache[colorType];
      chainCacheState->gChainCacheTail = chainCacheState->gChainCacheTail->next;
    }

    chainCacheState->nEmptyChainCaches--;
    chainCacheState->nChainCaches++;
  }
#define MAX_CHAINS_PER_CACHE    (40)
  else if (colorInfo->chainCache[colorType]->chainCnt > MAX_CHAINS_PER_CACHE) {
    /* The color chain cache has exceeded a healthy size. Get rid of the LRU entry.
     */
    GS_CHAIN_CACHE_LIST *penultimateEntry = colorInfo->chainCache[colorType]->list;
    GS_CHAIN_CACHE_LIST *lastEntry;

    colorInfo->chainCache[colorType]->trimmed = TRUE;

    HQASSERT(penultimateEntry != NULL && penultimateEntry->next != NULL,
             "Color chain cache should have 2 chains");
    while (penultimateEntry->next->next != NULL)
      penultimateEntry = penultimateEntry->next;

    lastEntry = penultimateEntry->next;
    penultimateEntry->next = NULL;

    destroyCacheEntry(colorInfo->chainCache[colorType], lastEntry);
  }

  INCREMENT_CACHED_CHAINS;

  return TRUE;
}

static void fillInCacheDetails(GS_COLORinfo        *colorInfo,
                               int32               colorType,
                               GS_CHAINinfo        *colorChain,
                               Bool                forThisSaveLevelOnly,
                               GS_CHAIN_CACHE_INFO *info)
{
  int i;

  /* Accumulate the set of gstate info that we want to match */
  info->renderingIntent = cc_getrenderingintent(colorInfo);
  info->reproType = gsc_getRequiredReproType(colorInfo, colorType);
  info->colorModel = gsc_getColorModel(colorInfo, colorType);
  info->associatedProfile = cc_getAssociatedProfile(colorInfo, info->colorModel);
  info->overprint = gsc_getoverprint(colorInfo, colorType);
  info->opMode = gsc_getoverprintmode(colorInfo);
  info->opBlack = gsc_getoverprintblack(colorInfo);
  info->interceptId = cc_getInterceptId(colorInfo->hcmsInfo);
  info->rasterStyleId = guc_rasterstyleId(gsc_getTargetRS(colorInfo));
  info->opaqueNonStroke = cc_getOpaque(colorInfo, TsNonStroke);
  info->opaqueStroke = cc_getOpaque(colorInfo, TsStroke);

  /* Initialise the internalised object and CSA */
  info->internalisedColorSpace = onothing;  /* Struct copy to set slot properties */
  for (i = 0; i < MAX_CSA_LENGTH; i++)
    info->internalisedCSA[i] = onothing;    /* Struct copy to set slot properties */


  /* If we can reuse chains in any save level we should, otherwise restore away
   * when restore below the current save level.
   * The value of 0 means we can reuse chains in any save level */
  if (!forThisSaveLevelOnly)
    cc_validAssociatedProfile(&info->associatedProfile, &forThisSaveLevelOnly);
  info->saveLevel = get_core_context()->savelevel;
  info->forThisSaveLevelOnly = forThisSaveLevelOnly;


  /* Hacks to treat chains with ICC color spaces specially. Since ICC profiles
   * have their own cache and are purged independently of color spaces, we can
   * cache chains down to the associated save level.
   * We need to consider both color spaces and associated profiles. Profiles
   * used elsewhere in a color chain causes the chain cache to be reset.
   */
  if (colorChain->iColorSpace == SPACE_ICCBased) {
    ICC_PROFILE_INFO *iccInfo;
    int32 dummyDims;
    COLORSPACE_ID dummySpace;
    OBJECT *fileObj;

    HQASSERT((oType(colorChain->colorspace) == OARRAY ||
              oType(colorChain->colorspace) == OPACKEDARRAY) &&
             theLen(colorChain->colorspace) >= 2,
             "Inconsistent ICCBased colorspace");

    if (!cc_get_iccbased_profile_info(colorInfo, &colorChain->colorspace,
                                      &iccInfo, &dummyDims, &dummySpace, &dummySpace))
      HQFAIL("ICC profile should already be in the ICC cache");
    info->saveLevel = cc_iccSaveLevel(iccInfo);

    fileObj = &oArray(colorChain->colorspace)[1];
    if (oFile(*fileObj)->sid > info->saveLevel)
      info->saveLevel = oFile(*fileObj)->sid;
    HQASSERT(info->forThisSaveLevelOnly, "Unexpected ICC cache entry");
  }
  if (info->associatedProfile.inputColorSpaceId == SPACE_ICCBased) {
    /* While associated profiles usually aren't used if the color space is ICC,
     * they might be if the ICC profile contains named colors. It's not worth
     * the risk of optimising this, so just take the highest level.
     */
    int32 possSavelevel = cc_iccSaveLevel(info->associatedProfile.u.icc);
    if (possSavelevel > info->saveLevel) {
      info->saveLevel = possSavelevel;
      info->forThisSaveLevelOnly = TRUE;
    }
  }
}

static void assertValidColorSpace(GS_COLORinfo  *colorInfo,
                                  OBJECT        *colorSpace,
                                  Bool          assertBaseSpace)
{
  UNUSED_PARAM(GS_COLORinfo *, colorInfo);
  UNUSED_PARAM(OBJECT *, colorSpace);
  UNUSED_PARAM(Bool, assertBaseSpace);

#ifdef ASSERT_BUILD
  /* Assert the color space. NB. null objects are routinely used for device spaces */
  if (oType(*colorSpace) != ONULL) {
    COLORSPACE_ID colorSpaceId;
    int32 dummyN;

    HQASSERT(gsc_getcolorspacesizeandtype(colorInfo, colorSpace,
                                          &colorSpaceId, &dummyN),
             "An invalid color space used in the chain cache");

    if (assertBaseSpace) {
      int csLength = theLen(*colorSpace);

      /* Also assert the base/alternate space if present */
      switch (colorSpaceId){
      case SPACE_Pattern:
        if (csLength == 2)
          assertValidColorSpace(colorInfo, &oArray(*colorSpace)[1], FALSE);
        break;
      case SPACE_Indexed:
          assertValidColorSpace(colorInfo, &oArray(*colorSpace)[1], FALSE);
        break;
      case SPACE_Separation:
      case SPACE_DeviceN:
        assertValidColorSpace(colorInfo, &oArray(*colorSpace)[2], FALSE);
        break;
      }
    }
  }
#endif
}

/* Compares the colorant list for two DeviceN spaces as used when the colorants
 * are all renderable, i.e. when forThisSaveLevelOnly == FALSE and the
 * simpleTransform == NULL. A match of the colorants is then sufficient to match
 * the color spaces, with the alternate space & tint transform disregarded.
 * Returns TRUE if the colorant lists match, FALSE otherwise.
 */
static Bool matchDeviceNColorants(GS_CHAIN_CACHE_INFO  *info,
                                  GS_CHAINinfo         *srcChain,
                                  GS_CHAIN_CACHE_INFO  *listInfo,
                                  GS_CHAINinfo         *listChain)
{
  Bool sameColorSpace = FALSE;

  HQASSERT(!listInfo->forThisSaveLevelOnly, "forThisSaveLevelOnly should be FALSE");
  HQASSERT(listInfo->simpleTransform == NULL, "simpleTransform should be NULL");

  if (info->nDeviceNColorants == listInfo->nDeviceNColorants &&
      info->simpleTransform == NULL) {
    HQASSERT(info->nDeviceNColorants == srcChain->n_iColorants &&
             listInfo->nDeviceNColorants == listChain->n_iColorants,
             "Inconsistent nDeviceNColorants");

    if (listChain->iColorSpace == srcChain->iColorSpace &&
        listChain->n_iColorants == srcChain->n_iColorants) {
      int32 i;

      sameColorSpace = TRUE;
      for (i = 0; i < listChain->n_iColorants; i++) {
#ifdef ASSERT_BUILD
        GS_CHAIN_CONTEXT *listChainCtxt = listChain->context;
#endif
        HQASSERT(listChainCtxt->pnext->linkType == CL_TYPEgraytok ||
                 listChainCtxt->pnext->iColorants[i] == listInfo->colorantArray[i],
                 "Inconsistent colorant for cached Separation/DeviceN chain");
        if (listInfo->colorantArray[i] != info->colorantArray[i])
          sameColorSpace = FALSE;
      }
    }
  }

  return sameColorSpace;
}

/* Returns the cached 'chain' matching the matching the current colorspace and
 * other data accessible from colorInfo.
 * - optionally, the 'chainCacheInfo' is also filled in with the current data if
 * it's non-NULL. If it's NULL, the data is only used internally.
 * - one complication is the list of colorant indices in the colorspace. When
 * stored in the ChainCache the list will be contained in an array of the correct
 * size, but here it's awkward so we'll contain it in a large, but fixed size
 * array which is pointed at from the 'chainCacheInfo'.
 * - 'suitableForCaching' is returned as TRUE for colorspaces that are suitable
 * for the ChainCache, FALSE for others, such as CIEBasedABC that are considered
 * too difficult to compare.
 * - 'potentiallyUnsafe' is set to TRUE by clients that cannot guarantee the
 * veracity of a colorspace object due to jobs poking other colorants and reusing
 * them after setcolorspace.
 */
Bool cc_findChainCacheEntry(GS_COLORinfo        *colorInfo,
                            int32               colorType,
                            Bool                potentiallyUnsafe,
                            GS_CHAINinfo        **chain,
                            GS_CHAIN_CACHE_INFO *chainCacheInfo,
                            Bool                *suitableForCaching)
{
  GS_CHAIN_CACHE_LIST *cacheListEntry;
  GS_CHAINinfo *srcChain;
  GS_CHAIN_CACHE_INFO localInfo;
  GS_CHAIN_CACHE_INFO *info;
  COLORANTINDEX localColorantArray[MAX_CHAIN_CACHE_SEPS];
  Bool forThisSaveLevelOnly;

  HQASSERT(colorInfo != NULL, "colorInfo NULL");
  COLORTYPE_ASSERT(colorType, "cc_findChainCacheEntry") ;

  *chain = NULL;
  *suitableForCaching = FALSE;

  /* Ignore this request if called from a nested context */
  if (colorInfo->constructionDepth[colorType] > 0)
    return TRUE;

  /* There are 2 callers, one to add a chain to the cache, for which we need to
   * fill in the details of the chain in the 'info' passed as a param for
   * insertion into the cache.
   * The other is when looking for a match, for which the caller doesn't care
   * about the cache info.
   */
  if (chainCacheInfo == NULL) {
    info = &localInfo;
    info->colorantArray = localColorantArray;

    /* A hack to bail out if the chain cache isn't enabled when called from
     * gsc_constructChain().
     */
    if (colorInfo->chainCache[colorType] == NULL)
      return TRUE;
  }
  else
    info = chainCacheInfo;

  srcChain = colorInfo->chainInfo[colorType];

  /* Don't bother if the colorspace cannot be compared with cc_sameColorSpaceObject */
  if (!cc_validColorSpace(colorInfo,
                          srcChain,
                          colorType,
                          potentiallyUnsafe,
                          &info->nDeviceNColorants,
                          info->colorantArray,
                          &info->simpleTransform,
                          &forThisSaveLevelOnly))
    return TRUE;

  fillInCacheDetails(colorInfo, colorType, srcChain, forThisSaveLevelOnly, info);

  *suitableForCaching = TRUE;

  /* We've now filled in the chainCacheInfo, so bail-out if the cache is empty */
  if (colorInfo->chainCache[colorType] == NULL)
    return TRUE;

  /* Now search the list of cache entries looking for one that matches */
  cacheListEntry = colorInfo->chainCache[colorType]->list;
  while (cacheListEntry != NULL) {
    GS_CHAINinfo *listChain = cacheListEntry->chain;
    GS_CHAIN_CACHE_INFO *listInfo = &cacheListEntry->info;
    Bool sameColorSpace;
#ifdef ASSERT_BUILD
    GS_CHAIN_CONTEXT *srcChainCtxt = srcChain->context;
    GS_CHAIN_CONTEXT *listChainCtxt = listChain->context;
#endif

    HQASSERT(listChain != NULL, "listChain NULL");
    HQASSERT(listChain->context != NULL, "listChain->context NULL");
    CLINK_RESERVE(listChain);

    if (listInfo->nDeviceNColorants == 0 ||
        listInfo->forThisSaveLevelOnly || listInfo->simpleTransform != NULL) {
      assertValidColorSpace(colorInfo, &listInfo->internalisedColorSpace, TRUE);

      HQASSERT(listInfo->nDeviceNColorants == 0 ||
               listInfo->simpleTransform == cc_csaGetSimpleTransform(&listInfo->internalisedColorSpace),
               "Inconsistent simple transform");
      sameColorSpace = cc_sameColorSpaceObject(colorInfo,
                                               &listInfo->internalisedColorSpace,
                                               listChain->iColorSpace,
                                               &srcChain->colorspace,
                                               srcChain->iColorSpace);
    }
    else {
      assertValidColorSpace(colorInfo, &listInfo->internalisedColorSpace, FALSE);

      sameColorSpace = matchDeviceNColorants(info, srcChain, listInfo, listChain);
    }

    if (sameColorSpace &&
        listInfo->renderingIntent == info->renderingIntent &&
        listInfo->reproType == info->reproType &&
        listInfo->colorModel == info->colorModel &&
        cc_sameColorSpaceFromTransformInfo(&listInfo->associatedProfile,
                                           &info->associatedProfile) &&
        listInfo->overprint == info->overprint &&
        listInfo->opMode == info->opMode &&
        listInfo->opBlack == info->opBlack &&
        listInfo->interceptId == info->interceptId &&
        listInfo->opaqueNonStroke == info->opaqueNonStroke &&
        listInfo->opaqueStroke == info->opaqueStroke &&
        listChain->fSoftMaskLuminosityChain == srcChain->fSoftMaskLuminosityChain &&
        listChain->chainStyle == srcChain->chainStyle &&
        listChain->fCompositing == srcChain->fCompositing &&
        listChain->inBlackType == srcChain->inBlackType &&
        listChain->prevIndependentChannels == srcChain->prevIndependentChannels &&
        listChain->fPresepColorIsGray == srcChain->fPresepColorIsGray &&
        listChain->patternPaintType == srcChain->patternPaintType &&
        listInfo->rasterStyleId == info->rasterStyleId) {

      HQASSERT(listChain->structSize == srcChain->structSize &&
               listChain->n_iColorants == srcChain->n_iColorants &&
               listInfo->simpleTransform == info->simpleTransform,
               "Restoring an inconsistent cached chain");
      HQASSERT(listChainCtxt->pnext != NULL, "An empty chain in the cache");
      /* NB. We can't guarantee reuse of chains for Separation spaces because
       *     of the rules for not peeking into PSVM unless we know it's safe.
       */
      HQASSERT(srcChainCtxt == NULL || srcChainCtxt->pnext == NULL ||
               listChainCtxt->pnext == srcChainCtxt->pnext ||
               srcChain->iColorSpace == SPACE_Separation ||
               srcChain->iColorSpace == SPACE_DeviceN ||
               colorInfo->chainCache[colorType]->trimmed,
               "Cached chain wasn't used");

      *chain = cacheListEntry->chain;
      cc_destroyChain(&listChain); /* not destroying, just releasing */
      break;
    }

    cc_destroyChain(&listChain); /* not destroying, just releasing */
    cacheListEntry = cacheListEntry->next;
  }

  return TRUE;
}

/* Decide whether this colorChain is suitable for caching in the ChainCache.
 * The chain can exist or not, but the rules for validity are different
 * because color space objects can be poked by jobs in some cases so we can't
 * always rely on the color space.
 * In some cases, a chain is only suitable at the current save level.
 * If appropriate, return an array of colorants and a simpleTransform for
 * DeviceN spaces.
 */
static Bool cc_validColorSpace(GS_COLORinfo          *colorInfo,
                               GS_CHAINinfo          *colorChain,
                               int32                 colorType,
                               Bool                  potentiallyUnsafe,
                               int32                 *nDeviceNColorants,
                               COLORANTINDEX         *colorantIndexArray,
                               GSC_SIMPLE_TRANSFORM  **simpleTransform,
                               Bool                  *forThisSaveLevelOnly)
{
  Bool validColorSpace = FALSE;
  CLINK *pLink;
  GUCR_RASTERSTYLE *hRasterStyle;
  OBJECT *excludedSeparations;
  int32 enableColorCache;
  OBJECT *baseSpace;
  Bool deviceN_allowAlternate = TRUE;

  *simpleTransform = NULL;
  *nDeviceNColorants = 0;
  *forThisSaveLevelOnly = FALSE;

  HQASSERT(colorInfo != NULL, "colorInfo NULL");
  HQASSERT(simpleTransform != NULL, "simpleTransform NULL");
  HQASSERT(forThisSaveLevelOnly != NULL, "forThisSaveLevelOnly NULL");

  hRasterStyle = gsc_getTargetRS(colorInfo);
  excludedSeparations = &colorInfo->params.excludedSeparations;
  enableColorCache = colorInfo->params.enableColorCache;

  assertValidColorSpace(colorInfo, &colorChain->colorspace, TRUE);

  switch (colorChain->iColorSpace) {
  case SPACE_DeviceGray:
  case SPACE_DeviceRGB:
  case SPACE_DeviceCMY:
  case SPACE_DeviceCMYK:
    validColorSpace = TRUE;
    break;

  case SPACE_ICCBased:
    validColorSpace = TRUE;
    /* The exact save level could be adjusted in fillInCacheDetails() */
    *forThisSaveLevelOnly = TRUE;
    break;

  case SPACE_Indexed:
    /* If the base space is a CSA, we get stability problems for PDF because
     * that code will change the base space under the chain cache's feet. The
     * chain cache can't compare the Indexed CSA for that case so we're forced
     * to give up. Unfortunately, it means disabling the chain cache from all
     * clients, not just PDF.
     */
    baseSpace = &oArray(colorChain->colorspace)[1];
    if (oType(*baseSpace) != ONAME)
      break;

    /* Although we have never seen a job that pokes into an Indexed CSA after
     * the setcolorspace, the potential exists so only allow their caching when
     * we know it's safe.
     * For GSC_SHFILL chains, there is an associated GSC_SHFILL_INDEXED_BASE
     * chain constructed as part of the GSC_SHFILL construction which can't
     * easily be restored at the same time as the GSC_SHFILL chain. The simplest
     * way of handling this is to disable caching for GSC_SHFILL chains. In this
     * case the large majority of the color conversions are done on the
     * GSC_SHFILL_INDEXED_BASE for which we do allow caching.
     */
    if (!potentiallyUnsafe && colorType != GSC_SHFILL) {
      validColorSpace = TRUE;
      *forThisSaveLevelOnly = TRUE;
    }
    break;

  case SPACE_Separation:
  case SPACE_DeviceN:
    /* If the base space is a CSA, we get stability problems for PDF because
     * that code will change the base space under the chain cache's feet. The
     * chain cache can't compare the parent CSA for that case. That means we can
     * only cache the colorants of these spaces in the colorants only mode
     * described below for caching across save levels, and are forced to give up
     * on reusing color chains requiring alternate spaces. Unfortunately, it
     * means disabling that mode from all clients, not just PDF.
     */
    baseSpace = &oArray(colorChain->colorspace)[2];
    if (oType(*baseSpace) != ONAME)
      deviceN_allowAlternate = FALSE;

    /* We cannot simply cache these in general because postscript jobs are too
     * fond of poking into colorspace arrays, especially from older applications.
     * So we jump through several hoops to make sure that caching these are safe
     * with known applications.
     *
     * Another complication is that the chain cache for these spaces operates in
     * one of 3 modes:
     * - we compare only the colorants when they are renderable in the current
     * raster style. These colour chains can be reused across save levels because
     * we internalise the colorants and don't use the remainder of the colour
     * space.
     * - we compare the whole colour space. This has 2 sub-modes, the alternate
     * space is a simple transforms or not. If it's a simple transform the
     * colour chains can be reused across save levels because can rely on it to
     * not get corrupted. Otherwise they can only be reused within the current
     * save level.
     */

    pLink = NULL;
    *nDeviceNColorants = colorChain->n_iColorants;

    if (colorChain->context != NULL) {
      /* Ignore any black links that may be there before the first significant link. */
      for (pLink = colorChain->context->pnext; pLink != NULL; pLink = pLink->pnext) {
        Bool skipLink = FALSE;

        switch (pLink->linkType) {
        case CL_TYPEblackevaluate:
        case CL_TYPEblackremove:
          skipLink = TRUE;
          break ;
        }
        if (!skipLink)
          break;
      }
    }

    /* pLink will now point to the fist significant link, or NULL */

    *simpleTransform = cc_csaGetSimpleTransform(&colorChain->colorspace);

    /* At this point, we don't yet know for certain that a simpleTransform will
     * be used because intercepttinttransform and interceptdevicen links trump
     * simpleTransforms. Therefore, we have to determine the colorantIndexArray
     * for all calls to this function, just in case.
     */

    if (colorChain->n_iColorants <= MAX_CHAIN_CACHE_SEPS) {
      /* If a Separation/DeviceN colorspace only contains renderable colorants
       * on the raster style then we allow chain reuse. [If they don't have a
       * chain then we are more likely to be here as part of setcolorspace
       * which is ok, but we obviously can't reuse the chain.]
       */
      if (pLink != NULL &&
          (pLink->linkType == CL_TYPEdevicecode ||
           pLink->linkType == CL_TYPEallseptinttransform ||
           pLink->linkType == CL_TYPEtinttransform ||
           pLink->linkType == CL_TYPEinterceptdevicen)) {
        int32  i;

        /* A tint transform link can only be used at the current save level.
         * An interceptdevicen link can only be reused in the current save
         * level if it contains postscript that might be restored away.
         */
        if (pLink->linkType == CL_TYPEtinttransform ||
            (pLink->linkType == CL_TYPEinterceptdevicen &&
             !cc_devicenCachable(pLink))) {
          if ((enableColorCache & GSC_ENABLE_CHAIN_CACHE_PSVM) == 0)
            validColorSpace = (*simpleTransform != NULL);
          else
            validColorSpace = TRUE;
          *forThisSaveLevelOnly = TRUE;
        }
        else
          validColorSpace = TRUE;

        /* Due to the link types in the test, we now know that the colorants are
         * either renderable or else can potentially be used within the current
         * save level if a simple transform is involved, so there's no need to
         * work it out again. Getting the colorants from the next link is reliable.
         */
        for (i = 0; i < colorChain->n_iColorants; i++)
          colorantIndexArray[i] = pLink->iColorants[i];
      }
      else if (pLink != NULL &&
               pLink->linkType == CL_TYPEgraytok) {
        COLORANTINDEX cmyk[4];

        /* We must be recombining a Separation Black because we're dealing with
         * Separations. A graytok link doesn't hold the colorant index directly,
         * so we have to get it from the raster style.
         */
        if (!guc_simpleDeviceColorSpaceMapping(hRasterStyle, DEVICESPACE_CMYK,
                                               cmyk, 4))
          return FALSE;
        HQASSERT(colorChain->n_iColorants == 1, "Expected just 1 colorant");
        colorantIndexArray[0] = cmyk[3];
      }
      else if (!potentiallyUnsafe || (*simpleTransform != NULL)) {
        Bool renderableColorants;
        Bool allowAutoSeparations;
        Bool f_do_nci;

        HQASSERT(pLink == NULL, "Unexpected chain present");

        /* autoseparations are disabled because there is no point in doing extra
         * work - if the separation doesn't exist yet, it won't be in the chain
         * cache. Also, we have to build a chain to set the CMYK equivalent colors
         * in the rasterstyle.
         */
        allowAutoSeparations = FALSE;
        f_do_nci = FALSE;  /* We are only interested in renderable colorants */

        /* We are accessing the colorspace object in the existing color chain,
         * so we can only do this when we are sure that the object is still
         * around, i.e. not potentiallyUnsafe. In particular, we shouldn't be
         * here when called (indirectly) from cc_addChainCacheEntry() because
         * a chain must exist with a specific signature, and that case is
         * handled above.
         */
        if (!cc_colorspaceNamesToIndex(hRasterStyle,
                                       &colorChain->colorspace,
                                       allowAutoSeparations,
                                       f_do_nci,
                                       colorantIndexArray,
                                       colorChain->n_iColorants,
                                       excludedSeparations,
                                       &renderableColorants))
          return FALSE;

        /* Now that we've determined the colorant list, if possible, always assume
         * that simple tint transforms are valid.
         * Don't compare color spaces equal if it's disallowed.
         */
        if ((enableColorCache & GSC_ENABLE_CHAIN_CACHE_PSVM) == 0)
          validColorSpace = renderableColorants || (*simpleTransform != NULL);
        else
          validColorSpace = TRUE;
        *forThisSaveLevelOnly = !renderableColorants;
      }

      /* If caching is only allowed in the current save level, requiring the
       * alternate space. But deviceN_allowAlternate prevents access to the base
       * space, no caching is possible.
       */
      if (!deviceN_allowAlternate && *forThisSaveLevelOnly)
        validColorSpace = FALSE;
    }
    else {
#ifdef DEBUG_COLOR
      HQTRACE(TRUE, ("ChainCache colorant limit blown\n"));
#endif
    }
    break;
  }

  return validColorSpace;
}

/* Decide whether a color chain containing an associated profile is suitable for
 * caching at the current save level or all save levels.
 * NB. Because the rip sets associated profiles, we don't have to worry about
 * objects being poked by jobs, so they are always safe for the current save level.
 */
static void cc_validAssociatedProfile(TRANSFORM_LINK_INFO *associatedProfile,
                                      Bool                *forThisSaveLevelOnly)
{
  switch (associatedProfile->inputColorSpaceId) {
  case SPACE_notset:
  case SPACE_DeviceGray:
  case SPACE_DeviceRGB:
  case SPACE_DeviceCMYK:
  case SPACE_ICCBased:
    forThisSaveLevelOnly = FALSE;
    break;

  default:
    *forThisSaveLevelOnly = TRUE;
    break;
  }
}

static void unLinkChainCache(GS_CHAIN_CACHE *chainCache)
{
  GS_CHAIN_CACHE_STATE *chainCacheState = chainCache->state;

  HQASSERT(chainCache != NULL, "chainCache NULL");
  HQASSERT(chainCache->chainCnt == 0, "Non-zero cache count");

  /* Unlink the chainCache from the list */
  if (chainCacheState->gChainCacheHead == chainCache) {
    chainCacheState->gChainCacheHead = chainCache->next;
    if (chainCacheState->gChainCacheTail == chainCache) {
      HQASSERT(chainCacheState->gChainCacheHead == NULL,
               "chainCacheState->gChainCacheHead non-NULL");
      chainCacheState->gChainCacheTail = NULL;
    }
  }
  else {
    GS_CHAIN_CACHE *prevChainCache = chainCacheState->gChainCacheHead;
    while (prevChainCache != NULL) {
      if (prevChainCache->next == chainCache) {
        prevChainCache->next = chainCache->next;
        break;
      }
      prevChainCache = prevChainCache->next;
    }
    HQASSERT(prevChainCache != NULL, "Didn't find cache entry");

    if (chainCacheState->gChainCacheTail == chainCache)
      chainCacheState->gChainCacheTail = prevChainCache;
  }

  chainCache->next = NULL;
}

static void destroyCacheEntry(GS_CHAIN_CACHE      *chainCache,
                              GS_CHAIN_CACHE_LIST *cacheListEntry)
{
  GS_CHAIN_CACHE_STATE *chainCacheState = chainCache->state;

  HQASSERT(chainCache != NULL, "chainCache NULL");
  HQASSERT(cacheListEntry != NULL, "cacheListEntry NULL");
  HQASSERT(cacheListEntry->chain != NULL, "chain head NULL");
  HQASSERT(cacheListEntry->chain->context->pnext != NULL, "chain NULL");

  if (cacheListEntry->info.colorantArray != NULL) {
    mm_sac_free(mm_pool_color,
                cacheListEntry->info.colorantArray,
                cacheListEntry->info.nDeviceNColorants * sizeof (COLORANTINDEX));
  }
  else
    HQASSERT(cacheListEntry->info.nDeviceNColorants == 0, "nDeviceNColorants != 0");

  /* If we allocated an array for DeviceN colorant lists, free it now. */
  if (oType(cacheListEntry->info.internalisedColorSpace) != ONULL) {
    COLORSPACE_ID csId;

    if (!gsc_getcolorspacetype(&cacheListEntry->info.internalisedColorSpace,
                               &csId))
      HQFAIL("Internalised color space got corrupted");
    if (csId == SPACE_DeviceN &&
        (oType(cacheListEntry->info.internalisedCSA[1]) == OARRAY ||
         oType(cacheListEntry->info.internalisedCSA[1]) == OPACKEDARRAY) &&
        cacheListEntry->info.simpleTransform == NULL) {
      OBJECT *devNArray = &cacheListEntry->info.internalisedCSA[1];
      mm_sac_free(mm_pool_color, oArray(*devNArray), theLen(*devNArray) * sizeof(OBJECT));
    }
  }

  cc_destroyChain(&cacheListEntry->chain);

  mm_sac_free(mm_pool_color, cacheListEntry, sizeof (GS_CHAIN_CACHE_LIST));

  chainCache->chainCnt--;
  DECREMENT_CACHED_CHAINS;

  /* If there was a chain in the ChainCache and now there isn't, then we'll unlink
   * the chain and update the counters.
   */
  if (chainCache->chainCnt == 0) {
    unLinkChainCache(chainCache);
    chainCacheState->nEmptyChainCaches++;
    chainCacheState->nChainCaches--;
  }
}

static void cc_destroyChainCacheList(GS_CHAIN_CACHE *chainCache)
{
  GS_CHAIN_CACHE_LIST *cacheListEntry = chainCache->list;

  /* Destroy the cache list and it's contents */
  while (cacheListEntry != NULL) {
    GS_CHAIN_CACHE_LIST *nextEntry = cacheListEntry->next;
    destroyCacheEntry(chainCache, cacheListEntry);
    cacheListEntry = nextEntry;
  }

  chainCache->list = NULL;
}

Bool cc_invalidateChainCache(GS_COLORinfo *colorInfo, int32 colorType)
{
  cc_destroyChainCache(colorInfo, colorType);

  return cc_createChainCache(colorInfo, colorType);
}

/* Purge the ChainCache of all caches containing PS objects above saveLevel
 * prior to a restore.
 */
void cc_chainCacheRestore(int32 saveLevel)
{
  GS_CHAIN_CACHE *chainCache = frontEndColorState->chainCacheState->gChainCacheHead;

  while (chainCache != NULL) {
    GS_CHAIN_CACHE *nextChainCache = chainCache->next;
    GS_CHAIN_CACHE_LIST *cacheListEntry;
    GS_CHAIN_CACHE_LIST *prevCacheEntry = NULL;

    HQASSERT(chainCache->refCnt > 0, "Non-zero refCnt");

    cacheListEntry = chainCache->list;
    while (cacheListEntry != NULL) {
      GS_CHAIN_CACHE_LIST *nextCacheEntry = cacheListEntry->next;

      if (cacheListEntry->info.saveLevel > saveLevel) {
        /* When we're restoring a save level, always dispose of the transform
         * chains (currentcmykcolor etc.) because these may well contain PSVM
         * even if the main chain doesn't. These chains aren't used that much
         * and it isn't worth the risk of optimally retaining them.
         */
        cc_invalidateTransformChains(cacheListEntry->chain->context);

        if (cacheListEntry->info.forThisSaveLevelOnly) {
          /* Found one, so delete and remove it from the list */
          destroyCacheEntry(chainCache, cacheListEntry);

          if (cacheListEntry == chainCache->list)
            chainCache->list = nextCacheEntry;
          else
            prevCacheEntry->next = nextCacheEntry;
        }
        else {
#ifdef ASSERT_BUILD
          OBJECT *cs = &cacheListEntry->info.internalisedColorSpace;
          OBJECT *csa = cacheListEntry->info.internalisedCSA;
          COLORSPACE_ID colorSpaceId;
          int i;

          /* This entry is marked as ok for all save levels. Check that a
           * Separation/DeviceN space had its alternate space & tint transform
           * removed when entered into this cache.
           */
          if (oType(*cs) != ONULL && cacheListEntry->info.simpleTransform == NULL) {
            if (!gsc_getcolorspacetype(cs, &colorSpaceId))
              HQFAIL("Should've validated this color space prior to now");
            if (colorSpaceId == SPACE_Separation || colorSpaceId == SPACE_DeviceN) {
              for (i = 2; i < MAX_CSA_LENGTH; i++)
                HQASSERT(oType(csa[i]) == ONOTHING, "Inconsistent cached CSA");
            }
          }
#endif    /* ASSERT_BUILD */

          prevCacheEntry = cacheListEntry;
        }
      }
      else
        prevCacheEntry = cacheListEntry;

      cacheListEntry = nextCacheEntry;
    }

    chainCache = nextChainCache;
  }
}

/* Purge the ChainCache of all caches containing simple transforms prior to
 * destroying the spacecache.
 */
void cc_chainCachePurgeSpaceCache(GS_CHAIN_CACHE_STATE *chainCacheState)
{
  GS_CHAIN_CACHE *chainCache = chainCacheState->gChainCacheHead;

  while (chainCache != NULL) {
    GS_CHAIN_CACHE *nextChainCache = chainCache->next;
    GS_CHAIN_CACHE_LIST *cacheListEntry;
    GS_CHAIN_CACHE_LIST *prevCacheEntry = NULL;

    HQASSERT(chainCache->refCnt > 0, "Non-zero refCnt");

    cacheListEntry = chainCache->list;
    while (cacheListEntry != NULL) {
      GS_CHAIN_CACHE_LIST *nextCacheEntry = cacheListEntry->next;

      if (cacheListEntry->info.simpleTransform != NULL) {
        /* Found one, so delete and remove it from the list */
        destroyCacheEntry(chainCache, cacheListEntry);

        if (cacheListEntry == chainCache->list)
          chainCache->list = nextCacheEntry;
        else
          prevCacheEntry->next = nextCacheEntry;
      }
      else
        prevCacheEntry = cacheListEntry;

      cacheListEntry = nextCacheEntry;
    }

    chainCache = nextChainCache;
  }
}


/** Solicit method of the chain cache low-memory handler. */
static low_mem_offer_t *gs_chain_cache_solicit(low_mem_handler_t *handler,
                                               corecontext_t *context,
                                               size_t count,
                                               memory_requirement_t* requests)
{
  static low_mem_offer_t offer;
  /** \todo The backend color chain cache is currently not purged. */
  GS_CHAIN_CACHE_STATE *cache_state = frontEndColorState->chainCacheState;
  GS_CHAIN_CACHE *chain_cache = cache_state->gChainCacheHead;
  size_t size_to_purge = 0;

  UNUSED_PARAM(low_mem_handler_t *, handler);
  UNUSED_PARAM(size_t, count); UNUSED_PARAM(memory_requirement_t*, requests);

  if ( !context->is_interpreter )
    /* The cache is not thread-safe, but only the interpreter thread uses it. */
    return NULL;
  if ( cache_state->nCachedChains == 0 )
    return NULL;

  while ( chain_cache != NULL ) {
    GS_CHAIN_CACHE_LIST *cache_list_entry = chain_cache->list;

    while ( cache_list_entry != NULL ) {
      HQASSERT(cache_list_entry->chain != NULL, "chain head NULL");
      HQASSERT(cache_list_entry->chain->context != NULL, "chain NULL");

      /** \todo not thread safe, but only using frontEndColorState */
      if ( CLINK_OWNER(cache_list_entry->chain) &&
           CLINK_OWNER(cache_list_entry->chain->context) )
        size_to_purge += 20480; /* @@@@ guess size */
      cache_list_entry = cache_list_entry->next;
    }
    chain_cache = chain_cache->next;
  }
  if ( size_to_purge == 0 )
    return NULL;

  offer.pool = mm_pool_color;
  offer.offer_size = size_to_purge;
  offer.offer_cost = 1.0f;
  offer.next = NULL;
  return &offer;
}


/** Return the allocated size of the color pool, including the SAC.

  This is not thread-safe, so should only be used in the interpreter thread.
*/
static size_t gs_pool_alloced_size(void)
{
  HQASSERT(IS_INTERPRETER(), "gs_pool_alloced_size called unsafely");
  return mm_pool_alloced_size(mm_pool_color)
    - mps_sac_free_size(mm_pool_sac(mm_pool_color));
}


/** Release method of the chain cache low-memory handler. */
static Bool gs_chain_cache_release(low_mem_handler_t *handler,
                                   corecontext_t *context,
                                   low_mem_offer_t *offer)
{
  size_t current_size = gs_pool_alloced_size(), target_size;
  GS_CHAIN_CACHE_STATE *cache_state = frontEndColorState->chainCacheState;
  GS_CHAIN_CACHE *chain_cache = cache_state->gChainCacheHead;

  UNUSED_PARAM(low_mem_handler_t *, handler);
  UNUSED_PARAM(corecontext_t*, context);

  if ( current_size <= offer->taken_size )
    target_size = 0;
  else
    target_size = current_size - offer->taken_size;

  while ( chain_cache != NULL && current_size >= target_size ) {
    GS_CHAIN_CACHE_LIST *cache_list_entry = chain_cache->list;
    GS_CHAIN_CACHE_LIST *prev_cache_entry = NULL;
    GS_CHAIN_CACHE_LIST *next_cache_entry;
    GS_CHAIN_CACHE *next_chain_cache = chain_cache->next;

    HQASSERT(chain_cache->refCnt > 0, "Non-zero refCnt");

    while ( cache_list_entry != NULL && current_size >= target_size ) {
      HQASSERT(cache_list_entry->chain != NULL, "chain head NULL");
      HQASSERT(cache_list_entry->chain->context != NULL, "chain NULL");

      next_cache_entry = cache_list_entry->next;
      /** \todo not thread safe, but only using frontEndColorState */
      if ( CLINK_OWNER(cache_list_entry->chain) &&
           CLINK_OWNER(cache_list_entry->chain->context) ) {
        destroyCacheEntry(chain_cache, cache_list_entry);
        if (cache_list_entry == chain_cache->list)
          chain_cache->list = next_cache_entry;
        else
          prev_cache_entry->next = next_cache_entry;
        /* Other threads may change the size, but can't afford to check. */
        current_size = gs_pool_alloced_size();
      } else
        prev_cache_entry = cache_list_entry;
      cache_list_entry = next_cache_entry;
    }
    chain_cache = next_chain_cache;
  }
  return TRUE;
}


/** The chain cache low-memory handler. */
static low_mem_handler_t gs_chain_cache_handler = {
  "chain cache purge",
  memory_tier_ram, gs_chain_cache_solicit, gs_chain_cache_release, TRUE,
  0, FALSE };


#ifdef METRICS_BUILD
#ifdef ASSERT_BUILD
/* Count all the chains in the ChainCache, but allowing for chain sharing by
 * taking account of the refCnt on both the chainHead and the chain itself.
 * Thus we may return a fractional number, which is ok because it will be
 * used by adding to the fractional contribrution from other roots.
 */
void cc_countChainsinChainCache(double *chainCnt, double *linkCnt)
{
  /* Only the frontend chain caches are counted; the backend chain caches are
     ignored. */
  GS_CHAIN_CACHE *chainCache;

  for ( chainCache = frontEndColorState->chainCacheState->gChainCacheHead;
        chainCache != NULL; chainCache = chainCache->next ) {
    GS_CHAIN_CACHE_LIST *cacheListEntry;

    cacheListEntry = chainCache->list;
    while (cacheListEntry != NULL) {
      double floatChainCount = 0;
      double floatLinkCount = 0;
      GS_CHAINinfo *chain = cacheListEntry->chain;

      HQASSERT(chain->context->pnext != NULL, "chain NULL");
      cc_addCountsForOneContext(chain, &floatChainCount, &floatLinkCount);
      *chainCnt += floatChainCount;
      *linkCnt += floatLinkCount;

      cacheListEntry = cacheListEntry->next;
    }
  }
}
#endif
#endif


#ifdef METRICS_BUILD
static Bool gs_chaincache_metrics_update(sw_metrics_group *metrics)
{
  if ( !sw_metrics_open_group(&metrics, METRIC_NAME_AND_LENGTH("Color")) )
    return FALSE ;

  /* Only the frontend chain caches are counted; the backend chain caches are
     ignored. */
  SW_METRIC_INTEGER("MaxCachedChains", frontEndColorState->chainCacheState->nMaxCachedChains) ;

  sw_metrics_close_group(&metrics) ;

  return TRUE ;
}


static void gs_chaincache_metrics_reset(int reason)
{
  UNUSED_PARAM(int, reason) ;
  if ( frontEndColorState != NULL &&
       frontEndColorState->chainCacheState != NULL )
    frontEndColorState->chainCacheState->nMaxCachedChains = 0;
}

static sw_metrics_callbacks gs_chaincache_metrics_hook = {
  gs_chaincache_metrics_update,
  gs_chaincache_metrics_reset,
  NULL
} ;
#endif


Bool cc_initChainCache(GS_COLORinfo *colorInfo)
{
  int32 i;

  HQASSERT(colorInfo != NULL, "colorInfo NULL");

  for (i = 0; i < GSC_N_COLOR_TYPES; i++) {
    if (!cc_createChainCache(colorInfo, i))
      return FAILURE(FALSE);
  }
  return TRUE ;
}

/* The low mem handler registered global does not need initialising in a init
 * function since it is only read in the finish function which can only be called
 * if the start function has been called which does the initialisation.
 */
static Bool chain_cache_handler_registered = FALSE;

Bool cc_chainCacheSWStart(void)
{
  return chain_cache_handler_registered = low_mem_handler_register(&gs_chain_cache_handler);
}


void cc_chainCacheSWFinish(void)
{
  if (chain_cache_handler_registered) {
    low_mem_handler_deregister(&gs_chain_cache_handler);
    chain_cache_handler_registered = FALSE;
  }
}


void init_C_globals_gs_chaincache(void)
{
  /*
    Globals are only allowed for frontend color transforms. If an item needs to
    be used for both frontend and backend transforms then it should be put into
    COLOR_STATE.
  */
#ifdef METRICS_BUILD
  gs_chaincache_metrics_reset(SW_METRICS_RESET_BOOT) ;
  sw_metrics_register(&gs_chaincache_metrics_hook) ;
#endif
}

#if 0
static void dump_chainCacheDetails(GS_CHAIN_CACHE_INFO *info)
{
  monitorf((uint8 *) "ri:%d, RT:%d, CM:%d, op:%d, opm:%d, ovB:%d, icID:%d, rsID:%d, opqNS:%d, opqS:%d\n",
           info->renderingIntent,
           info->reproType,
           info->colorModel,
           info->overprint,
           info->opMode,
           info->opBlack,
           info->interceptId,
           info->rasterStyleId,
           info->opaqueNonStroke,
           info->opaqueStroke);
  monitorf((uint8 *) "AP:%x, DeviceNn:%d, smpTT:%x, svl:%d, svlOnly:%d\n",
           info->associatedProfile.u,
           info->nDeviceNColorants,
           &info->simpleTransform,
           info->saveLevel,
           info->forThisSaveLevelOnly);
  /** \todo Dump internalisedColorSpace. */
}

void debug_dump_chainCacheDetails(GS_COLORinfo *colorInfo, int32 colorType)
{
  if (debug_chainCache) {
    GS_CHAIN_CACHE_INFO tmpInfo = {0};
    GS_CHAINinfo *foundChain;
    Bool suitableForCaching;
    COLORANTINDEX ciArray[100];
    tmpInfo.colorantArray = ciArray;
    if (cc_findChainCacheEntry(colorInfo, colorType, FALSE,
                               &foundChain, &tmpInfo, &suitableForCaching)) {
      dump_chainCacheDetails(&tmpInfo);
    }
    else
      HQFAIL("cc_findChainCacheEntry failed, I'm confused");
  }
}
#endif


/* Log stripped */
