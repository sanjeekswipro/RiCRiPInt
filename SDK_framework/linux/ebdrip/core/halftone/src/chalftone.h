/** \file
 * \ingroup halftone
 *
 * $HopeName: COREhalftone!src:chalftone.h(EBDSDK_P.1) $
 *
 * Copyright (C) 1991-2011 Global Graphics Software Ltd. All rights reserved.
 * Global Graphics Software Ltd. Confidential Information.
 *
 * \brief
 * The CHALFTONE structure describing a single screen.
 */

#ifndef __CHALFTONE_H__
#define __CHALFTONE_H__ 1

#include "htpriv.h"
#include "bitbltt.h" /* FORM */

struct NAMECACHE ; /* from COREobjects */
struct FORMCLASS; /* from halftone.c */
struct LEVELSRECORD; /* from halftone.c */


/** The real in-memory structure for cached halftones.  N.B. Must be
 * compatible with CHALFTONE_ON_DISK, as mediated by htdisk.c.  All
 * measurements are in pixels, unless explicitly noted to be in bits
 * (different for multibit halftones).
 */
struct CHALFTONE {
  SYSTEMVALUE      freqv ;
  SYSTEMVALUE      anglv ;
  SYSTEMVALUE      ofreq ;
  SYSTEMVALUE      oangle ;
  SYSTEMVALUE      dfreq ;
  SYSTEMVALUE      efreq ;
  SYSTEMVALUE      eangle ;
  SYSTEMVALUE      supcell_ratio ;
  int32            *halfys ;
  int16            *xcoords ;
  int16            *ycoords ;
  uint32           *thxfer ;        /**< Only non-NULL for threshold arrays. */
  struct LEVELSRECORD *levels;      /**< Array of levelsrecords. */
  struct LEVELSRECORD *usage;       /**< Levelsrecord for the frontend. */
  struct LEVELSRECORD *forms;       /**< Levelsrecord for the backend. */
  FORM             *pattern_form ;  /**< Form if the screen is a pattern screen. */
  struct NAMECACHE *sfname ;
  struct FORMCLASS *formclass ;
  struct CHALFTONE *prev_chptr ;    /**< Chain of similar-sized screens. */
  struct CHALFTONE *next_chptr ;    /**< Chain of similar-sized screens. */
  void *           spare4; /* SPARE, PLEASE USE ME. NULL on disk. */
  int32            halftype ;       /**< Halftone type (ht_render_type). */
  int32            halfrotate ;     /**< Blit width modulo cell width in bits for ONELESSWORD. */
  int32            halfxdims ;      /**< Actual cell width in bits. */
  int32            halfydims ;      /**< Actual cell height in pixels. */
  int32            halfexdims ;     /**< Cell width including orthogonal replications. */
  int32            halfeydims ;     /**< Cell height including orthogonal replications. */
  int32            halfmxdims ;     /**< Cell width used for allocation. */
  int32            halfmydims ;     /**< Cell height used for allocation. */
  int32            halfr1 ;
  int32            halfr2 ;
  int32            halfr3 ;
  int32            halfr4 ;
  int32            halfrepeatb ;    /**< Byte repeat to replicate cells (LCM of width & 8). */
  int32            spare5; /* SPARE, PLEASE USE ME. 0 on disk. */
  int32            num_deferred ;   /**< Track the number of deferred allocations. */
  uint8            *path;           /**< Location of screen cache on disk. */
  uint32           duplicate ;
  int32            accurateScreen ;
  int32            supcell_multiplesize ;
  int32            supcell_actual ;
  int32            supcell_remainder ;
  int32            screen_index ;  /* unique screen index */
  uint16           notones ;       /**< number of levels in the screen minus 1. */
  int16            spare3 ;        /* SPARE, PLEASE USE ME.  insertchentry() sets me to 0 */
  /** Security: Locks the screen cache to the dongle. Note, older caches
      (pre version 6) have zero here; Such caches must be regenerated,
      otherwise there would be a way to poke the field with zero and
      have the cache work with any RIP. At some point, it may become
      possible to distribute screens in this format, in which case there
      will need to be a way to enable arbitrary caches by password; but
      so far this is just to secure the caches generated by some other
      secure means in one RIP from being transported to another. */
  uint16           lock ;
  uint16           maxthxfer ;     /**< Largest index of thxfer array. */
  int16            screenmark ;
  int16            reportme ;
  int8             reported ;      /**< true if already reported by screenforall. */
  int8             reportcolor ;   /**< remember color for HDS reporting (-1 for N/A). */
  int8             spare1; /* SPARE, PLEASE USE ME. insertchentry() sets me to 0 */
  uint8            flags; /**< Flags: extragrays, multithreshold, dotcentered */
  int8             hpstwo ;        /**< True if screen generated with HPS2. */
  int8             screenprotection ; /* See the SCREENPROT_xxx
                                         definers later (used to be
                                         0x01 for Hex-Hds protection) */
  uint8            depth_shift; /**< Shift for bit depth */
  uint8            spare2; /* SPARE, PLEASE USE ME.  insertchentry() sets me to 0 */
};


#define HALF_EXTRA_GRAYS    0x1
#define HALF_MULTITHRESHOLD 0x2
#define HALF_DOT_CENTERED   0x4
#define HALF_LOW_RES_HDS    0x8  /**< HDS installed with low-res password */
#define HALF_LOW_RES_HXM    0x10 /**< HXM installed with low-res password */
#define HALF_OPT_EXCEEDED   0x20 /**< Exceeded frequency/angle error limits */
#define HALF_ANGLE_UNOPT    0x40 /**< Unoptimized angle in HPS */

#define HalfGetExtraGrays(ch) (((ch)->flags & HALF_EXTRA_GRAYS) != 0)
#define HalfSetExtraGrays(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_EXTRA_GRAYS; \
 else \
   (ch)->flags &= ~HALF_EXTRA_GRAYS; \
MACRO_END

#define HalfGetMultithreshold(ch) (((ch)->flags & HALF_MULTITHRESHOLD) != 0)
#define HalfSetMultithreshold(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_MULTITHRESHOLD; \
 else \
   (ch)->flags &= ~HALF_MULTITHRESHOLD; \
MACRO_END

#define HalfGetDotCentered(ch) (((ch)->flags & HALF_DOT_CENTERED) != 0)
#define HalfSetDotCentered(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_DOT_CENTERED; \
 else \
   (ch)->flags &= ~HALF_DOT_CENTERED; \
MACRO_END

#define HalfGetLowResHDS(ch) (((ch)->flags & HALF_LOW_RES_HDS) != 0)
#define HalfSetLowResHDS(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_LOW_RES_HDS; \
 else \
   (ch)->flags &= ~HALF_LOW_RES_HDS; \
MACRO_END

#define HalfGetLowResHXM(ch) (((ch)->flags & HALF_LOW_RES_HXM) != 0)
#define HalfSetLowResHXM(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_LOW_RES_HXM; \
 else \
   (ch)->flags &= ~HALF_LOW_RES_HXM; \
MACRO_END

#define HalfGetOptimizationErrorExceeded(ch) (((ch)->flags & HALF_OPT_EXCEEDED) != 0)
#define HalfSetOptimizationErrorExceeded(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_OPT_EXCEEDED; \
 else \
   (ch)->flags &= ~HALF_OPT_EXCEEDED; \
MACRO_END

#define HalfGetAngleUnoptimized(ch) (((ch)->flags & HALF_ANGLE_UNOPT) != 0)
#define HalfSetAngleUnoptimized(ch, val) MACRO_START \
 if (val) \
   (ch)->flags |= HALF_ANGLE_UNOPT; \
 else \
   (ch)->flags &= ~HALF_ANGLE_UNOPT; \
MACRO_END

#define theIHalfType(val)      ((val)->halftype)
#define theIHalfRotate(val)    ((val)->halfrotate)
#define theIHalfRepeat(val)    ((val)->halfrepeat)
#define theIHalfRepeatB(val)   ((val)->halfrepeatb)

#define theIScreenReport(val)  ((val)->reported)
#define theIScreenIndex(val)   ((val)->screen_index)

#define theIHalfXDims(val)     ((val)->halfxdims)
#define theIHalfYDims(val)     ((val)->halfydims)
#define theIHalfEXDims(val)    ((val)->halfexdims)
#define theIHalfEYDims(val)    ((val)->halfeydims)
#define theIHalfMXDims(val)    ((val)->halfmxdims)
#define theIHalfMYDims(val)    ((val)->halfmydims)

#define theINoTones(val)       ((val)->notones)

#define theIHalfR1(val)        ((val)->halfr1)
#define theIHalfR2(val)        ((val)->halfr2)
#define theIHalfR3(val)        ((val)->halfr3)
#define theIHalfR4(val)        ((val)->halfr4)

#define theIHalfYs(val)         ((val)->halfys)
#define theIXCoords(val)        ((val)->xcoords)
#define theIYCoords(val)        ((val)->ycoords)

#define theITHXfer(val)         ((val)->thxfer)
#define theIMaxTHXfer(val)      ((val)->maxthxfer)

#define theIUsageLevels(val)   ((val)->usage)
#define theIFormLevels(val)    ((val)->forms)
#define theILevels(val)        ((val)->levels)

#define theIDuplicate(val)     ((val)->duplicate)
#define theIScreenMarked(val)  ((val)->screenmark)

#define theIAccurateScreen(val)         ((val)->accurateScreen)
#define theIExtraGrays(val)             ((val)->extragrays)
#define theIHPSTwo(val)                 ((val)->hpstwo)
#define theISFName(val)                 ((val)->sfname)
#define theISuperCellRatio(val)         ((val)->supcell_ratio)
#define theISuperCellMultipleSize(val)  ((val)->supcell_multiplesize)
#define theISuperCellActual(val)        ((val)->supcell_actual)
#define theISuperCellRemainder(val)     ((val)->supcell_remainder)


/* The screenprotection byte used to be called hdsprotection.
   It used to be 0x01 for Hex-Hds screens, 0x00 otherwise.
   It has now been extended and is made up of:
     m.s. 4 bits = The minimum required encryption level;
     l.s. 4 bits = Which feature-password is required to use the screen.
   The value 0x01 used by existing Hex-Hds caches must be retained. */
#define SCREENPROT_ENCRYPT_MASK (0xF0)
#define SCREENPROT_PASSREQ_MASK (0x0F)

#define SCREENPROT_ENCRYPT_NONE     (0x00)
#define SCREENPROT_ENCRYPT_ANYHQN   (0x10)
#define SCREENPROT_ENCRYPT_CUSTOMER (0x20)
#define SCREENPROT_ENCRYPT_DONGLE   (0x30)

#define SCREENPROT_PASSREQ_NONE (0x00)
#define SCREENPROT_PASSREQ_HDS  (0x01)
#define SCREENPROT_PASSREQ_HXM  (0x02)

#define SCREENPROT_NONE (SCREENPROT_ENCRYPT_NONE | SCREENPROT_PASSREQ_NONE)


#endif /* protection for multiple inclusion */

/* Log stripped */
