/* Copyright (C) 2006-2007 Global Graphics Software Ltd. All rights reserved.
 *
 * $HopeName: SWptdev!src:xpsconf.c(EBDSDK_P.1) $
 *
 * This example is provided on an "as is" basis and without
 * warranty of any kind. Global Graphics Software Ltd. does not
 * warrant or make any representations regarding the use or results
 * of use of this example.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ptincs.h"
#include "xmlcbcks.h"
#include "prnttckt.h"
#include "msxml.h"
#include "ggxml.h"
#ifdef INRIP_PTDEV
#include "streams.h"
#endif

#include "xpsconf.h"

/**
 * @file
 * @brief Configuration of PrintTicket device.
 */

/**
 * @brief This holds the initial default PrintTicket that is used to create the initial
 * merged and validated Job-Level PrintTicket
 */
static PRINTTICKET* pt_default = NULL;

/**
 * @brief Array of validated PrintTickets for each scope level.  The next specific
 * validated PrintTicket is generated by merge and validating the current
 * validated PrintTicket with the one just parsed.
 */
static PRINTTICKET* pt_validated[3];

/**
 * @brief The custom namespace URI used in the PrintTicket.
 */
#define CUSTOM_NAMESPACE_URI "http://schemas.globalgraphics.com/xps/2005"

/**
 * @brief The XML for the default PrintTicket settings.
 *
 * When an external PrintTicket handler is specified it will provide
 * the default values instead of using those defined here.
 * To add a default value which will apply regardless of whether an internal
 * or external PrintTicket handler is specified consider adding default
 * values to the appropriate PrintTicket PostScript module(s).
 *
 * @see setExternalPTHandler()
 */
static char* default_printticket[] = {
"<psf:PrintTicket version=\"1\" \
  xmlns:ns0000=\"" CUSTOM_NAMESPACE_URI "\" \
  xmlns:psf=\"http://schemas.microsoft.com/windows/2003/08/printing/printschemaframework\" \
  xmlns:psk=\"http://schemas.microsoft.com/windows/2003/08/printing/printschemakeywords\" \
  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \
  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">",

  /* Hard-coded defaults go here. */

"</psf:PrintTicket>"
};

#define NUM_LINES_DFLTXML  (sizeof(default_printticket)/sizeof(default_printticket[0]))

#ifdef INRIP_PTDEV

/**
 * @brief Pointer to an external set of functions for merging and validating
 * the PrintTicket parts.
 *
 * <p>This demonstration PT device provides its own merging functionality,
 * which will be used by default.
 */
static PTHandler *pExternalPTHandler = NULL;

/**
 * @brief When using an external PTHandler, this stream consumes the data for
 * the current PrintTicket fragment.
 */
static HqnWriteStream *pPTDeltaStream = NULL;

#endif

/**
 *  @brief This variable can be set with the result of a digital signature check.
 */
static int32 fXPSSignatureStatus = TRUE;

#ifdef INRIP_PTDEV

/**
 * @return A pointer to the PGB device.
 */
static DEVICELIST* getPGBDevice()
{
  return SwFindDevice( (uint8*) "pagebuffer" );
}

/**
 * @brief Switch to a set of external functions for merging PrintTickets.
 */
void setExternalPTHandler( PTHandler *pHandler )
{
  pExternalPTHandler = pHandler;
}

#endif

/**
 * @brief Record the state of the job's digital signature.
 */
void setXPSDigitalSignatureStatus( int32 fDigitalSignatureValid )
{
  fXPSSignatureStatus = fDigitalSignatureValid;
}

#ifdef INRIP_PTDEV

/**
 * @brief Use the externally-provided PT merging functions to create the
 * effective PT for the given scope.
 *
 * <p>When this function has been called, a complete XML PT fragment
 * (or "delta") will have been written into the <code>pPTDeltaStream</code>.
 * The external handler is invoked to merge this onto the current PT. The
 * external handler then provides a read stream onto the merged result,
 * which is consumed and parsed in a single XML parsing session.
 *
 * <p>This function has the side effect of placing the parsed tree
 * into <code>pt_validated[ level ]</code>.
 */
static int32 mergeViaExternalHandler( int32 level )
{
  HqnReadStream *pMergeStream = NULL;
  uint8          buffer[ 4096 ];
  int32          cbBytes;
  int32          fParseError = FALSE;
  int32          nXPSPTScope;

  /* Map between the PT device's internal scope value and the
     scope value as defined by the PTHandler contract. */
  switch( level )
  {
    case JOB_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_JOB;
      break;
    case DOCUMENT_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_DOCUMENT;
      break;
    case PAGE_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_PAGE;
      break;
    default:
      /* Illegal */
      return FALSE;
  }

  /* Merge the current delta into the effective PrintTicket. This returns
     a read stream on the merged XML, or NULL if the merge failed. */
  pMergeStream = pExternalPTHandler->pfMergeDelta
    (
      pExternalPTHandler->pPrivate,
      pPTDeltaStream,
      nXPSPTScope
    );

  if ( pMergeStream == NULL )
  {
    /* The external handler was unable to perform the merge. */
    return FALSE;
  }

  /* We now need to parse the merged PT, so start a new parsing session. */
  if ( !pt_xml_start() )
  {
    pMergeStream->pfClose( pMergeStream->pPrivate );
    return FALSE;
  }

  /* Consume and parse the merge stream in buffered chunks. */
  cbBytes = pMergeStream->pfRead
    ( pMergeStream->pPrivate, buffer, sizeof( buffer ) );

  while ( cbBytes > 0 && !fParseError )
  {
    fParseError = !xml_parse( buffer, &cbBytes );
    cbBytes = pMergeStream->pfRead
      ( pMergeStream->pPrivate, buffer, sizeof( buffer ) );
  }

  /* End of session */
  pt_xml_end();

  /* If the parse worked, pt_new is now the current valid PT. */
  if ( !fParseError )
  {
    pt_validated[ level ] = pt_copy( pt_new );
  }

  /* Shed the temporary parse tree. */
  if ( pt_new != NULL )
  {
    pt_release( &pt_new );
  }

  /* And close the stream. */
  pMergeStream->pfClose( pMergeStream->pPrivate );

  return !fParseError;
}

/**
 * @brief Fire progress messages.
 *
 * If an externally-provided progress callback function is defined
 * then it will be called.  The document number held by the pagebuffer
 * device are is updated here.
 *
 * @param level  The XPS job/doc/page scope level.
 * @param fEntered <code>TRUE</code> if processing is beginning at the specified
 * <code>level</code>, <code>FALSE</code> if processing is complete.
 */
static void fireProgressMessage( int32 level, int32 fEntered )
{
  int32 nXPSPTScope;
  DEVICELIST* pPGBDev = getPGBDevice ();
  DEVICEPARAM devDocumentParam;

  theDevParamName (devDocumentParam) = (uint8*) "DocumentNumber";
  theDevParamNameLen (devDocumentParam) = strlen_int32 ((const char*) devDocumentParam.paramname);
  theDevParamType (devDocumentParam) = ParamInteger;

  /* Map between the PT device's internal scope value and the
      scope value as defined by the PTHandler contract. */
  switch( level )
  {
    case JOB_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_JOB;

      /* Reset pagebuffer document count */
      if (fEntered && pPGBDev)
      {
        devDocumentParam.paramval.intval = 0;
        (*theISetParam (pPGBDev))(pPGBDev, &devDocumentParam);
      }
      break;

    case DOCUMENT_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_DOCUMENT;

      /* Increment pagebuffer document count */
      if (fEntered && pPGBDev)
      {
        (*theIGetParam (pPGBDev))(pPGBDev, &devDocumentParam);
        devDocumentParam.paramval.intval ++;
        (*theISetParam (pPGBDev))(pPGBDev, &devDocumentParam);
      }
      break;

    case PAGE_LEVEL:
      nXPSPTScope = XPSPT_LEVEL_PAGE;
      break;

    default:
      /* Illegal */
      return;
  }

  /* Signal progress callback via external PT handler */
  if ( pExternalPTHandler && pExternalPTHandler->pfProgressCallback )
  {
    pExternalPTHandler->pfProgressCallback (
      pExternalPTHandler->pPrivate,
      nXPSPTScope,
      fEntered
      );
  }
}

#endif

/**
 * @brief Block of data to be returned on a config file read.
 */
typedef struct FILE_CONTENT {
  int32   read_state;  /** Current state of read */
  int32   level;       /** PrintTicket scope level */
  int32   start;       /** PrintTicket start config file */
  uint8*  buffer;      /** Buffered data to be returned */
  int32   bufsize;     /** Size of the buffer */
  int32   length;      /** Length of data in buffer to be returned */
  int32   index;       /** Index of start of data to be returned, <= length */
} FILE_CONTENT;

#define READ_UNDEFINED  (0) /** No active read in progress */
#define READ_CHECK_PT   (1) /** First call to read from a file */
#define READ_START      (2) /** First call to read from a file */
#define READ_DO         (3) /** Reading file data */
#define READ_EOF        (4) /** No more data to return on a read */

static
FILE_CONTENT g_fc = {0};

/** @brief Set up file content for next lump of data to return */
static
void fc_setup(
  FILE_CONTENT* fc,
  uint8*        data,
  int32         length)
{
  if (length > 0)
  {
    if (length > fc->bufsize)
    {
      /* (Re)allocate buffer */
      if (fc->buffer)
        MemFree (fc->buffer);

      fc->buffer = (uint8*) MemAlloc (length, FALSE, FALSE);
      if (! fc->buffer)
      {
        /* Allocation failed */
        fc->bufsize = 0;
        fc->length = 0;
        fc->index = 0;
        return;
      }

      fc->bufsize = length;
    }
    memcpy(fc->buffer, data, CAST_SIGNED_TO_SIZET(length));
  }

  fc->length = length;
  fc->index = 0;
}

/** @brief Read data from buffer up to amount requested or available */
static
int32 fc_read(
  FILE_CONTENT* fc,
  uint8*        buff,
  int32         len)
{
  int32   do_len;

  do_len = fc->length - fc->index;
  if ( len < do_len ) {
    do_len = len;
  }

  if ( do_len > 0 ) {
    memcpy(buff, &fc->buffer[fc->index], CAST_SIGNED_TO_SIZET(do_len));
    fc->index += do_len;

    if (fc->index == fc->length)
    {
      /* No more data to read so we can release the buffer */
      MemFree (fc->buffer);
      fc->buffer = NULL;
      fc->bufsize = 0;
      fc->length = 0;
      fc->index = 0;
    }
  }

  return(do_len);
}


/**
 * @brief Creates the default PrintTicket settings for the device.
 *
 * Passes strings of XML for the default PrintTicket parameters to the XML
 * parser to create the internal structure representation
 */
static int32 parseInternalDefaultPT(void)
{
  int32 i;
  int32 len;
  int32 fResult = FALSE;
  PRINTTICKET* pt_current = NULL;

  /* Initialise XML parser */
  if ( !pt_xml_start() ) {
    return(FALSE);
  }

  /* Record current state of pt_new */
  if (pt_new) {
    pt_current = pt_copy (pt_new);
    pt_release (&pt_new);
    pt_new = NULL;
  }

  /* Send default PT XML through the parser */
  for ( i = 0; i < NUM_LINES_DFLTXML; i++ ) {
    len = strlen_int32(default_printticket[i]);
    if ( !xml_parse((uint8*)default_printticket[i], &len) ) {
      break;
    }
  }

  /* Close down the parser */
  pt_xml_end();

  if ( (i < NUM_LINES_DFLTXML) || ! pt_new || !pt_complete(pt_new) ) {
    /* There was an error parsing the default PT - purge any structure built */
    if (pt_new)
      pt_release(&pt_new);
  } else {
    fResult = TRUE;

    /* Cache the default PrintTicket */
    pt_default = pt_copy(pt_new);
    pt_release(&pt_new);
  }

  /* Restore state of pt_new */
  if (pt_current) {
    pt_new = pt_copy (pt_current);
    pt_release (&pt_current);
  }

  return fResult;
}

int32 cfg_start(void)
{
  /* Reset all the C globals. */
  pt_default = NULL;
  memset(pt_validated, 0, sizeof(pt_validated));
#ifdef INRIP_PTDEV
  pExternalPTHandler = NULL;
  pPTDeltaStream = NULL;
#endif
  fXPSSignatureStatus = TRUE;
  memset(&g_fc, 0, sizeof(FILE_CONTENT));
  return(TRUE);
}


int32 cfg_open(
  int32 level,
  int32 start)
{
  if ( start )
  {
#ifdef INRIP_PTDEV
    if ( pExternalPTHandler != NULL )  /* Use external merging. */
    {
      pPTDeltaStream = pExternalPTHandler->pfOpenDelta
        ( pExternalPTHandler->pPrivate );

      if ( pPTDeltaStream == NULL )
        return FALSE;
    }
    else
#endif
    if ( !pt_xml_start() )  /* Get ready to start parsing the PT for this
                               scope. */
    {
      return(FALSE);
    }
  }

  /* Flag if need to merge and validate any PrintTicket on first read for a
   * start configuration file.
   */
  g_fc.level = level;
  g_fc.start = start;
  g_fc.read_state = start ? READ_CHECK_PT : READ_START ;

  return(TRUE);
}

/**
 *  Convert XPS points (96 dpi) to PostScript points (72 dpi).
 */
static double XPSToPSdpi (double n)
{
  return n * 72.0 / 96.0;
}

/**
 *  Convert XPS microns to PostScript points. (E.g. 25400 microns = 72 points)
 */
static double MicronToPSdpi (double n)
{
  return n / 1000.0 * 72.0 / 25.4;
}

/**
 * \brief Set the ImageableArea used by the PrintTicket procset.
 *
 * In practice this code could query the output device for an appropriate
 * ImageableArea, or use the FixedPage size in combination with a lookup table.
 *
 * \param pPageAreas  The structure to populate with ImageableArea info.
 */
static void setXPSImageableArea (PT_PAGEAREAS* pPageAreas) 
{
  /*
   * Adjust the following code to set a custom ImageableArea.
   *
   * If ExtentWidth and ExtentHeight are set to zero the PrintTicket procset
   * will assume the imageable area covers the entire media.
   */
  pPageAreas->arrImageableArea[0] = MicronToPSdpi (0.0); /* OriginWidth */
  pPageAreas->arrImageableArea[1] = MicronToPSdpi (0.0); /* OriginHeight */
  pPageAreas->arrImageableArea[2] = MicronToPSdpi (0.0); /* ExtentWidth */
  pPageAreas->arrImageableArea[3] = MicronToPSdpi (0.0); /* ExtentHeight */
  pPageAreas->fTrimToImageableArea = FALSE;
}

/**
 * \brief Set the various page areas (such as FixedPage size, ContentBox area, etc).
 *
 * All values should be in PostScript points.
 *
 * \param pPageAreas  The structure to populate.
 */
static void setXPSPageAreas (PT_PAGEAREAS* pPageAreas) 
{
  const int32 kBoxArrayLength = 4;
  int32 i;

  /* Set the FixedPageSize. */
  pPageAreas->arrFixedPageSize[0] = XPSToPSdpi (size[0]);
  pPageAreas->arrFixedPageSize[1] = XPSToPSdpi (size[1]);

  /* Set the BleedBox and ContentBox area (in PS points). */
  for (i = 0; i < kBoxArrayLength; i ++)
  {
    pPageAreas->arrBleedBox[i] = XPSToPSdpi (bleedbox[i]);
    pPageAreas->arrContentBox[i] = XPSToPSdpi (contentbox[i]);
  }

  /* Set the ImageableArea. */
  setXPSImageableArea (pPageAreas);
}

int32 cfg_read(
  uint8*  buff,
  int32*  len)
{
  PRINTTICKET*  pt_valid;
  uint8* ptbzPS;
  int32 fStartPTScope = (g_fc.start != 0);

  switch ( g_fc.read_state ) {
  case READ_CHECK_PT :
#ifdef INRIP_PTDEV
    if ( pExternalPTHandler != NULL )
    {
      mergeViaExternalHandler( g_fc.level );
    }
    else
#endif
    {
      /* Ensure default PrintTicket settings are available */
      if (! pt_default)
        parseInternalDefaultPT ();

      /* Perform the validation using demo functionality in the PT device. */
      pt_valid = (g_fc.level == PT_LEVEL_JOB)
                    ? pt_default
                    : pt_validated[g_fc.level - 1];

      if (pt_valid)
      {
        /* Merge new PrintTicket with current validated one */
        pt_merge_and_validate(&pt_validated[g_fc.level], pt_valid, pt_new, g_fc.level);
      }
      else
      {
        pt_validated[g_fc.level] = NULL;
      }
    }

    g_fc.read_state = READ_DO;
    /* FALLTHROUGH */

  case READ_START:

#ifdef INRIP_PTDEV
    /* Signal progress information */
    fireProgressMessage( g_fc.level, fStartPTScope );
#endif

    /* Generate PostScript suitable for each job level */
    switch ( g_fc.level ) {
    case PT_LEVEL_JOB:
      if ( fStartPTScope ) {
        ptbzPS = pt_createJobStartPS (pt_validated[PT_LEVEL_JOB]);

        if (ptbzPS)
        {
          fc_setup (&g_fc, ptbzPS, strlen_int32 ((char*) ptbzPS));
          MemFree (ptbzPS);
          ptbzPS = NULL;
        } else {
          fc_setup(&g_fc, STRING_AND_LENGTH("% Error generating job config."));
        }
      } else {
        fc_setup(&g_fc, STRING_AND_LENGTH("/HqnXPSPrintTicket /ProcSet findresource /EndJob get exec\n"));
      }
      break;

    case PT_LEVEL_DOCUMENT:
      if ( fStartPTScope ) {
        ptbzPS = pt_createDocumentStartPS (pt_validated[PT_LEVEL_DOCUMENT]);

        if (ptbzPS)
        {
          fc_setup (&g_fc, ptbzPS, strlen_int32 ((char*) ptbzPS));
          MemFree (ptbzPS);
          ptbzPS = NULL;
        } else {
          fc_setup(&g_fc, STRING_AND_LENGTH("% Error generating document config."));
        }
      } else {
        fc_setup(&g_fc, STRING_AND_LENGTH("/HqnXPSPrintTicket /ProcSet findresource /EndDocument get exec\n"));
      }
      break;

    case PT_LEVEL_PAGE:
      if ( fStartPTScope ) {
        PT_PAGEAREAS pageAreas;

        setXPSPageAreas (&pageAreas);
        ptbzPS = pt_createPageStartPS (&pageAreas,
                                       fXPSSignatureStatus,
                                       pt_validated[PT_LEVEL_PAGE]);
        if (ptbzPS)
        {
          fc_setup (&g_fc, ptbzPS, strlen_int32 ((char*) ptbzPS));
          MemFree (ptbzPS);
          ptbzPS = NULL;
        } else {
          fc_setup(&g_fc, STRING_AND_LENGTH("% Error generating page config."));
        }
      } else {
        fc_setup(&g_fc, STRING_AND_LENGTH("/HqnXPSPrintTicket /ProcSet findresource /EndPage get exec\n"));
      }
      break;

    default:
      return(FALSE);
    }
    g_fc.read_state = READ_DO;
    /* FALLTHROUGH */

  case READ_DO:
    *len = fc_read(&g_fc, buff, *len);
    if ( *len == 0 ) {
      g_fc.read_state = READ_EOF;
    }
    break;

  case READ_EOF:
    *len = 0;
    break;

  default: /* Invalid read state */
    return(FALSE);
  }

  return(TRUE);
}

int32 cfg_write(
  uint8*  buffer,
  int32*  len)
{
#ifdef INRIP_PTDEV
  /* If we are using an external PT handler, then just write the data straight
     through to the current stream. Otherwise, incrementally parse the buffer. */
  if ( pPTDeltaStream != NULL )
  {
    int32 cbWritten = pPTDeltaStream->pfWrite
      ( pPTDeltaStream->pPrivate, buffer, *len );

    if ( cbWritten < 0 )
    {
      *len = 0;
      return FALSE;
    }
    else
    {
      *len = cbWritten;
      return TRUE;
    }
  }
  else
#endif
  {
    return(xml_parse(buffer, len));
  }
}

int32 cfg_close(
  int32 level,
  int32 start,
  int32 abort)
{
  UNUSED_PARAM(int32, abort);

  if ( start )
  {
#ifdef INRIP_PTDEV
    if ( pExternalPTHandler != NULL )
    {
      /* We don't close the delta stream, we just set it to NULL. It will
         already have been closed via pfMergeDelta() */
      pPTDeltaStream = NULL;
    }
    else
#endif
    {
      /* Start scope files use XML parser for a PrintTicket so close it */
      pt_xml_end();

      if ( pt_new != NULL ) {
        /* A PrintTicket has been parsed and merge and validated */
        pt_release(&pt_new);
      }
    }
  }
  else
  {
    /* PrintTicket for scope level no longer applies, release it */
    pt_release(&pt_validated[level]);
  }

  g_fc.read_state = READ_UNDEFINED;

  return(TRUE);
}

int32 cfg_eof(
  int32 level,
  int32 start)
{
  UNUSED_PARAM(int32, level);
  UNUSED_PARAM(int32, start);

  return(g_fc.read_state == READ_EOF);
}

int32 cfg_end(void)
{
  /* Free off default PrintTicket structure */
  if ( pt_default != NULL ) {
    pt_release(&pt_default);
  }

  return(TRUE);
}

const char *cfgCheckDigitalSignatures(void)
{
#ifdef INRIP_PTDEV
  if ( pExternalPTHandler != NULL &&
       pExternalPTHandler->pfGetDigitalSignatureStatus != NULL )
  {
    uint32 statusResult = pExternalPTHandler->pfGetDigitalSignatureStatus
      ( pExternalPTHandler->pPrivate );

    switch( statusResult )
    {
      case XPSPT_DIGSIG_NOTCHECKED:
        return "NotChecked";

      case XPSPT_DIGSIG_NOTSIGNED:
        return "NotSigned";

      case XPSPT_DIGSIG_INVALID:
        return "SignedInvalid";

      case XPSPT_DIGSIG_VALID:
        return "SignedValid";

      case XPSPT_DIGSIG_ERROR:
      default:
        return "CheckingError";
    }
  }
#endif

  return "NoFacility";
}


/* EOF config.c */
