/* Copyright (C) 2006-2012 Global Graphics Software Ltd. All rights reserved.
 *
 * This example is provided on an "as is" basis and without
 * warranty of any kind. Global Graphics Software Ltd. does not
 * warrant or make any representations regarding the use or results
 * of use of this example.
 */

/* $HopeName: SWskinkit!export:memfs.h(EBDSDK_P.1) $ */

#ifndef __MEMFS_H__
#define __MEMFS_H__

/**
 * \file memfs.h
 * \ingroup skinkit
 * \brief Simple API for managing an in-memory, virtual file system.
 *
 * <p>This API specifies a simple tree data structure for representing
 * one or more <dfn>virtual file systems</dfn>. Each system is modelled as a
 * tree of <code>MFSNODE</code> objects, where each node represents either a
 * file or a directory. A file is always a leaf node, whereas a directory
 * contains pointers down to child nodes. As with any filesystem, each
 * node is assigned a name, meaning that nodes may be addressed using
 * a path. Currently, only 8-bit ASCII filenames are supported. The tree
 * may be arbitrarily nested. (Pathnames are expressed using a forward-slash
 * <code>'/'</code> character as the separator).
 *
 * <p>These data structures are designed to be statically-declarable, but
 * dynamically-growable. A filesystem need not start off as empty, although
 * it can do. It is possible to write (or generate) a series of static
 * C data declarations to describe the initial state of a whole tree.
 * This leads the way for implementing an "Import Tool", which can scan
 * an existing directory on disk, and represent it as a virtual filesystem
 * within the application's memory. This can eliminate avoid the need for
 * configuration files on disk.
 *
 * <p>Whether from an empty initial state, or from a pre-declared static state,
 * it is possible to access and modify files, and to create new ones.
 * Such modifications, of course, persist only for the lifetime of the
 * application, since the entire filesystem is held in process-local memory.
 * Functions are provided to open and create files, and for reading and
 * writing data. There are also functions for managing the tree: such as
 * locating, deleting and renaming files. See the individual function
 * descriptions for further details in each case.
 *
 * <p>The API supports compression and decompression via the ZLIB
 * interface. This happens transparently, but a file's data stream can only
 * be in a compressed state when the file is closed. In order to keep the
 * code simple, live stream-based compression/decompression of open files is
 * \e not supported. As soon as a file is opened with
 * <code>MFSOpen()</code>, its data stream will become uncompressed
 * in its entirety, and will remain so until the file is closed, whereupon
 * the data will be re-compressed.
 *
 * <p>When a file system has a statically-declared initial state (as might
 * be generated by an Import Tool), it is likely that the Import Tool
 * will apply compression to the data buffers where possible. If it does
 * so, it \e must do so via the ZLIB interface. Statically-declared
 * filesystems are expected to be the typical case for compression. However,
 * a policy of compressing dynamically-created MFS files can also be
 * put in place by tuning the <code>COMPRESS_NEW_FILES</code> macro, defined
 * in this header file. If this macro is set to <code>FALSE</code>, no
 * compression will be applied to fresh files created at runtime.
 *
 * <p>The implementation of this API is thread-safe, to the extent that there
 * is no undocumented global state within the implementation that might
 * prevent concurrent use. However, the tree structures themselves are
 * \e not protected by this layer. Broadly, this means that
 * concurrent use of this API should be limited to <em>disjoint
 * filesystem trees, or disjoint portions of a single tree</em>. For
 * convenience, there are some exceptions to this general rule, particularly
 * when read-only access is required to files and directories.
 *
 * <p>This API is primarily aimed at implementing a \e device in terms
 * of the Core RIP Device Interface. Some of the flags and return codes used
 * here are deliberately specified to match the contracts of the Device
 * Interface. However, this API can also be used standalone, instead of
 * (or even as well as) just providing the support for a device implementation.
 *
 * <p>As with much of the technology in the Skin Kit, this API aims to
 * be both useful and demonstrative in its own right, but it is not
 * suitable for production use.
 */

#include "std.h"

/*
 * ********************************* Macros ***********************************
 */

#define MAX_DEPTH 64

/** \brief Tune this to decide whether compression should be applied to
 * new files created at run-time.
 *
 * See also the MFSSetCompression() function, which allows the caller to
 * decide whether to apply compression for individual files.
 */
#define COMPRESS_NEW_FILES TRUE

/*
 * ************************** Foward Declarations *****************************
 */

struct _MFSNODE;


/*
 * ******************************* Data Types *********************************
 */

/**
 * \brief A node within the filesystem is either a file or a directory,
 * and we use these markers to indicate which.
 *
 * \see MFSNODE
 */
enum
{
  MFS_File, /**< \brief Denotes an ordinary file. */
  MFS_Directory /**< \brief Denotes a directory. */
};

/**
 * \brief Describes a file.
 */
typedef struct _MFSFILE
{
  /** \brief The file's current meaningful extent. Do not confuse this
      with <code>cbCapacity</code>. */
  uint32               cbSize;
  /** \brief Pointer to the file's current uncompressed data buffer. */
  uint8               *pData;
  /** \brief The number of descriptors currently open for read access. */
  uint32               nReaders;
  /** \brief The number of descriptors currently open for write access. */
  uint32               nWriters;
  /** \brief Indicates whether <code>pData</code> points to runtime-allocated
      memory, and thus whether it should be freed when the buffer is grown
      or otherwise de-assigned. */
  uint32               fDynamicBuffer;
  /** \brief Indicates the capacity of the current buffer, which will be
      greater than or equal to <code>cbSize</code>. */
  uint32               cbCapacity;
  /** \brief Indicates whether the file is compressed. */
  uint32               fCompressed;
  /** \brief The compressed size of the file. */
  uint32               cbCompressedSize;
  /** \brief Indicates whether the compressed byte buffer is runtime-allocated,
      and thus whether it should be freed when the file is deleted. */
  uint32               fDynamicCompressedBuffer;
  /** \brief Pointer to the compressed data. */
  uint8               *pCompressedData;
  /** \brief Flag indicating that the file has been modified. */
  uint32               fModified;
} MFSFILE;

/**
 * \brief Describes a directory.
 */
typedef struct _MFSDIR
{
  /** \brief The number of array elements available in the entries array. */
  uint32               nEntries;
  /** \brief Pointer to the base of the entries array. One or more elements
      of the array may be <code>NULL</code>. */
  struct _MFSNODE    **entries;
  /** \brief Indicates whether <code>entries</code> points to runtime-allocated
      memory, and thus whether it should be freed when the array is grown
      or when the directory is deleted. */
  uint32               fDynamicList;
} MFSDIR;

/**
 * \brief Describes a node, which is a named entry within the filesystem, and
 * is either a file or a directory.
 *
 * <p>If this node is a file, then it is a leaf node. If it is a directory,
 * then it contains an array of pointers to the child <code>MFSNODE</code>s.
 *
 * <p>Nodes do \e not contain parent pointers.
 */
typedef struct _MFSNODE
{
  /** \brief Indicates whether this node is a file or a directory. */
  uint32               type;

  /** \brief Indicates whether this node (regardless of its type) should
      be locked against changes. */
  uint32               fReadOnly;

  /** \brief Determines whether this structure (and its pointer fields)
      refer to runtime-allocated memory, and thus whether they should be
      freed when this node is destroyed. */
  uint32               fDynamic;

  /** \brief The leaf name of this entry within the filesystem. */
  char                *pszName;

  /** \brief Pointer to the file, if this node is a file.
   *
   * <p>Only one of the <code>pFile</code> or <code>pDir</code> slots
   * is used in any one node. Conceptually, these two fields are a union.
   * We do not use a union, however, because unions are hard to initialize
   * statically. (The C standard dictates that only the first field of
   * a union may be statically initialized).
   */
  MFSFILE           *pFile;

  /** \brief Pointer to the directory, if this node is a directory.
   *
   * <p>Only one of the <code>pFile</code> or <code>pDir</code> slots
   * is used in any one node. Conceptually, these two fields are a union.
   * We do not use a union, however, because unions are hard to initialize
   * statically. (The C standard dictates that only the first field of
   * a union may be statically initialized).
   */
  MFSDIR            *pDir;

} MFSNODE;

/**
 * \brief Encapsulates the information required to control access to an
 * open file.
 */
typedef struct _MFSFILEDESC MFSFILEDESC;

/**
 * \brief Helper structure for storing the state of an iteration.
 */
typedef struct _MFSITERELEMENT
{
  MFSNODE             *pDirNode;
  uint32               index;
} MFSITERELEMENT;

/**
 * \brief Encapsulates the current state of an iteration.
 *
 * \see MFSIterBegin
 */
typedef struct _MFSITERSTATE
{
  MFSITERELEMENT       stack[ MAX_DEPTH ];
  uint32               depth;
  void                *pPrivate;
} MFSITERSTATE;


/*
 * ******************************* Functions ***********************************
 */


/**
 * \brief Locate a file node, relative to the given root, according to
 * its pathname.
 *
 * <p>This function may be called concurrently, even on shared
 * directory trees. However, it should not be called concurrently
 * with <code>MFSOpen()</code>, <code>MFSRename()</code> or
 * <code>MFSDelete()</code>, unless such concurrent calls are
 * operating on disjoint (sub-)trees, otherwise race conditions
 * result.
 *
 * \param pRoot The root of the search.
 *
 * \param pszFilename The pathname of the required file, expressed
 * relative to <code>pRoot</code>, and with forward-slash characters
 * separating the path elements.
 *
 * \param ppParent If the function succeeds, this output parameter
 * receives a pointer to the target node's parent node, which will
 * be of type <code>MFS_Directory</code>.
 *
 * \param pIndex If the function succeeds, this output parameter
 * receives the index of the target node within its parent directory's
 * child array.
 *
 * \return A pointer to the located node, or <code>NULL</code> if no matching
 * node was found. (This function never creates new nodes - you must use
 * <code>MFSOpen()</code> for that). If a pointer is returned, the node will
 * always be of type <code>MFS_File</code>.
 */
MFSNODE *MFSFindRelative
  ( MFSNODE *pRoot, char *pszFilename, MFSNODE **ppParent, uint32 *pIndex );

/**
 * \brief Open or create a file for reading and/or writing.
 *
 * <p>This function can be called concurrently, provided that all concurrent
 * calls are given disjoint (sub-)trees as the first argument. Similar
 * caveats apply with concurrent calls to <code>MFSDelete()</code>
 * and <code>MFSRename()</code>.
 *
 * \param pRoot Root of the file system or sub-tree. This may be any
 * directory node within the tree, as long as the filename is
 * expressed relative to it.
 *
 * \param pszFilename The pathname of the required file, expressed
 * relative to <code>pRoot</code>, and with forward-slash characters
 * separating the path elements.
 *
 * \param openFlags Specified as per the Core RIP Device Interface,
 * indicating the required level of access to the file. The Memory
 * File System allows concurrent read access, but write access is
 * always exclusive. This parameter can also indicate whether to create
 * a new file.
 *
 * \param ppDesc If the function succeeds, receives a pointer to the
 * file descriptor. This pointer must subsequently be passed into
 * all functions used to access the file while it is open. Ultimately,
 * the pointer must be passed to <code>MFSClose()</code> in order to
 * close the file.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return TRUE upon success; FALSE upon failure. Note that the
 * Core RIP Device Interfaces uses a different return convention
 * for the <code>open_file()</code> function. When implementing such
 * a function in terms of <code>MFSOpen()</code>, you must convert
 * TRUE to 0, and FALSE to -1 respectively.
 */
int32 MFSOpen
  ( MFSNODE *pRoot, char *pszFilename, int32 openFlags, MFSFILEDESC **ppDesc,
    int32 *err );

/**
 * \brief Close a file that was previously opened with <code>MFSOpen()</code>.
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>.
 *
 * \return TRUE upon success; FALSE upon failure. Note that the
 * Core RIP Device Interfaces uses a different return convention
 * for the <code>open_file()</code> function. When implementing such
 * a function in terms of <code>MFSOpen()</code>, you must convert
 * TRUE to 0, and FALSE to -1 respectively.
 */
int32 MFSClose( MFSFILEDESC *pDesc );

/**
 * \brief Return the underlying file from its open descriptor.
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>.
 *
 * \return The corresponding file within the virtual tree.
 */
MFSFILE *MFSGetFile( MFSFILEDESC *pDesc );

/**
 * \brief Read a specified number of bytes from the current location
 * of an open file.
 *
 * <p>This function has no side-effects on the underlying file. Therefore,
 * it is permissible to call this function concurrently for different
 * descriptors on the same file, but \e not with identical
 * descriptors.
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>. The file must have been opened
 * with read access: <code>SW_RDONLY</code> or <code>SW_RDWR</code>.
 *
 * \param buffer Pointer to caller-managed data buffer, which will
 * receive the bytes.
 *
 * \param cbLen The maximum number of bytes to read.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return The number of bytes actually read, which will not be greater
 * than <code>cbLen</code>, but which might be less. Returns zero if
 * the end of file has been reached. Returns -1 upon failure. This
 * return convention is directly compatible with <code>read_file</code>
 * in the Core RIP Device interface.
 */
int32 MFSRead( MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err );

/**
 * \brief Write a specified number of bytes to an open file at the
 * current location, expanding the file as necessary.
 *
 * <p>This function has side-effects on the underlying file. Therefore,
 * it is never permissible to call this function concurrently
 * with descriptors on the same file. It is also never permissible
 * to call <code>MFSRead()</code> concurrently with
 * <code>MFSWrite()</code> with descriptors on the same underlying
 * file.
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>. The file must have been opened
 * with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.
 *
 * \param buffer Pointer to caller-managed data buffer, from which
 * bytes will be copied into the file.
 *
 * \param cbLen The maximum number of bytes to write.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return The number of bytes actually written, which will not be greater
 * than <code>cbLen</code>, but which might be less. Returns -1 upon failure.
 * This return convention is directly compatible with <code>write_file</code>
 * in the Core RIP Device interface.
 */
int32 MFSWrite( MFSFILEDESC *pDesc, uint8 *buffer, int32 cbLen, int32 *err );

/**
 * \brief Write a specified NUL-terminated character string to an open
 * file at the current location, expanding the file as necessary. The terminating
 * NUL character itself is not written.
 *
 * <p>This function has side-effects on the underlying file. Therefore,
 * it is never permissible to call this function concurrently
 * with descriptors on the same file. It is also never permissible
 * to call <code>MFSRead()</code> or <code>MFSWrite()</code> concurrently with
 * <code>MFSWriteString()</code>, with descriptors on the same underlying
 * file.
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>. The file must have been opened
 * with write access: <code>SW_WRONLY</code> or <code>SW_RDWR</code>.
 *
 * \param pszString A pointer to caller-managed string memory. The string should
 * be NUL-terminated, and should be an ANSI or multi-byte encoded character
 * string.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return The number of bytes actually written, which will not be greater
 * than the length of the string <em>in bytes</em>, but which might be less.
 * Returns -1 upon failure. This return convention is directly compatible
 * with <code>write_file</code> in the Core RIP Device interface.
 */
int32 MFSWriteString( MFSFILEDESC *pDesc, char *pszString, int32 *err );

/**
 * \brief Set (or query) the current the position in an open file.
 *
 * <p>It is never permissible to call this function concurrently
 * with the same file descriptor. It \e is, however, permissible
 * to call the function concurrently with different descriptors
 * on the same underlying file, <em>provided that there are no
 * open descriptors with write access on the file.</em>
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code> (with any level of access).
 *
 * \param pDestination Specifies the file pointer adjustment, and receives
 * the absolute file position if the function returns successfully.
 *
 * \param flags One of <code>SW_SET</code>, <code>SW_INCR</code> or
 * <code>SW_XTND</code>, as per the Core RIP Device Interface. This
 * determines how the <code>pDestination</code> argument is treated
 * on entry. However, the updated <code>pDestination</code> is always
 * an absolute file pointer on exit. To query the current file pointer
 * without modifying it, use <code>SW_INCR</code> and supply
 * a pointer to a <em>zero-valued</em> <code>Hq32x2</code> (note
 * that this <em>does not</em> mean a NULL pointer).
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 * 
 * \return TRUE upon success, in which case <code>pDestination</code> is
 * updated with the current file pointer. FALSE upon failure, in
 * which case <code>pDestination</code> is not updated. This
 * return convention is directly compatible with <code>seek_file</code>
 * in the Core RIP Device Interface
 */
int32 MFSSeek( MFSFILEDESC *pDesc, Hq32x2 *pDestination, int32 flags, int32 *err );

/**
 * \brief Determine the number of bytes that are currently available
 * to be read from an open file.
 *
 * <p>It is never permissible to call this function concurrently
 * with the same descriptor. It \e is, however, permissible
 * to call the function concurrently with different descriptors
 * on the same underlying file, <em>provided that there are no
 * open descriptors with write access on the file.</em>
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to <code>MFSOpen()</code>.
 *
 * \param pAvail Receives a count of available bytes upon
 * successful return.
 *
 * \param reasonFlag One of <code>SW_BYTES_AVAIL_REL</code> or
 * <code>SW_BYTES_TOTAL_ABS</code>, as per the Core RIP Device
 * Interface. Since files are stored in memory, the maximum extent of
 * the data is always known, so precise information can be returned
 * in both cases.
 *
 * \return TRUE upon success; FALSE upon failure. This return convention
 * is directly compatible with <code>bytes_file</code> in the
 * Core RIP Device Interface.
 */
int32 MFSAvail( MFSFILEDESC *pDesc, Hq32x2 *pAvail, int32 reasonFlag );

/**
 * \brief Controls whether the file's data buffer will be compressed
 * (or re-compressed) when the file is closed.
 *
 * This function can only be called when the file's data buffer is
 * currently in an uncompressed state. This will be the case if the
 * file was opened for writing, or for random-access reading.
 * In other cases, it is less certain.
 *
 * Normally, when a file is closed, its data buffer is retained in a
 * compressed state to save on memory usage. There might be cases where
 * this is undesirable. For instance, if a large file is opened and
 * closed many times in rapid succession, a runtime expense will be
 * incurred in decompression (and re-compression) of the data.
 * The caller might use this function to de-activate the compression
 * for periods of such activity. The caller might also use this function
 * when storing data that has already been compressed, in which case
 * there is little point in trying to compress it again.
 *
 * The most typical use of this function is immediately after creation
 * of a \e new file with \c MFSOpen().
 *
 * \param pDesc A pointer to the file descriptor, obtained from an
 * earlier call to \c MFSOpen().
 *
 * \param fCompress Supply \c TRUE to indicate that the file buffer should
 * be compressed when the file is closed, or \c FALSE to indicate that
 * it shouldn't.
 *
 * \return \c TRUE if the function succeeds, otherwise \c FALSE.
 */
int32 MFSSetCompression( MFSFILEDESC *pDesc, uint32 fCompress );

/**
 * \brief Delete a file or directory, and completely release all of its
 * associated memory resources.
 *
 * <p>This function can be used to delete a single file, or to \e recursively
 * delete a directory and all of its descendants, regardless of their
 * contents. If you consider this function as being like the UNIX
 * <code>rm</code> command, then there is an implicit
 * <code>-rf</code>.
 *
 * <p>This function will fail if the specified file is currently open
 * with any level of access. In the recursive case, the function will
 * similarly fail if any open files are included amongst the
 * directory's descendants.
 *
 * <p>It is permissible to call this function concurrently, provided
 * that all concurrent calls are given disjoint (sub-)trees as
 * the first argument.
 *
 * \param pRoot Root of the file system or sub-tree. This can be any
 * directory node, as long as the filename is expressed relative to it.
 *
 * \param pszFilename The pathname of the required file or directory, expressed
 * relative to <code>pRoot</code>, and with forward-slash characters
 * separating the path elements.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return Zero on success, -1 on failure. This return convention is
 * directly compatible with <code>delete_file</code> in the Core RIP
 * Device Interface.
 */
int32 MFSDelete( MFSNODE *pRoot, char *pszFilename, int32 *err );

/**
 * \brief Rename a file, preserving all of its contents and other
 * properties.
 *
 * <p>It is permissible to call this function concurrently, provided
 * that all concurrent calls are given disjoint (sub-)trees as
 * the first argument.
 *
 * \param pRoot Root of the file system or sub-tree. This can be any
 * directory node, as long as the filenames are expressed relative to it.
 *
 * \param pszFromName The pathname of the source file, expressed
 * relative to <code>pRoot</code>, and with forward-slash characters
 * separating the path elements. The function will fail if this
 * pathname designates a file that is currently open with any level
 * of access. The function will also fail if this pathname does not
 * exist, or if it designates a directory.
 *
 * \param pszToName The pathname of the destination file, expressed
 * relative to <code>pRoot</code>, and with forward-slash characters
 * separating the path elements. If this pathname denotes any file or
 * directory that already exists, the function will fail.
 *
 * \param err Pointer to an integer error code, specified according to
 * the Core RIP Device Interface. If the function fails, this will
 * receive the appropriate device error code.
 *
 * \return Zero on success, -1 on failure. This return convention is
 * directly compatible with <code>delete_file</code> in the Core RIP
 * Device Interface.
 */
int32 MFSRename( MFSNODE *pRoot, char* pszFromName, char *pszToName, int32 *err );

/**
 * \brief Begin an iteration over all or part of the file system.
 *
 * <p>This function can be used to visit \e file nodes beneath
 * the given directory. The iteration will recursively enter all
 * nested directories, but the directories themselves are not
 * visited as an explicit iteration step.
 *
 * <p>The function returns a pointer to an internally-allocated
 * <code>MFSITERSTATE</code> structure, which maintains information
 * about the current iteration state. This structure is initialized
 * at a notional position \e before the first file. To visit
 * the first file, you must make an initial call to
 * <code>MFSIterNext()</code>, and so on to visit subsequent files.
 *
 * <p>At each iteration step, you can call <code>MFSIterNameLength()</code>
 * and <code>MFSIterName()</code> to obtain the pathname of the current
 * file, expressed relative to <code>pRoot</code>. You can also
 * call <code>MFSIterNode()</code> to obtain a direct pointer to the
 * current file node.
 *
 * <p>To avoid resource leaks, all calls to <code>MFSIterBegin()</code> must
 * be matched by a later call to <code>MFSIterEnd()</code>.
 *
 * <p>The following code fragment demonstrates the basic call pattern
 * for iteration.
 *
  \verbatim
  {
     char filename[ MAXFILENAMELENGTH ];
     MFSITERSTATE *pState = MFSIterBegin( pRoot, NULL );
     while ( MFSIterNext( pState ) )
     {
       if ( MFSIterName( pState, filename, sizeof( filename ), TRUE ) )
         printf( "Visiting %s\n", filename );
       else
         printf( "<Filename too long>\n" );
     }
     MFSIterEnd( pState );
  } 
  \endverbatim
 *
 * <p>Backwards iteration is not supported, and no assumption should
 * be made that files are visited in any particular order, such as
 * alphabetical order.
 *
 * <p>It is legal to call <code>MFSDelete()</code> on the current file
 * during iteration. It is also legal to call <code>MFSRename()</code>,
 * although it is then undefined whether the destination file will
 * then be visited later in the iteration.
 *
 * <p>The iteration function can be used to support an implementation
 * of the <code>start_file_list</code> and <code>next_file</code>
 * functions in the Core RIP Device Interface.
 *
 * <p>In general, iteration functions may be called concurrently, provided
 * that they are "separate" iterations - that is, using different
 * <code>MFSITERSTATE</code> structures.
 *
 * \param pRoot Root of the file system, or directory sub-tree to be
 * traversed.
 *
 * \param pPrivate Arbitrary pointer to caller-managed memory. This
 * pointer will be installed into the <code>pPrivate</code> field of
 * the <code>MFSITERSTATE</code> structure.
 *
 * \return Pointer to an internally-managed data structure. This pointer
 * remains legal until it is passed into <code>MFSIterEnd()</code>.
 */
MFSITERSTATE *MFSIterBegin( MFSNODE *pRoot, void *pPrivate );

/**
 * \brief Proceed to the first (or next) file in an iteration sequence.
 *
 * <p>For more information, see <code>MFSIterBegin()</code>.
 *
 * \param pState The current iteration state, as previously obtained
 * from a call to <code>MFSIterBegin()</code>.
 *
 * \return TRUE if the iteration has proceeded; FALSE if the iteration
 * has been exhausted.
 */
int32 MFSIterNext( MFSITERSTATE *pState );

/**
 * \brief Close an iteration sequence.
 *
 * <p>For more information, see <code>MFSIterBegin()</code>.
 *
 * \param pState The current iteration state, as previously obtained
 * from a call to <code>MFSIterBegin()</code>. This pointer becomes
 * invalid upon return.
 */
void MFSIterEnd( MFSITERSTATE *pState );

/**
 * \brief Obtain a direct pointer to the <code>MFS_File</code> node
 * of the current iteration step.
 *
 * <p>For more information, see <code>MFSIterBegin()</code>.
 *
 * \param pState The current iteration state, as previously obtained
 * from a call to <code>MFSIterBegin()</code>.
 */
MFSNODE *MFSIterNode( MFSITERSTATE *pState );

/**
 * \brief Obtain the pathname length of the file at the current
 * iteration step.
 *
 * <p>For more information, see <code>MFSIterBegin()</code>.
 *
 * \param pState The current iteration state, as previously obtained
 * from a call to <code>MFSIterBegin()</code>.
 *
 * \param fLeadingSlash Flag indicating whether a leading slash
 * should be taken into account when computing the filename.
 * This will just increase the returned value by 1 character, but
 * the parameterization is in order to be consistent with
 * <code>MFSIterName()</code>.
 *
 * \return The number of 8-bit characters, including a NUL terminator
 * and all separating characters, required to store the pathname of
 * the current file.
 */
uint32 MFSIterNameLength( MFSITERSTATE *pState, uint32 fLeadingSlash );

/**
 * \brief Obtain the pathname of the file at the current iteration
 * step.
 *
 * <p>For more information, see <code>MFSIterBegin()</code>.
 *
 * \param pState The current iteration state, as previously obtained
 * from a call to <code>MFSIterBegin()</code>.
 *
 * \param pszFilenameBuf A pointer to caller-managed memory, which will
 * receive the pathname. The pathname will be expressed relative
 * to the directory that was specified to <code>MFSIterBegin()</code>,
 * and will use forward-slash characters as path separators. A leading
 * foward-slash and a terminating NUL character are included.
 *
 * \param bufLen The number of bytes available in the buffer. If this
 * does not accommodate the pathname (including its NUL terminator),
 * the function will fail, and no bytes will be written into the
 * buffer. Use <code>MFSIterNameLength()</code> to obtain the
 * required buffer length, and remember to use the same value for
 * <code>fLeadingSlash</code>.
 *
 * \param fLeadingSlash Flag indicating whether a leading slash should
 * be included in the name.
 *
 * \return TRUE upon success; FALSE upon failure.
 */
int32 MFSIterName
  ( MFSITERSTATE *pState, char *pszFilenameBuf, uint32 bufLen, uint32 fLeadingSlash );

/**
 * \brief Construct and return a completely new root directory node.
 *
 * Use \c MFSReleaseRoot() to destroy this root and the entire
 * virtual filesystem descended from it.
 *
 * \c MFSNewRoot() and \c MFSCopyTree() are the only two
 * functions that can be used to create a completely fresh virtual
 * filesystem tree. All other functions operate on nodes that are already
 * linked into an existing tree.
 *
 * The directory node returned by this function is stand-alone, and completely
 * unlinked from any existing virtual filesystems being managed by MFS.
 *
 * \param pszRootName The identifier to use for the root node, since all nodes
 * must have a name. Note that this name <em>does not</em> form a part
 * of any path relative to this root.
 *
 * \return A new node, whose type will be <code>MFS_Directory</code>, or
 * <code>NULL</code> if there has been a failure to allocate the necessary
 * memory.
 */
MFSNODE *MFSNewRoot( char *pszRootName );

/**
 * \brief Construct and return a completely new filesystem tree by
 * making a recursive copy of the given tree.
 *
 * Use \c MFSReleaseRoot() to recursively destroy the copy when it is
 * no longer needed.
 *
 * \c MFSNewRoot() and \c MFSCopyTree() are the only two
 * functions that can be used to create a completely fresh virtual
 * filesystem tree. All other functions operate on nodes that are already
 * linked into an existing tree.
 *
 * The directory node returned by this function is stand-alone, and completely
 * unlinked from any existing virtual filesystems being managed by MFS.
 *
 * \param pMFSRoot Pointer to the root of the tree to be copied.
 *
 * \param fCopyFileData Controls whether the underlying file data buffers
 * are copied into the new tree. If you pass \c TRUE, then fresh copies
 * of the file data will be made in the new tree. Otherwise, the underlying
 * file data will be shared by the new tree and the original tree.
 * Sharing the file data will use less memory, but it means that modifications
 * to files in the new tree can potentially have side-effects on
 * the files in the original tree.
 *
 * \return If the function succeeds, the return value is a pointer to
 * a newly-allocated filesystem tree whose shape and contents exactly
 * match the original tree. Every directory and file that exists in
 * the original tree will also exist in the new tree. The files will
 * also contain the same data, which will either be a copy of the
 * original, or a duplicated pointer to memory shared with the original,
 * depending on the value of \c fCopyFileData. If the function fails, the
 * return value is \c NULL, which is best interpreted as being due to memory
 * exhaustion.
 */
MFSNODE *MFSCopyTree( MFSNODE *pMFSRoot, uint32 fCopyFileData );

/**
 * \brief Destroy the given root node, and the entire virtual filesystem
 * descended from it.
 *
 * \param pMFSRoot The root node, which must have previously been allocated
 * with either \c MFSNewRoot() or \c MFSCopyTree(). \e Never call
 * <code>MFSReleaseRoot()</code> with a non-root node from within another
 * virtual filesystem. Use <code>MFSDelete()</code> instead.
 */
void MFSReleaseRoot( MFSNODE *pMFSRoot );

/**
 * \brief Calculate the amount of memory currently in use by the virtual
 * filesystem descended from the given node.
 *
 * This function recursively walks over the tree, and totals up the file
 * data buffer space being used. The result is approximate, since the
 * memory consumption of MFS internal data structures is not included, but
 * this is generally small in comparison with the actual file data.
 *
 * The function produces separate totals for ROM consumption and RAM
 * consumption. ROM consumption extends to initial file data that was
 * imported from an external source and embedded in the compiled
 * binaries. RAM consumption extends to all further space that was
 * allocated at runtime. RAM consumption will tend to fluctuate with
 * usage of the filesystem, whereas ROM consumption is fixed (effectively
 * at application link time).
 *
 * \param pNode Root node of the virtual filesystem to be examined. This
 * is allowed to be \c NULL, in which case the function does nothing.
 *
 * \param pROMSize This number is increased by the number of bytes of
 * ROM being consumed by the filesystem. The caller should initialize this
 * to zero to obtain a total for just the given node. There is no handling
 * for overflow. If files have been deleted from the tree, their ROM
 * consumption is no longer included by this function, although the
 * memory is effectively "leaked" and cannot be recovered. (RAM space,
 * by comparison, is never leaked).
 *
 * \param pRAMSize This number is increased by the number of bytes of
 * dynamic heap memory being consumed by the filesystem. The caller should
 * initialize this to zero to obtain a total for just the given node. There
 * is no handling for overflow.
 */
void MFSMemUsage( MFSNODE *pNode, uint32 *pROMSize, uint32 *pRAMSize );

#endif

