/*
 * Copyright (C) 2007-12 Global Graphics Software Ltd.  All rights reserved.
 *
 * This example is provided on an "as is" basis and without
 * warranty of any kind. Global Graphics Software Ltd. does not
 * warrant or make any representations regarding the use or results
 * of use of this example.
 *
 * $HopeName: SWskinkit!src:handshake_ebdeval_linux.c(EBDSDK_P.1) $
 *
 * Created automatically with SWprod_lesec_dll v2.0
 * DO NOT EDIT THIS FILE, RE-GENERATE IT INSTEAD.
 */

/**
 * Customer:  0x63
 * Platform:  0x87
 * Version:   35
 * Res limit: 2400
 * Passwords: 1SWROZZA7 1SWROZZA8 1SWROZZAV 1SWROZZAW 
 */

/**
 * @file
 *
 * @brief Implementation of security handshake.
 */


#include "handshake.h"
#include "mem.h"

#define MAX_HANDSHAKE_LEN 64

static void RIPCALL SecHandshake( SwSecHandshakeStruct * pParam );

static uint32 T[65] = {
    0x0u,
    0xd76aa478u,    0xe8c7b756u,    0x242070dbu,    0xc1bdceeeu,
    0xf57c0fafu,    0x4787c62au,    0xa8304613u,    0xfd469501u,
    0x698098d8u,    0x8b44f7afu,    0xffff5bb1u,    0x895cd7beu,
    0x6b901122u,    0xfd987193u,    0xa679438eu,    0x49b40821u,
    0xf61e2562u,    0xc040b340u,    0x265e5a51u,    0xe9b6c7aau,
    0xd62f105du,    0x02441453u,    0xd8a1e681u,    0xe7d3fbc8u,
    0x21e1cde6u,    0xc33707d6u,    0xf4d50d87u,    0x455a14edu,
    0xa9e3e905u,    0xfcefa3f8u,    0x676f02d9u,    0x8d2a4c8au,
    0xfffa3942u,    0x8771f681u,    0x6d9d6122u,    0xfde5380cu,
    0xa4beea44u,    0x4bdecfa9u,    0xf6bb4b60u,    0xbebfbc70u,
    0x289b7ec6u,    0xeaa127fau,    0xd4ef3085u,    0x04881d05u,
    0xd9d4d039u,    0xe6db99e5u,    0x1fa27cf8u,    0xc4ac5665u,
    0xf4292244u,    0x432aff97u,    0xab9423a7u,    0xfc93a039u,
    0x655b59c3u,    0x8f0ccc92u,    0xffeff47du,    0x85845dd1u,
    0x6fa87e4fu,    0xfe2ce6e0u,    0xa3014314u,    0x4e0811a1u,
    0xf7537e82u,    0xbd3af235u,    0x2ad7d2bbu,    0xeb86d391u
};

static uint32 md5round1(uint32 a, uint32 b, uint32 c, uint32 d,
	      uint32 Xk, uint32 Ti, uint8 s)
{
    a += (b & c) | (~b & d) ;
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

static uint32 md5round2(uint32 a, uint32 b, uint32 c, uint32 d,
	      uint32 Xk, uint32 Ti, uint8 s)
{
    a += (b & d) | (c & ~d) ;
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

static uint32 md5round3(uint32 a, uint32 b, uint32 c, uint32 d,
	      uint32 Xk, uint32 Ti, uint8 s)
{
    a += b ^ c ^ d ;
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

static uint32 md5round4(uint32 a, uint32 b, uint32 c, uint32 d,
	      uint32 Xk, uint32 Ti, uint8 s)
{
    a += c ^ (b | ~d) ;
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

static void md5(uint8 *in, uint32 len, uint8 out[16])
{
    uint32 last_block ;
    uint8 i ;
    uint32 X[16], chars_remaining = len ;
    uint8 buf[64], *p, pad = 0x80u ;
    uint32 AA, A = 0x67452301u ;
    uint32 BB, B = 0xefcdab89u ;
    uint32 CC, C = 0x98badcfeu ;
    uint32 DD, D = 0x10325476u ;

    do { 
        last_block = chars_remaining <= 55 ;

        for ( i = 0 ; i < 64 ; i++ ) {
            if (chars_remaining) {
                buf[i] = *in++ ;
                chars_remaining-- ;
            }
            else {
                buf[i] = pad ;
                pad = 0x00 ;
            }
        }
        if (last_block) {
            len <<= 3 ;
            buf[56] = (uint8)(len >>  0) ;
            buf[57] = (uint8)(len >>  8) ;
            buf[58] = (uint8)(len >> 16) ;
            buf[59] = (uint8)(len >> 24) ;
        }

        p = buf ;
        for ( i = 0 ; i < 16 ; i++ ) {
            X[i] = *(p) | *(p+1) << 8 | *(p+2) << 16 | *(p+3) << 24 ;
            p += 4;
        }

        AA = A ;
        BB = B ;
        CC = C ;
        DD = D ;

        A = md5round1(A, B, C, D, X[ 0], T[ 1],  7) ;
        D = md5round1(D, A, B, C, X[ 1], T[ 2], 12) ;
        C = md5round1(C, D, A, B, X[ 2], T[ 3], 17) ;
        B = md5round1(B, C, D, A, X[ 3], T[ 4], 22) ;

        A = md5round1(A, B, C, D, X[ 4], T[ 5],  7) ;
        D = md5round1(D, A, B, C, X[ 5], T[ 6], 12) ;
        C = md5round1(C, D, A, B, X[ 6], T[ 7], 17) ;
        B = md5round1(B, C, D, A, X[ 7], T[ 8], 22) ;

        A = md5round1(A, B, C, D, X[ 8], T[ 9],  7) ;
        D = md5round1(D, A, B, C, X[ 9], T[10], 12) ;
        C = md5round1(C, D, A, B, X[10], T[11], 17) ;
        B = md5round1(B, C, D, A, X[11], T[12], 22) ;

        A = md5round1(A, B, C, D, X[12], T[13],  7) ;
        D = md5round1(D, A, B, C, X[13], T[14], 12) ;
        C = md5round1(C, D, A, B, X[14], T[15], 17) ;
        B = md5round1(B, C, D, A, X[15], T[16], 22) ;

        A = md5round2(A, B, C, D, X[ 1], T[17],  5) ;
        D = md5round2(D, A, B, C, X[ 6], T[18],  9) ;
        C = md5round2(C, D, A, B, X[11], T[19], 14) ;
        B = md5round2(B, C, D, A, X[ 0], T[20], 20) ;

        A = md5round2(A, B, C, D, X[ 5], T[21],  5) ;
        D = md5round2(D, A, B, C, X[10], T[22],  9) ;
        C = md5round2(C, D, A, B, X[15], T[23], 14) ;
        B = md5round2(B, C, D, A, X[ 4], T[24], 20) ;

        A = md5round2(A, B, C, D, X[ 9], T[25],  5) ;
        D = md5round2(D, A, B, C, X[14], T[26],  9) ;
        C = md5round2(C, D, A, B, X[ 3], T[27], 14) ;
        B = md5round2(B, C, D, A, X[ 8], T[28], 20) ;

        A = md5round2(A, B, C, D, X[13], T[29],  5) ;
        D = md5round2(D, A, B, C, X[ 2], T[30],  9) ;
        C = md5round2(C, D, A, B, X[ 7], T[31], 14) ;
        B = md5round2(B, C, D, A, X[12], T[32], 20) ;

        A = md5round3(A, B, C, D, X[ 5], T[33],  4) ;
        D = md5round3(D, A, B, C, X[ 8], T[34], 11) ;
        C = md5round3(C, D, A, B, X[11], T[35], 16) ;
        B = md5round3(B, C, D, A, X[14], T[36], 23) ;

        A = md5round3(A, B, C, D, X[ 1], T[37],  4) ;
        D = md5round3(D, A, B, C, X[ 4], T[38], 11) ;
        C = md5round3(C, D, A, B, X[ 7], T[39], 16) ;
        B = md5round3(B, C, D, A, X[10], T[40], 23) ;

        A = md5round3(A, B, C, D, X[13], T[41],  4) ;
        D = md5round3(D, A, B, C, X[ 0], T[42], 11) ;
        C = md5round3(C, D, A, B, X[ 3], T[43], 16) ;
        B = md5round3(B, C, D, A, X[ 6], T[44], 23) ;

        A = md5round3(A, B, C, D, X[ 9], T[45],  4) ;
        D = md5round3(D, A, B, C, X[12], T[46], 11) ;
        C = md5round3(C, D, A, B, X[15], T[47], 16) ;
        B = md5round3(B, C, D, A, X[ 2], T[48], 23) ;

        A = md5round4(A, B, C, D, X[ 0], T[49],  6) ;
        D = md5round4(D, A, B, C, X[ 7], T[50], 10) ;
        C = md5round4(C, D, A, B, X[14], T[51], 15) ;
        B = md5round4(B, C, D, A, X[ 5], T[52], 21) ;

        A = md5round4(A, B, C, D, X[12], T[53],  6) ;
        D = md5round4(D, A, B, C, X[ 3], T[54], 10) ;
        C = md5round4(C, D, A, B, X[10], T[55], 15) ;
        B = md5round4(B, C, D, A, X[ 1], T[56], 21) ;

        A = md5round4(A, B, C, D, X[ 8], T[57],  6) ;
        D = md5round4(D, A, B, C, X[15], T[58], 10) ;
        C = md5round4(C, D, A, B, X[ 6], T[59], 15) ;
        B = md5round4(B, C, D, A, X[13], T[60], 21) ;

        A = md5round4(A, B, C, D, X[ 4], T[61],  6) ;
        D = md5round4(D, A, B, C, X[11], T[62], 10) ;
        C = md5round4(C, D, A, B, X[ 2], T[63], 15) ;
        B = md5round4(B, C, D, A, X[ 9], T[64], 21) ;

        A += AA;
        B += BB;
        C += CC;
        D += DD;

    } while (!last_block) ;

    out[0x0] = (uint8)(A >>  0) ;
    out[0x1] = (uint8)(A >>  8) ;
    out[0x2] = (uint8)(A >> 16) ;
    out[0x3] = (uint8)(A >> 24) ;

    out[0x4] = (uint8)(B >>  0) ;
    out[0x5] = (uint8)(B >>  8) ;
    out[0x6] = (uint8)(B >> 16) ;
    out[0x7] = (uint8)(B >> 24) ;

    out[0x8] = (uint8)(C >>  0) ;
    out[0x9] = (uint8)(C >>  8) ;
    out[0xa] = (uint8)(C >> 16) ;
    out[0xb] = (uint8)(C >> 24) ;

    out[0xc] = (uint8)(D >>  0) ;
    out[0xd] = (uint8)(D >>  8) ;
    out[0xe] = (uint8)(D >> 16) ;
    out[0xf] = (uint8)(D >> 24) ;
}

static void RIPCALL SecHandshake( SwSecHandshakeStruct * pParam )
{
  static uint8 data[] = {
    0xB9, 0x54, 0xBC, 0x5C, 0x37, 0x93, 0x0C, 0x46,
    0xE5, 0x28, 0x62, 0xBF, 0x23, 0x02, 0xC9, 0xB4
  };

  uint32  i;
  uint8   scratch[ MAX_HANDSHAKE_LEN ];

  for( i = 0; i < pParam->nLength; i++ )
  {
    scratch[ i ] = pParam->pIn[ i ] ^ data[ i % sizeof( data ) ];
  }

  md5( scratch, pParam->nLength, pParam->pOut );
}


void SecInit( SwSecInitStruct * pParam )
{
  static uint8 data[] = {
    0x80, 0x3B, 0x6B, 0x67, 0x68, 0x02, 0x9E, 0x9C,
    0xAE, 0x87, 0x86, 0xB6, 0x03, 0x27, 0x29, 0x26,
    0xE4, 0x81, 0xC2, 0x85, 0xAB, 0x92, 0x4C, 0x57,
    0xC2, 0xCA, 0x2B, 0xFE, 0x70, 0x43, 0xF5, 0x5B,
    0xC5, 0x81, 0x3B, 0x4A, 0xF4, 0x13, 0x64, 0x36,
    0x97, 0x47, 0xDC, 0x5A, 0xC9, 0xFB, 0x5D, 0xD4,
    0x74, 0xC8, 0x8F, 0xF3, 0xED, 0x83, 0x32, 0xC0,
    0x24, 0xA6, 0x13, 0x39, 0x3D, 0x1C, 0x40, 0xBA,
    0x78, 0x24, 0xD7, 0x71, 0x04, 0x45, 0xDF, 0xD1,
    0xDA, 0xEB, 0xE3, 0xB9, 0x46, 0xA4, 0x36, 0x9D
  };

  pParam->oemID = 0x63;
  pParam->dataLen = sizeof( data );
  pParam->pData = data;
  pParam->handshakeFn = SecHandshake;
}


/* eof */
