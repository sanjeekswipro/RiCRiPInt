/* Copyright (C) 2007 Global Graphics Software Ltd. All rights reserved. */
/* Global Graphics Software Ltd. Confidential Information. */
/* $HopeName: HQNmd5!src:md5.c(EBDSDK_P.1) $
 *
* Log stripped */


/* ----------------------------------------------------------------------------
   file:                MD5               author:              Paul Bramall
   creation date:       14-Jul-1997       last modification:   ##-###-####
   
   description:
   For calculating MD5 checksums.

---------------------------------------------------------------------------- */
#include "std.h"

#include "md5.h"

/* The contents of the following table was generated by this Perl
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * for ($i = 1; $i <= 64; $i++) {
 *     printf("    0x%08xu,", int(4294967296 * abs(sin($i))));
 *     print "\n" if $i % 4 == 0;
 * }
 */

STATIC uint32 T[65] = {
    0x0u, /* Only really 64 elements, this pad makes the code look like the spec */
    0xd76aa478u,    0xe8c7b756u,    0x242070dbu,    0xc1bdceeeu,
    0xf57c0fafu,    0x4787c62au,    0xa8304613u,    0xfd469501u,
    0x698098d8u,    0x8b44f7afu,    0xffff5bb1u,    0x895cd7beu,
    0x6b901122u,    0xfd987193u,    0xa679438eu,    0x49b40821u,
    0xf61e2562u,    0xc040b340u,    0x265e5a51u,    0xe9b6c7aau,
    0xd62f105du,    0x02441453u,    0xd8a1e681u,    0xe7d3fbc8u,
    0x21e1cde6u,    0xc33707d6u,    0xf4d50d87u,    0x455a14edu,
    0xa9e3e905u,    0xfcefa3f8u,    0x676f02d9u,    0x8d2a4c8au,
    0xfffa3942u,    0x8771f681u,    0x6d9d6122u,    0xfde5380cu,
    0xa4beea44u,    0x4bdecfa9u,    0xf6bb4b60u,    0xbebfbc70u,
    0x289b7ec6u,    0xeaa127fau,    0xd4ef3085u,    0x04881d05u,
    0xd9d4d039u,    0xe6db99e5u,    0x1fa27cf8u,    0xc4ac5665u,
    0xf4292244u,    0x432aff97u,    0xab9423a7u,    0xfc93a039u,
    0x655b59c3u,    0x8f0ccc92u,    0xffeff47du,    0x85845dd1u,
    0x6fa87e4fu,    0xfe2ce6e0u,    0xa3014314u,    0x4e0811a1u,
    0xf7537e82u,    0xbd3af235u,    0x2ad7d2bbu,    0xeb86d391u
};

/* The following four functions are the clever bit of MD5.  They are
 * identical except for their first lines.
 */

STATIC uint32 md5round1(uint32 a, uint32 b, uint32 c, uint32 d,
          uint32 Xk, uint32 Ti, uint8 s)
{
    a += (b & c) | (~b & d) ;  /* Auxiliary FN "F" from the md5 spec */
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

STATIC uint32 md5round2(uint32 a, uint32 b, uint32 c, uint32 d,
          uint32 Xk, uint32 Ti, uint8 s)
{
    a += (b & d) | (c & ~d) ;  /* Auxiliary FN "G" from the md5 spec */
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

STATIC uint32 md5round3(uint32 a, uint32 b, uint32 c, uint32 d,
          uint32 Xk, uint32 Ti, uint8 s)
{
    a += b ^ c ^ d ;	      /* Auxiliary FN "H" from the md5 spec */
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}

STATIC uint32 md5round4(uint32 a, uint32 b, uint32 c, uint32 d,
          uint32 Xk, uint32 Ti, uint8 s)
{
    a += c ^ (b | ~d) ;	      /* Auxiliary FN "I" from the md5 spec */
    a += Xk + Ti ;
    return(((a << s) | (a >> (32 - s))) + b) ;
}


/* This function will calculate an MD5 progressively so that the data does
 * not all have to be made available to it at once.
 *
 * After the first time it is called the MD5 so far will be in the out
 * buffer.  On subsequent times of calling this should be passed back in
 * via the out buffer.
 *
 * The first time it is called first_data must be set to TRUE.
 * The final time it is called last_data must be set to TRUE.
 * All other times, first_data and last_data must be set to FALSE.
 * The whole calculation may be done at once by setting both
 * first_data and last_data to TRUE.
 * 
 * Each time it is called len must be set to the length of the current in
 * buffer.  Apart from the last (or only) time it is called len must be a
 * multiple of 64 bytes.
 *
 * The last time it is called total_len is used.  It should be set to the
 * total length of the data passed in all the calls.
 */
void md5_progressive(uint8* in,
                     uint32 len,
                     uint8  out[MD5_OUTPUT_LEN],
                     uint32 total_len,
                     uint32 first_data,
                     uint32 last_data)
{
    uint32 last_block, done;
    uint8 i ;
    uint32 X[16], chars_remaining = len ;
    uint8 buf[64], *p, pad = 0x80u ; /* First pad character has high bit set. */

    uint32 AA, A ;
    uint32 BB, B ;
    uint32 CC, C ;
    uint32 DD, D ;

    HQASSERT ( in  , "Null input buffer for MD5" ) ;
    HQASSERT ( out , "Null output buffer for MD5" ) ;
    HQASSERT ( last_data || len % 64 == 0,
               "MD5 data length should be divisible by 64" );

    /* Initialisation of A, B, C & D */
    if (first_data) {
      /* these numbers come from the md5 spec. */
      A = 0x67452301u ;
      B = 0xefcdab89u ;
      C = 0x98badcfeu ;
      D = 0x10325476u ;
    }
    else {
      A = out[0x0] | (out[0x1] << 8) | (out[0x2] << 16 ) | ( out[0x3] << 24) ;
      B = out[0x4] | (out[0x5] << 8) | (out[0x6] << 16 ) | ( out[0x7] << 24) ;
      C = out[0x8] | (out[0x9] << 8) | (out[0xa] << 16 ) | ( out[0xb] << 24) ;
      D = out[0xc] | (out[0xd] << 8) | (out[0xe] << 16 ) | ( out[0xf] << 24) ;
    }

    do {
        last_block = chars_remaining <= 55 ; /* 9 bytes needed at the end of
                                              * the data block.  55 + 9 = 64 */

        done = !last_data ? chars_remaining <= 64 : last_block ;

        for ( i = 0 ; i < 64 ; i++ ) {
            if (chars_remaining) {
                buf[i] = *in++ ;
                chars_remaining-- ;
            }
            else {
                buf[i] = pad ;
                pad = 0x00 ;    /* Subsequent padding is with zeros */
            }
        }
        if (last_block && last_data) {
            total_len <<= 3 ;  /* Convert length in bits, to length in bytes */
            buf[56] = (uint8)(total_len >>  0) ;
            buf[57] = (uint8)(total_len >>  8) ;
            buf[58] = (uint8)(total_len >> 16) ;
            buf[59] = (uint8)(total_len >> 24) ;
        }

        p = buf ;
        for ( i = 0 ; i < 16 ; i++ ) {
            X[i] = *(p) | *(p+1) << 8 | *(p+2) << 16 | *(p+3) << 24 ;
            p += 4;
        }

        AA = A ;
        BB = B ;
        CC = C ;
        DD = D ;
                            /* ROUND 1 */
        A = md5round1(A, B, C, D, X[ 0], T[ 1],  7) ;
        D = md5round1(D, A, B, C, X[ 1], T[ 2], 12) ;
        C = md5round1(C, D, A, B, X[ 2], T[ 3], 17) ;
        B = md5round1(B, C, D, A, X[ 3], T[ 4], 22) ;

        A = md5round1(A, B, C, D, X[ 4], T[ 5],  7) ;
        D = md5round1(D, A, B, C, X[ 5], T[ 6], 12) ;
        C = md5round1(C, D, A, B, X[ 6], T[ 7], 17) ;
        B = md5round1(B, C, D, A, X[ 7], T[ 8], 22) ;

        A = md5round1(A, B, C, D, X[ 8], T[ 9],  7) ;
        D = md5round1(D, A, B, C, X[ 9], T[10], 12) ;
        C = md5round1(C, D, A, B, X[10], T[11], 17) ;
        B = md5round1(B, C, D, A, X[11], T[12], 22) ;

        A = md5round1(A, B, C, D, X[12], T[13],  7) ;
        D = md5round1(D, A, B, C, X[13], T[14], 12) ;
        C = md5round1(C, D, A, B, X[14], T[15], 17) ;
        B = md5round1(B, C, D, A, X[15], T[16], 22) ;

                            /* ROUND 2 */
        A = md5round2(A, B, C, D, X[ 1], T[17],  5) ;
        D = md5round2(D, A, B, C, X[ 6], T[18],  9) ;
        C = md5round2(C, D, A, B, X[11], T[19], 14) ;
        B = md5round2(B, C, D, A, X[ 0], T[20], 20) ;

        A = md5round2(A, B, C, D, X[ 5], T[21],  5) ;
        D = md5round2(D, A, B, C, X[10], T[22],  9) ;
        C = md5round2(C, D, A, B, X[15], T[23], 14) ;
        B = md5round2(B, C, D, A, X[ 4], T[24], 20) ;

        A = md5round2(A, B, C, D, X[ 9], T[25],  5) ;
        D = md5round2(D, A, B, C, X[14], T[26],  9) ;
        C = md5round2(C, D, A, B, X[ 3], T[27], 14) ;
        B = md5round2(B, C, D, A, X[ 8], T[28], 20) ;

        A = md5round2(A, B, C, D, X[13], T[29],  5) ;
        D = md5round2(D, A, B, C, X[ 2], T[30],  9) ;
        C = md5round2(C, D, A, B, X[ 7], T[31], 14) ;
        B = md5round2(B, C, D, A, X[12], T[32], 20) ;

                            /* ROUND 3 */
        A = md5round3(A, B, C, D, X[ 5], T[33],  4) ;
        D = md5round3(D, A, B, C, X[ 8], T[34], 11) ;
        C = md5round3(C, D, A, B, X[11], T[35], 16) ;
        B = md5round3(B, C, D, A, X[14], T[36], 23) ;

        A = md5round3(A, B, C, D, X[ 1], T[37],  4) ;
        D = md5round3(D, A, B, C, X[ 4], T[38], 11) ;
        C = md5round3(C, D, A, B, X[ 7], T[39], 16) ;
        B = md5round3(B, C, D, A, X[10], T[40], 23) ;

        A = md5round3(A, B, C, D, X[13], T[41],  4) ;
        D = md5round3(D, A, B, C, X[ 0], T[42], 11) ;
        C = md5round3(C, D, A, B, X[ 3], T[43], 16) ;
        B = md5round3(B, C, D, A, X[ 6], T[44], 23) ;

        A = md5round3(A, B, C, D, X[ 9], T[45],  4) ;
        D = md5round3(D, A, B, C, X[12], T[46], 11) ;
        C = md5round3(C, D, A, B, X[15], T[47], 16) ;
        B = md5round3(B, C, D, A, X[ 2], T[48], 23) ;

                            /* ROUND 4 */
        A = md5round4(A, B, C, D, X[ 0], T[49],  6) ;
        D = md5round4(D, A, B, C, X[ 7], T[50], 10) ;
        C = md5round4(C, D, A, B, X[14], T[51], 15) ;
        B = md5round4(B, C, D, A, X[ 5], T[52], 21) ;

        A = md5round4(A, B, C, D, X[12], T[53],  6) ;
        D = md5round4(D, A, B, C, X[ 3], T[54], 10) ;
        C = md5round4(C, D, A, B, X[10], T[55], 15) ;
        B = md5round4(B, C, D, A, X[ 1], T[56], 21) ;

        A = md5round4(A, B, C, D, X[ 8], T[57],  6) ;
        D = md5round4(D, A, B, C, X[15], T[58], 10) ;
        C = md5round4(C, D, A, B, X[ 6], T[59], 15) ;
        B = md5round4(B, C, D, A, X[13], T[60], 21) ;

        A = md5round4(A, B, C, D, X[ 4], T[61],  6) ;
        D = md5round4(D, A, B, C, X[11], T[62], 10) ;
        C = md5round4(C, D, A, B, X[ 2], T[63], 15) ;
        B = md5round4(B, C, D, A, X[ 9], T[64], 21) ;

        A += AA;
        B += BB;
        C += CC;
        D += DD;

    } while (!done) ;

    /* Now load up the output buffer */
    out[0x0] = (uint8)(A >>  0) ;
    out[0x1] = (uint8)(A >>  8) ;
    out[0x2] = (uint8)(A >> 16) ;
    out[0x3] = (uint8)(A >> 24) ;

    out[0x4] = (uint8)(B >>  0) ;
    out[0x5] = (uint8)(B >>  8) ;
    out[0x6] = (uint8)(B >> 16) ;
    out[0x7] = (uint8)(B >> 24) ;

    out[0x8] = (uint8)(C >>  0) ;
    out[0x9] = (uint8)(C >>  8) ;
    out[0xa] = (uint8)(C >> 16) ;
    out[0xb] = (uint8)(C >> 24) ;

    out[0xc] = (uint8)(D >>  0) ;
    out[0xd] = (uint8)(D >>  8) ;
    out[0xe] = (uint8)(D >> 16) ;
    out[0xf] = (uint8)(D >> 24) ;
}

